
<html>
<head><script src="//archive.org/includes/analytics.js?v=cf34f82" type="text/javascript"></script>
<script type="text/javascript">window.addEventListener('DOMContentLoaded',function(){var v=archive_analytics.values;v.service='wb';v.server_name='wwwb-app203.us.archive.org';v.server_ms=473;archive_analytics.send_pageview({});});</script>
<script type="text/javascript" src="/_static/js/bundle-playback.js?v=1WaXNDFE" charset="utf-8"></script>
<script type="text/javascript" src="/_static/js/wombat.js?v=txqj7nKC" charset="utf-8"></script>
<script type="text/javascript">
  __wm.init("https://web.archive.org/web");
  __wm.wombat("https://allkeys.cc/","20220428024327","https://web.archive.org/","web","/_static/",
	      "1651113807");
</script>
<link rel="stylesheet" type="text/css" href="/_static/css/banner-styles.css?v=S1zqJCYt" />
<link rel="stylesheet" type="text/css" href="/_static/css/iconochive.css?v=qtvMKcIJ" />
<!-- End Wayback Rewrite JS Include -->

    <title>All Cryptocoin Private Keys</title>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=1585, initial-scale=0.8"/>
    <link rel="manifest" href="manifest.json">
</head>
<body><!-- BEGIN WAYBACK TOOLBAR INSERT -->
<script>__wm.rw(0);</script>
<div id="wm-ipp-base" lang="en" style="display:none;direction:ltr;">
<div id="wm-ipp" style="position:fixed;left:0;top:0;right:0;">
<div id="donato" style="position:relative;width:100%;">
  <div id="donato-base">
    <iframe id="donato-if" src="https://archive.org/includes/donate.php?as_page=1&amp;platform=wb&amp;referer=https%3A//web.archive.org/web/20220428024327/https%3A//allkeys.cc/"
	    scrolling="no" frameborder="0" style="width:100%; height:100%">
    </iframe>
  </div>
</div><div id="wm-ipp-inside">
  <div id="wm-toolbar" style="position:relative;display:flex;flex-flow:row nowrap;justify-content:space-between;">
    <div id="wm-logo" style="/*width:110px;*/padding-top:12px;">
      <a href="/web/" title="Wayback Machine home page"><img src="/_static/images/toolbar/wayback-toolbar-logo-200.png" srcset="/_static/images/toolbar/wayback-toolbar-logo-100.png, /_static/images/toolbar/wayback-toolbar-logo-150.png 1.5x, /_static/images/toolbar/wayback-toolbar-logo-200.png 2x" alt="Wayback Machine" style="width:100px" border="0" /></a>
    </div>
    <div class="c" style="display:flex;flex-flow:column nowrap;justify-content:space-between;flex:1;">
      <form class="u" style="display:flex;flex-direction:row;flex-wrap:nowrap;" target="_top" method="get" action="/web/submit" name="wmtb" id="wmtb"><input type="text" name="url" id="wmtbURL" value="https://allkeys.cc/" onfocus="this.focus();this.select();" style="flex:1;"/><input type="hidden" name="type" value="replay" /><input type="hidden" name="date" value="20220428024327" /><input type="submit" value="Go" />
      </form>
      <div style="display:flex;flex-flow:row nowrap;align-items:flex-end;">
                <div class="s" id="wm-nav-captures" style="flex:1;">
                    <a class="t" href="/web/20220428024327*/https://allkeys.cc/" title="See a list of every capture for this URL">7 captures</a>
          <div class="r" title="Timespan for captures of this URL">27 Sep 2021 - 01 Mar 2023</div>
          </div>
        <div class="k">
          <a href="" id="wm-graph-anchor">
            <div id="wm-ipp-sparkline" title="Explore captures for this URL" style="position: relative">
              <canvas id="wm-sparkline-canvas" width="700" height="27" border="0"></canvas>
            </div>
          </a>
        </div>
      </div>
    </div>
    <div class="n">
      <table>
        <tbody>
          <!-- NEXT/PREV MONTH NAV AND MONTH INDICATOR -->
          <tr class="m">
            <td class="b" nowrap="nowrap"><a href="https://web.archive.org/web/20211124234631/http://allkeys.cc/" title="24 Nov 2021"><strong>Nov</strong></a></td>
            <td class="c" id="displayMonthEl" title="You are here: 02:43:27 Apr 28, 2022">APR</td>
            <td class="f" nowrap="nowrap"><a href="https://web.archive.org/web/20220625000751/https://allkeys.cc/" title="25 Jun 2022"><strong>Jun</strong></a></td>
          </tr>
          <!-- NEXT/PREV CAPTURE NAV AND DAY OF MONTH INDICATOR -->
          <tr class="d">
            <td class="b" nowrap="nowrap"><a href="https://web.archive.org/web/20211124234631/http://allkeys.cc/" title="23:46:31 Nov 24, 2021"><img src="/_static/images/toolbar/wm_tb_prv_on.png" alt="Previous capture" width="14" height="16" border="0" /></a></td>
            <td class="c" id="displayDayEl" style="width:34px;font-size:22px;white-space:nowrap;" title="You are here: 02:43:27 Apr 28, 2022">28</td>
            <td class="f" nowrap="nowrap"><a href="https://web.archive.org/web/20220625000751/https://allkeys.cc/" title="00:07:51 Jun 25, 2022"><img src="/_static/images/toolbar/wm_tb_nxt_on.png" alt="Next capture" width="14" height="16" border="0" /></a></td>
          </tr>
          <!-- NEXT/PREV YEAR NAV AND YEAR INDICATOR -->
          <tr class="y">
            <td class="b" nowrap="nowrap">2021</td>
            <td class="c" id="displayYearEl" title="You are here: 02:43:27 Apr 28, 2022">2022</td>
            <td class="f" nowrap="nowrap">2023</td>
          </tr>
        </tbody>
      </table>
    </div>
    <div class="r" style="display:flex;flex-flow:column nowrap;align-items:flex-end;justify-content:space-between;">
      <div id="wm-btns" style="text-align:right;height:23px;">
                <span class="xxs">
          <div id="wm-save-snapshot-success">success</div>
          <div id="wm-save-snapshot-fail">fail</div>
          <a id="wm-save-snapshot-open" href="#" title="Share via My Web Archive" >
            <span class="iconochive-web"></span>
          </a>
          <a href="https://archive.org/account/login.php" title="Sign In" id="wm-sign-in">
            <span class="iconochive-person"></span>
          </a>
          <span id="wm-save-snapshot-in-progress" class="iconochive-web"></span>
        </span>
                <a class="xxs" href="http://faq.web.archive.org/" title="Get some help using the Wayback Machine" style="top:-6px;"><span class="iconochive-question" style="color:rgb(87,186,244);font-size:160%;"></span></a>
        <a id="wm-tb-close" href="#close" style="top:-2px;" title="Close the toolbar"><span class="iconochive-remove-circle" style="color:#888888;font-size:240%;"></span></a>
      </div>
      <div id="wm-share" class="xxs">
        <a href="/web/20220428024327/http://web.archive.org/screenshot/https://allkeys.cc/"
           id="wm-screenshot"
           title="screenshot">
          <span class="wm-icon-screen-shot"></span>
        </a>
        <a href="#" id="wm-video" title="video">
          <span class="iconochive-movies"></span>
        </a>
        <a id="wm-share-facebook" href="#" data-url="https://web.archive.org/web/20220428024327/https://allkeys.cc/" title="Share on Facebook" style="margin-right:5px;" target="_blank"><span class="iconochive-facebook" style="color:#3b5998;font-size:160%;"></span></a>
        <a id="wm-share-twitter" href="#" data-url="https://web.archive.org/web/20220428024327/https://allkeys.cc/" title="Share on Twitter" style="margin-right:5px;" target="_blank"><span class="iconochive-twitter" style="color:#1dcaff;font-size:160%;"></span></a>
      </div>
      <div style="padding-right:2px;text-align:right;white-space:nowrap;">
        <a id="wm-expand" class="wm-btn wm-closed" href="#expand" onclick="__wm.ex(event);return false;"><span id="wm-expand-icon" class="iconochive-down-solid"></span> <span class="xxs" style="font-size:80%;">About this capture</span></a>
      </div>
    </div>
  </div>
    <div id="wm-capinfo" style="border-top:1px solid #777;display:none; overflow: hidden">
        <div id="wm-capinfo-notice" source="api"></div>
                <div id="wm-capinfo-collected-by">
    <div style="background-color:#666;color:#fff;font-weight:bold;text-align:center">COLLECTED BY</div>
    <div style="padding:3px;position:relative" id="wm-collected-by-content">
            <div style="display:inline-block;vertical-align:top;width:50%;">
			<span class="c-logo" style="background-image:url(https://archive.org/services/img/archiveteam);"></span>
		Organization: <a style="color:#33f;" href="https://archive.org/details/archiveteam" target="_new"><span class="wm-title">Archive Team</span></a>
		<div style="max-height:75px;overflow:hidden;position:relative;">
	  <div style="position:absolute;top:0;left:0;width:100%;height:75px;background:linear-gradient(to bottom,rgba(255,255,255,0) 0%,rgba(255,255,255,0) 90%,rgba(255,255,255,255) 100%);"></div>
	  <img align=right src="http://archiveteam.org/images/e/e6/Archiveteam.jpg" width=200> Formed in 2009, the Archive Team (not to be confused with the archive.org Archive-It Team) is a rogue archivist collective dedicated to saving copies of rapidly dying or deleted websites for the sake of history and digital heritage. The group is 100% composed of volunteers and interested parties, and has expanded into a large amount of related projects for saving online and digital history.
<p>
History is littered with hundreds of conflicts over the future of a community, group, location or business that were "resolved" when one of the parties stepped ahead and destroyed what was there. With the original point of contention destroyed, the debates would fall to the wayside. Archive Team believes that by duplicated condemned data, the conversation and debate can continue, as well as the richness and insight gained by keeping the materials. Our projects have ranged in size from a single volunteer downloading the data to a small-but-critical site, to over 100 volunteers stepping forward to acquire terabytes of user-created data to save for future generations.
<p>
The main site for Archive Team is at <a href="http://www.archiveteam.org">archiveteam.org</a> and contains up to the date information on various projects, manifestos, plans and walkthroughs.
<p>
This collection contains the output of many Archive Team projects, both ongoing and completed. Thanks to the generous providing of disk space by the Internet Archive, multi-terabyte datasets can be made available, as well as in use by the <a href="http://archive.org/web/web.php">Wayback Machine</a>, providing a path back to lost websites and work. 
<p>
Our collection has grown to the point of having sub-collections for the type of data we acquire. If you are seeking to browse the contents of these collections, the Wayback Machine is the best first stop. Otherwise, you are free to dig into the stacks to see what you may find.
<p>
<b>The Archive Team Panic Downloads</b> are full pulldowns of currently extant websites, meant to serve as emergency backups for needed sites that are in danger of closing, or which will be missed dearly if suddenly lost due to hard drive crashes or server failures. 
<p>
	</div>
	      </div>
      <div style="display:inline-block;vertical-align:top;width:49%;">
			<span class="c-logo" style="background-image:url(https://archive.org/services/img/archiveteam_urls)"></span>
		<div>Collection: <a style="color:#33f;" href="https://archive.org/details/archiveteam_urls" target="_new"><span class="wm-title">Archive Team: URLs</span></a></div>
	      </div>
    </div>
    </div>
    <div id="wm-capinfo-timestamps">
    <div style="background-color:#666;color:#fff;font-weight:bold;text-align:center" title="Timestamps for the elements of this page">TIMESTAMPS</div>
    <div>
      <div id="wm-capresources" style="margin:0 5px 5px 5px;max-height:250px;overflow-y:scroll !important"></div>
      <div id="wm-capresources-loading" style="text-align:left;margin:0 20px 5px 5px;display:none"><img src="/_static/images/loading.gif" alt="loading" /></div>
    </div>
    </div>
  </div></div></div></div><div id="wm-ipp-print">The Wayback Machine - https://web.archive.org/web/20220428024327/https://allkeys.cc/</div>
<script type="text/javascript">//<![CDATA[
__wm.bt(700,27,25,2,"web","https://allkeys.cc/","20220428024327",1996,"/_static/",["/_static/css/banner-styles.css?v=S1zqJCYt","/_static/css/iconochive.css?v=qtvMKcIJ"], false);
  __wm.rw(1);
//]]></script>
<!-- END WAYBACK TOOLBAR INSERT -->
 
<script type="text/javascript">
// Array.prototype.map function is in the public domain.
// Production steps of ECMA-262, Edition 5, 15.4.4.19
// Reference: http://es5.github.com/#x15.4.4.19
if (!Array.prototype.map) {
    Array.prototype.map = function (callback, thisArg) {
        var T, A, k;
        if (this == null) {
            throw new TypeError(" this is null or not defined");
        }
        // 1. Let O be the result of calling ToObject passing the |this| value as the argument.
        var O = Object(this);
        // 2. Let lenValue be the result of calling the Get internal method of O with the argument "length".
        // 3. Let len be ToUint32(lenValue).
        var len = O.length >>> 0;
        // 4. If IsCallable(callback) is false, throw a TypeError exception.
        // See: http://es5.github.com/#x9.11
        if ({}.toString.call(callback) != "[object Function]") {
            throw new TypeError(callback + " is not a function");
        }
        // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
        if (thisArg) {
            T = thisArg;
        }
        // 6. Let A be a new array created as if by the expression new Array(len) where Array is
        // the standard built-in constructor with that name and len is the value of len.
        A = new Array(len);
        // 7. Let k be 0
        k = 0;
        // 8. Repeat, while k < len
        while (k < len) {
            var kValue, mappedValue;
            // a. Let Pk be ToString(k).
            //   This is implicit for LHS operands of the in operator
            // b. Let kPresent be the result of calling the HasProperty internal method of O with argument Pk.
            //   This step can be combined with c
            // c. If kPresent is true, then
            if (k in O) {
                // i. Let kValue be the result of calling the Get internal method of O with argument Pk.
                kValue = O[k];
                // ii. Let mappedValue be the result of calling the Call internal method of callback
                // with T as the this value and argument list containing kValue, k, and O.
                mappedValue = callback.call(T, kValue, k, O);
                // iii. Call the DefineOwnProperty internal method of A with arguments
                // Pk, Property Descriptor {Value: mappedValue, Writable: true, Enumerable: true, Configurable: true},
                // and false.
                // In browsers that support Object.defineProperty, use the following:
                // Object.defineProperty(A, Pk, { value: mappedValue, writable: true, enumerable: true, configurable: true });
                // For best browser support, use the following:
                A[k] = mappedValue;
            }
            // d. Increase k by 1.
            k++;
        }
        // 9. return A
        return A;
    };
}
    </script>
    <script type="text/javascript">
/*!
* Crypto-JS v2.5.4  Crypto.js
* http://code.google.com/p/crypto-js/
* Copyright (c) 2009-2013, Jeff Mott. All rights reserved.
* http://code.google.com/p/crypto-js/wiki/License
*/
if (typeof Crypto == "undefined" || !Crypto.util) {
    (function () {

        var base64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

        // Global Crypto object
        var Crypto = window.Crypto = {};

        // Crypto utilities
        var util = Crypto.util = {

            // Bit-wise rotate left
            rotl: function (n, b) {
                return (n << b) | (n >>> (32 - b));
            },

            // Bit-wise rotate right
            rotr: function (n, b) {
                return (n << (32 - b)) | (n >>> b);
            },

            // Swap big-endian to little-endian and vice versa
            endian: function (n) {

                // If number given, swap endian
                if (n.constructor == Number) {
                    return util.rotl(n, 8) & 0x00FF00FF |
                util.rotl(n, 24) & 0xFF00FF00;
                }

                // Else, assume array and swap all items
                for (var i = 0; i < n.length; i++)
                    n[i] = util.endian(n[i]);
                return n;

            },

            // Generate an array of any length of random bytes
            randomBytes: function (n) {
                for (var bytes = []; n > 0; n--)
                    bytes.push(Math.floor(Math.random() * 256));
                return bytes;
            },

            // Convert a byte array to big-endian 32-bit words
            bytesToWords: function (bytes) {
                for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)
                    words[b >>> 5] |= (bytes[i] & 0xFF) << (24 - b % 32);
                return words;
            },

            // Convert big-endian 32-bit words to a byte array
            wordsToBytes: function (words) {
                for (var bytes = [], b = 0; b < words.length * 32; b += 8)
                    bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
                return bytes;
            },

            // Convert a byte array to a hex string
            bytesToHex: function (bytes) {
                for (var hex = [], i = 0; i < bytes.length; i++) {
                    hex.push((bytes[i] >>> 4).toString(16));
                    hex.push((bytes[i] & 0xF).toString(16));
                }
                return hex.join("");
            },

            // Convert a hex string to a byte array
            hexToBytes: function (hex) {
                for (var bytes = [], c = 0; c < hex.length; c += 2)
                    bytes.push(parseInt(hex.substr(c, 2), 16));
                return bytes;
            },

            // Convert a byte array to a base-64 string
            bytesToBase64: function (bytes) {
                for (var base64 = [], i = 0; i < bytes.length; i += 3) {
                    var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
                    for (var j = 0; j < 4; j++) {
                        if (i * 8 + j * 6 <= bytes.length * 8)
                            base64.push(base64map.charAt((triplet >>> 6 * (3 - j)) & 0x3F));
                        else base64.push("=");
                    }
                }

                return base64.join("");
            },

            // Convert a base-64 string to a byte array
            base64ToBytes: function (base64) {
                // Remove non-base-64 characters
                base64 = base64.replace(/[^A-Z0-9+\/]/ig, "");

                for (var bytes = [], i = 0, imod4 = 0; i < base64.length; imod4 = ++i % 4) {
                    if (imod4 == 0) continue;
                    bytes.push(((base64map.indexOf(base64.charAt(i - 1)) & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2)) |
                    (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));
                }

                return bytes;
            }

        };

        // Crypto character encodings
        var charenc = Crypto.charenc = {};

        // UTF-8 encoding
        var UTF8 = charenc.UTF8 = {

            // Convert a string to a byte array
            stringToBytes: function (str) {
                return Binary.stringToBytes(unescape(encodeURIComponent(str)));
            },

            // Convert a byte array to a string
            bytesToString: function (bytes) {
                return decodeURIComponent(escape(Binary.bytesToString(bytes)));
            }

        };

        // Binary encoding
        var Binary = charenc.Binary = {

            // Convert a string to a byte array
            stringToBytes: function (str) {
                for (var bytes = [], i = 0; i < str.length; i++)
                    bytes.push(str.charCodeAt(i) & 0xFF);
                return bytes;
            },

            // Convert a byte array to a string
            bytesToString: function (bytes) {
                for (var str = [], i = 0; i < bytes.length; i++)
                    str.push(String.fromCharCode(bytes[i]));
                return str.join("");
            }

        };

    })();
}
    </script>
    <script type="text/javascript">
/*!
* Crypto-JS v2.5.4  SHA256.js
* http://code.google.com/p/crypto-js/
* Copyright (c) 2009-2013, Jeff Mott. All rights reserved.
* http://code.google.com/p/crypto-js/wiki/License
*/
(function () {

    // Shortcuts
    var C = Crypto,
        util = C.util,
        charenc = C.charenc,
        UTF8 = charenc.UTF8,
        Binary = charenc.Binary;

    // Constants
    var K = [0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
        0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
        0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
        0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
        0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
        0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
        0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
        0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
        0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
        0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
        0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
        0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
        0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
        0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
        0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
        0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2];

    // Public API
    var SHA256 = C.SHA256 = function (message, options) {
        var digestbytes = util.wordsToBytes(SHA256._sha256(message));
        return options && options.asBytes ? digestbytes :
        options && options.asString ? Binary.bytesToString(digestbytes) :
        util.bytesToHex(digestbytes);
    };

    // The core
    SHA256._sha256 = function (message) {

        // Convert to byte array
        if (message.constructor == String) message = UTF8.stringToBytes(message);
        /* else, assume byte array already */

        var m = util.bytesToWords(message),
        l = message.length * 8,
        H = [0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A,
                0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19],
        w = [],
        a, b, c, d, e, f, g, h, i, j,
        t1, t2;

        // Padding
        m[l >> 5] |= 0x80 << (24 - l % 32);
        m[((l + 64 >> 9) << 4) + 15] = l;

        for (var i = 0; i < m.length; i += 16) {

            a = H[0];
            b = H[1];
            c = H[2];
            d = H[3];
            e = H[4];
            f = H[5];
            g = H[6];
            h = H[7];

            for (var j = 0; j < 64; j++) {

                if (j < 16) w[j] = m[j + i];
                else {

                    var gamma0x = w[j - 15],
                gamma1x = w[j - 2],
                gamma0 = ((gamma0x << 25) | (gamma0x >>> 7)) ^
                            ((gamma0x << 14) | (gamma0x >>> 18)) ^
                            (gamma0x >>> 3),
                gamma1 = ((gamma1x << 15) | (gamma1x >>> 17)) ^
                            ((gamma1x << 13) | (gamma1x >>> 19)) ^
                            (gamma1x >>> 10);

                    w[j] = gamma0 + (w[j - 7] >>> 0) +
                    gamma1 + (w[j - 16] >>> 0);

                }

                var ch = e & f ^ ~e & g,
            maj = a & b ^ a & c ^ b & c,
            sigma0 = ((a << 30) | (a >>> 2)) ^
                        ((a << 19) | (a >>> 13)) ^
                        ((a << 10) | (a >>> 22)),
            sigma1 = ((e << 26) | (e >>> 6)) ^
                        ((e << 21) | (e >>> 11)) ^
                        ((e << 7) | (e >>> 25));


                t1 = (h >>> 0) + sigma1 + ch + (K[j]) + (w[j] >>> 0);
                t2 = sigma0 + maj;

                h = g;
                g = f;
                f = e;
                e = (d + t1) >>> 0;
                d = c;
                c = b;
                b = a;
                a = (t1 + t2) >>> 0;

            }

            H[0] += a;
            H[1] += b;
            H[2] += c;
            H[3] += d;
            H[4] += e;
            H[5] += f;
            H[6] += g;
            H[7] += h;

        }

        return H;

    };

    // Package private blocksize
    SHA256._blocksize = 16;

    SHA256._digestsize = 32;

})();
    </script>
    <script type="text/javascript">
/*!
* Crypto-JS v2.5.4  PBKDF2.js
* http://code.google.com/p/crypto-js/
* Copyright (c) 2009-2013, Jeff Mott. All rights reserved.
* http://code.google.com/p/crypto-js/wiki/License
*/
(function () {

    // Shortcuts
    var C = Crypto,
        util = C.util,
        charenc = C.charenc,
        UTF8 = charenc.UTF8,
        Binary = charenc.Binary;

    C.PBKDF2 = function (password, salt, keylen, options) {

        // Convert to byte arrays
        if (password.constructor == String) password = UTF8.stringToBytes(password);
        if (salt.constructor == String) salt = UTF8.stringToBytes(salt);
        /* else, assume byte arrays already */

        // Defaults
        var hasher = options && options.hasher || C.SHA1,
            iterations = options && options.iterations || 1;

        // Pseudo-random function
        function PRF(password, salt) {
            return C.HMAC(hasher, salt, password, { asBytes: true });
        }

        // Generate key
        var derivedKeyBytes = [],
            blockindex = 1;
        while (derivedKeyBytes.length < keylen) {
            var block = PRF(password, salt.concat(util.wordsToBytes([blockindex])));
            for (var u = block, i = 1; i < iterations; i++) {
                u = PRF(password, u);
                for (var j = 0; j < block.length; j++) block[j] ^= u[j];
            }
            derivedKeyBytes = derivedKeyBytes.concat(block);
            blockindex++;
        }

        // Truncate excess bytes
        derivedKeyBytes.length = keylen;

        return options && options.asBytes ? derivedKeyBytes :
        options && options.asString ? Binary.bytesToString(derivedKeyBytes) :
        util.bytesToHex(derivedKeyBytes);

    };

})();
    </script>
    <script type="text/javascript">
/*!
* Crypto-JS v2.5.4  HMAC.js
* http://code.google.com/p/crypto-js/
* Copyright (c) 2009-2013, Jeff Mott. All rights reserved.
* http://code.google.com/p/crypto-js/wiki/License
*/
(function () {

    // Shortcuts
    var C = Crypto,
        util = C.util,
        charenc = C.charenc,
        UTF8 = charenc.UTF8,
        Binary = charenc.Binary;

    C.HMAC = function (hasher, message, key, options) {

        // Convert to byte arrays
        if (message.constructor == String) message = UTF8.stringToBytes(message);
        if (key.constructor == String) key = UTF8.stringToBytes(key);
        /* else, assume byte arrays already */

        // Allow arbitrary length keys
        if (key.length > hasher._blocksize * 4)
            key = hasher(key, { asBytes: true });

        // XOR keys with pad constants
        var okey = key.slice(0),
            ikey = key.slice(0);
        for (var i = 0; i < hasher._blocksize * 4; i++) {
            okey[i] ^= 0x5C;
            ikey[i] ^= 0x36;
        }

        var hmacbytes = hasher(okey.concat(hasher(ikey.concat(message), { asBytes: true })), { asBytes: true });

        return options && options.asBytes ? hmacbytes :
        options && options.asString ? Binary.bytesToString(hmacbytes) :
        util.bytesToHex(hmacbytes);

    };

})();
    </script>
    <script type="text/javascript">
/*!
* Crypto-JS v2.5.4  AES.js
* http://code.google.com/p/crypto-js/
* Copyright (c) 2009-2013, Jeff Mott. All rights reserved.
* http://code.google.com/p/crypto-js/wiki/License
*/
(function () {

    // Shortcuts
    var C = Crypto,
        util = C.util,
        charenc = C.charenc,
        UTF8 = charenc.UTF8;

    // Precomputed SBOX
    var SBOX = [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,
            0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
            0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,
            0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
            0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,
            0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
            0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,
            0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
            0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,
            0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
            0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,
            0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
            0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,
            0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
            0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,
            0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
            0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,
            0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
            0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,
            0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
            0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,
            0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
            0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,
            0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
            0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,
            0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
            0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,
            0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
            0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,
            0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
            0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,
            0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16];

    // Compute inverse SBOX lookup table
    for (var INVSBOX = [], i = 0; i < 256; i++) INVSBOX[SBOX[i]] = i;

    // Compute multiplication in GF(2^8) lookup tables
    var MULT2 = [],
        MULT3 = [],
        MULT9 = [],
        MULTB = [],
        MULTD = [],
        MULTE = [];

    function xtime(a, b) {
        for (var result = 0, i = 0; i < 8; i++) {
            if (b & 1) result ^= a;
            var hiBitSet = a & 0x80;
            a = (a << 1) & 0xFF;
            if (hiBitSet) a ^= 0x1b;
            b >>>= 1;
        }
        return result;
    }

    for (var i = 0; i < 256; i++) {
        MULT2[i] = xtime(i, 2);
        MULT3[i] = xtime(i, 3);
        MULT9[i] = xtime(i, 9);
        MULTB[i] = xtime(i, 0xB);
        MULTD[i] = xtime(i, 0xD);
        MULTE[i] = xtime(i, 0xE);
    }

    // Precomputed RCon lookup
    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

    // Inner state
    var state = [[], [], [], []],
        keylength,
        nrounds,
        keyschedule;

    var AES = C.AES = {

        /**
        * Public API
        */

        encrypt: function (message, password, options) {

            options = options || {};

            // Determine mode
            var mode = options.mode || new C.mode.OFB;

            // Allow mode to override options
            if (mode.fixOptions) mode.fixOptions(options);

            var

            // Convert to bytes if message is a string
        m = (
            message.constructor == String ?
            UTF8.stringToBytes(message) :
            message
        ),

            // Generate random IV
        iv = options.iv || util.randomBytes(AES._blocksize * 4),

            // Generate key
        k = (
            password.constructor == String ?
            // Derive key from pass-phrase
            C.PBKDF2(password, iv, 32, { asBytes: true }) :
            // else, assume byte array representing cryptographic key
            password
        );

            // Encrypt
            AES._init(k);
            mode.encrypt(AES, m, iv);

            // Return ciphertext
            m = options.iv ? m : iv.concat(m);
            return (options && options.asBytes) ? m : util.bytesToBase64(m);

        },

        decrypt: function (ciphertext, password, options) {

            options = options || {};

            // Determine mode
            var mode = options.mode || new C.mode.OFB;

            // Allow mode to override options
            if (mode.fixOptions) mode.fixOptions(options);

            var

            // Convert to bytes if ciphertext is a string
        c = (
            ciphertext.constructor == String ?
            util.base64ToBytes(ciphertext) :
            ciphertext
        ),

            // Separate IV and message
        iv = options.iv || c.splice(0, AES._blocksize * 4),

            // Generate key
        k = (
            password.constructor == String ?
            // Derive key from pass-phrase
            C.PBKDF2(password, iv, 32, { asBytes: true }) :
            // else, assume byte array representing cryptographic key
            password
        );

            // Decrypt
            AES._init(k);
            mode.decrypt(AES, c, iv);

            // Return plaintext
            return (options && options.asBytes) ? c : UTF8.bytesToString(c);

        },


        /**
        * Package private methods and properties
        */

        _blocksize: 4,

        _encryptblock: function (m, offset) {

            // Set input
            for (var row = 0; row < AES._blocksize; row++) {
                for (var col = 0; col < 4; col++)
                    state[row][col] = m[offset + col * 4 + row];
            }

            // Add round key
            for (var row = 0; row < 4; row++) {
                for (var col = 0; col < 4; col++)
                    state[row][col] ^= keyschedule[col][row];
            }

            for (var round = 1; round < nrounds; round++) {

                // Sub bytes
                for (var row = 0; row < 4; row++) {
                    for (var col = 0; col < 4; col++)
                        state[row][col] = SBOX[state[row][col]];
                }

                // Shift rows
                state[1].push(state[1].shift());
                state[2].push(state[2].shift());
                state[2].push(state[2].shift());
                state[3].unshift(state[3].pop());

                // Mix columns
                for (var col = 0; col < 4; col++) {

                    var s0 = state[0][col],
                s1 = state[1][col],
                s2 = state[2][col],
                s3 = state[3][col];

                    state[0][col] = MULT2[s0] ^ MULT3[s1] ^ s2 ^ s3;
                    state[1][col] = s0 ^ MULT2[s1] ^ MULT3[s2] ^ s3;
                    state[2][col] = s0 ^ s1 ^ MULT2[s2] ^ MULT3[s3];
                    state[3][col] = MULT3[s0] ^ s1 ^ s2 ^ MULT2[s3];

                }

                // Add round key
                for (var row = 0; row < 4; row++) {
                    for (var col = 0; col < 4; col++)
                        state[row][col] ^= keyschedule[round * 4 + col][row];
                }

            }

            // Sub bytes
            for (var row = 0; row < 4; row++) {
                for (var col = 0; col < 4; col++)
                    state[row][col] = SBOX[state[row][col]];
            }

            // Shift rows
            state[1].push(state[1].shift());
            state[2].push(state[2].shift());
            state[2].push(state[2].shift());
            state[3].unshift(state[3].pop());

            // Add round key
            for (var row = 0; row < 4; row++) {
                for (var col = 0; col < 4; col++)
                    state[row][col] ^= keyschedule[nrounds * 4 + col][row];
            }

            // Set output
            for (var row = 0; row < AES._blocksize; row++) {
                for (var col = 0; col < 4; col++)
                    m[offset + col * 4 + row] = state[row][col];
            }

        },

        _decryptblock: function (c, offset) {

            // Set input
            for (var row = 0; row < AES._blocksize; row++) {
                for (var col = 0; col < 4; col++)
                    state[row][col] = c[offset + col * 4 + row];
            }

            // Add round key
            for (var row = 0; row < 4; row++) {
                for (var col = 0; col < 4; col++)
                    state[row][col] ^= keyschedule[nrounds * 4 + col][row];
            }

            for (var round = 1; round < nrounds; round++) {

                // Inv shift rows
                state[1].unshift(state[1].pop());
                state[2].push(state[2].shift());
                state[2].push(state[2].shift());
                state[3].push(state[3].shift());

                // Inv sub bytes
                for (var row = 0; row < 4; row++) {
                    for (var col = 0; col < 4; col++)
                        state[row][col] = INVSBOX[state[row][col]];
                }

                // Add round key
                for (var row = 0; row < 4; row++) {
                    for (var col = 0; col < 4; col++)
                        state[row][col] ^= keyschedule[(nrounds - round) * 4 + col][row];
                }

                // Inv mix columns
                for (var col = 0; col < 4; col++) {

                    var s0 = state[0][col],
                s1 = state[1][col],
                s2 = state[2][col],
                s3 = state[3][col];

                    state[0][col] = MULTE[s0] ^ MULTB[s1] ^ MULTD[s2] ^ MULT9[s3];
                    state[1][col] = MULT9[s0] ^ MULTE[s1] ^ MULTB[s2] ^ MULTD[s3];
                    state[2][col] = MULTD[s0] ^ MULT9[s1] ^ MULTE[s2] ^ MULTB[s3];
                    state[3][col] = MULTB[s0] ^ MULTD[s1] ^ MULT9[s2] ^ MULTE[s3];

                }

            }

            // Inv shift rows
            state[1].unshift(state[1].pop());
            state[2].push(state[2].shift());
            state[2].push(state[2].shift());
            state[3].push(state[3].shift());

            // Inv sub bytes
            for (var row = 0; row < 4; row++) {
                for (var col = 0; col < 4; col++)
                    state[row][col] = INVSBOX[state[row][col]];
            }

            // Add round key
            for (var row = 0; row < 4; row++) {
                for (var col = 0; col < 4; col++)
                    state[row][col] ^= keyschedule[col][row];
            }

            // Set output
            for (var row = 0; row < AES._blocksize; row++) {
                for (var col = 0; col < 4; col++)
                    c[offset + col * 4 + row] = state[row][col];
            }

        },


        /**
        * Private methods
        */

        _init: function (k) {
            keylength = k.length / 4;
            nrounds = keylength + 6;
            AES._keyexpansion(k);
        },

        // Generate a key schedule
        _keyexpansion: function (k) {

            keyschedule = [];

            for (var row = 0; row < keylength; row++) {
                keyschedule[row] = [
            k[row * 4],
            k[row * 4 + 1],
            k[row * 4 + 2],
            k[row * 4 + 3]
        ];
            }

            for (var row = keylength; row < AES._blocksize * (nrounds + 1); row++) {

                var temp = [
            keyschedule[row - 1][0],
            keyschedule[row - 1][1],
            keyschedule[row - 1][2],
            keyschedule[row - 1][3]
        ];

                if (row % keylength == 0) {

                    // Rot word
                    temp.push(temp.shift());

                    // Sub word
                    temp[0] = SBOX[temp[0]];
                    temp[1] = SBOX[temp[1]];
                    temp[2] = SBOX[temp[2]];
                    temp[3] = SBOX[temp[3]];

                    temp[0] ^= RCON[row / keylength];

                } else if (keylength > 6 && row % keylength == 4) {

                    // Sub word
                    temp[0] = SBOX[temp[0]];
                    temp[1] = SBOX[temp[1]];
                    temp[2] = SBOX[temp[2]];
                    temp[3] = SBOX[temp[3]];

                }

                keyschedule[row] = [
            keyschedule[row - keylength][0] ^ temp[0],
            keyschedule[row - keylength][1] ^ temp[1],
            keyschedule[row - keylength][2] ^ temp[2],
            keyschedule[row - keylength][3] ^ temp[3]
        ];

            }

        }

    };

})();
    </script>
    <script type="text/javascript">
/*!
* Crypto-JS 2.5.4 BlockModes.js
* contribution from Simon Greatrix
*/

(function (C) {

    // Create pad namespace
    var C_pad = C.pad = {};

    // Calculate the number of padding bytes required.
    function _requiredPadding(cipher, message) {
        var blockSizeInBytes = cipher._blocksize * 4;
        var reqd = blockSizeInBytes - message.length % blockSizeInBytes;
        return reqd;
    }

    // Remove padding when the final byte gives the number of padding bytes.
    var _unpadLength = function (cipher, message, alg, padding) {
        var pad = message.pop();
        if (pad == 0) {
            throw new Error("Invalid zero-length padding specified for " + alg
            + ". Wrong cipher specification or key used?");
        }
        var maxPad = cipher._blocksize * 4;
        if (pad > maxPad) {
            throw new Error("Invalid padding length of " + pad
            + " specified for " + alg
            + ". Wrong cipher specification or key used?");
        }
        for (var i = 1; i < pad; i++) {
            var b = message.pop();
            if (padding != undefined && padding != b) {
                throw new Error("Invalid padding byte of 0x" + b.toString(16)
                + " specified for " + alg
                + ". Wrong cipher specification or key used?");
            }
        }
    };

    // No-operation padding, used for stream ciphers
    C_pad.NoPadding = {
        pad: function (cipher, message) { },
        unpad: function (cipher, message) { }
    };

    // Zero Padding.
    //
    // If the message is not an exact number of blocks, the final block is
    // completed with 0x00 bytes. There is no unpadding.
    C_pad.ZeroPadding = {
        pad: function (cipher, message) {
            var blockSizeInBytes = cipher._blocksize * 4;
            var reqd = message.length % blockSizeInBytes;
            if (reqd != 0) {
                for (reqd = blockSizeInBytes - reqd; reqd > 0; reqd--) {
                    message.push(0x00);
                }
            }
        },

        unpad: function (cipher, message) {
            while (message[message.length - 1] == 0) {
                message.pop();
            }
        }
    };

    // ISO/IEC 7816-4 padding.
    //
    // Pads the plain text with an 0x80 byte followed by as many 0x00
    // bytes are required to complete the block.
    C_pad.iso7816 = {
        pad: function (cipher, message) {
            var reqd = _requiredPadding(cipher, message);
            message.push(0x80);
            for (; reqd > 1; reqd--) {
                message.push(0x00);
            }
        },

        unpad: function (cipher, message) {
            var padLength;
            for (padLength = cipher._blocksize * 4; padLength > 0; padLength--) {
                var b = message.pop();
                if (b == 0x80) return;
                if (b != 0x00) {
                    throw new Error("ISO-7816 padding byte must be 0, not 0x" + b.toString(16) + ". Wrong cipher specification or key used?");
                }
            }
            throw new Error("ISO-7816 padded beyond cipher block size. Wrong cipher specification or key used?");
        }
    };

    // ANSI X.923 padding
    //
    // The final block is padded with zeros except for the last byte of the
    // last block which contains the number of padding bytes.
    C_pad.ansix923 = {
        pad: function (cipher, message) {
            var reqd = _requiredPadding(cipher, message);
            for (var i = 1; i < reqd; i++) {
                message.push(0x00);
            }
            message.push(reqd);
        },

        unpad: function (cipher, message) {
            _unpadLength(cipher, message, "ANSI X.923", 0);
        }
    };

    // ISO 10126
    //
    // The final block is padded with random bytes except for the last
    // byte of the last block which contains the number of padding bytes.
    C_pad.iso10126 = {
        pad: function (cipher, message) {
            var reqd = _requiredPadding(cipher, message);
            for (var i = 1; i < reqd; i++) {
                message.push(Math.floor(Math.random() * 256));
            }
            message.push(reqd);
        },

        unpad: function (cipher, message) {
            _unpadLength(cipher, message, "ISO 10126", undefined);
        }
    };

    // PKCS7 padding
    //
    // PKCS7 is described in RFC 5652. Padding is in whole bytes. The
    // value of each added byte is the number of bytes that are added,
    // i.e. N bytes, each of value N are added.
    C_pad.pkcs7 = {
        pad: function (cipher, message) {
            var reqd = _requiredPadding(cipher, message);
            for (var i = 0; i < reqd; i++) {
                message.push(reqd);
            }
        },

        unpad: function (cipher, message) {
            _unpadLength(cipher, message, "PKCS 7", message[message.length - 1]);
        }
    };

    // Create mode namespace
    var C_mode = C.mode = {};

    /**
    * Mode base "class".
    */
    var Mode = C_mode.Mode = function (padding) {
        if (padding) {
            this._padding = padding;
        }
    };

    Mode.prototype = {
        encrypt: function (cipher, m, iv) {
            this._padding.pad(cipher, m);
            this._doEncrypt(cipher, m, iv);
        },

        decrypt: function (cipher, m, iv) {
            this._doDecrypt(cipher, m, iv);
            this._padding.unpad(cipher, m);
        },

        // Default padding
        _padding: C_pad.iso7816
    };


    /**
    * Electronic Code Book mode.
    *
    * ECB applies the cipher directly against each block of the input.
    *
    * ECB does not require an initialization vector.
    */
    var ECB = C_mode.ECB = function () {
        // Call parent constructor
        Mode.apply(this, arguments);
    };

    // Inherit from Mode
    var ECB_prototype = ECB.prototype = new Mode;

    // Concrete steps for Mode template
    ECB_prototype._doEncrypt = function (cipher, m, iv) {
        var blockSizeInBytes = cipher._blocksize * 4;
        // Encrypt each block
        for (var offset = 0; offset < m.length; offset += blockSizeInBytes) {
            cipher._encryptblock(m, offset);
        }
    };
    ECB_prototype._doDecrypt = function (cipher, c, iv) {
        var blockSizeInBytes = cipher._blocksize * 4;
        // Decrypt each block
        for (var offset = 0; offset < c.length; offset += blockSizeInBytes) {
            cipher._decryptblock(c, offset);
        }
    };

    // ECB never uses an IV
    ECB_prototype.fixOptions = function (options) {
        options.iv = [];
    };


    /**
    * Cipher block chaining
    *
    * The first block is XORed with the IV. Subsequent blocks are XOR with the
    * previous cipher output.
    */
    var CBC = C_mode.CBC = function () {
        // Call parent constructor
        Mode.apply(this, arguments);
    };

    // Inherit from Mode
    var CBC_prototype = CBC.prototype = new Mode;

    // Concrete steps for Mode template
    CBC_prototype._doEncrypt = function (cipher, m, iv) {
        var blockSizeInBytes = cipher._blocksize * 4;

        // Encrypt each block
        for (var offset = 0; offset < m.length; offset += blockSizeInBytes) {
            if (offset == 0) {
                // XOR first block using IV
                for (var i = 0; i < blockSizeInBytes; i++)
                    m[i] ^= iv[i];
            } else {
                // XOR this block using previous crypted block
                for (var i = 0; i < blockSizeInBytes; i++)
                    m[offset + i] ^= m[offset + i - blockSizeInBytes];
            }
            // Encrypt block
            cipher._encryptblock(m, offset);
        }
    };
    CBC_prototype._doDecrypt = function (cipher, c, iv) {
        var blockSizeInBytes = cipher._blocksize * 4;

        // At the start, the previously crypted block is the IV
        var prevCryptedBlock = iv;

        // Decrypt each block
        for (var offset = 0; offset < c.length; offset += blockSizeInBytes) {
            // Save this crypted block
            var thisCryptedBlock = c.slice(offset, offset + blockSizeInBytes);
            // Decrypt block
            cipher._decryptblock(c, offset);
            // XOR decrypted block using previous crypted block
            for (var i = 0; i < blockSizeInBytes; i++) {
                c[offset + i] ^= prevCryptedBlock[i];
            }
            prevCryptedBlock = thisCryptedBlock;
        }
    };


    /**
    * Cipher feed back
    *
    * The cipher output is XORed with the plain text to produce the cipher output,
    * which is then fed back into the cipher to produce a bit pattern to XOR the
    * next block with.
    *
    * This is a stream cipher mode and does not require padding.
    */
    var CFB = C_mode.CFB = function () {
        // Call parent constructor
        Mode.apply(this, arguments);
    };

    // Inherit from Mode
    var CFB_prototype = CFB.prototype = new Mode;

    // Override padding
    CFB_prototype._padding = C_pad.NoPadding;

    // Concrete steps for Mode template
    CFB_prototype._doEncrypt = function (cipher, m, iv) {
        var blockSizeInBytes = cipher._blocksize * 4,
    keystream = iv.slice(0);

        // Encrypt each byte
        for (var i = 0; i < m.length; i++) {

            var j = i % blockSizeInBytes;
            if (j == 0) cipher._encryptblock(keystream, 0);

            m[i] ^= keystream[j];
            keystream[j] = m[i];
        }
    };
    CFB_prototype._doDecrypt = function (cipher, c, iv) {
        var blockSizeInBytes = cipher._blocksize * 4,
            keystream = iv.slice(0);

        // Encrypt each byte
        for (var i = 0; i < c.length; i++) {

            var j = i % blockSizeInBytes;
            if (j == 0) cipher._encryptblock(keystream, 0);

            var b = c[i];
            c[i] ^= keystream[j];
            keystream[j] = b;
        }
    };


    /**
    * Output feed back
    *
    * The cipher repeatedly encrypts its own output. The output is XORed with the
    * plain text to produce the cipher text.
    *
    * This is a stream cipher mode and does not require padding.
    */
    var OFB = C_mode.OFB = function () {
        // Call parent constructor
        Mode.apply(this, arguments);
    };

    // Inherit from Mode
    var OFB_prototype = OFB.prototype = new Mode;

    // Override padding
    OFB_prototype._padding = C_pad.NoPadding;

    // Concrete steps for Mode template
    OFB_prototype._doEncrypt = function (cipher, m, iv) {

        var blockSizeInBytes = cipher._blocksize * 4,
            keystream = iv.slice(0);

        // Encrypt each byte
        for (var i = 0; i < m.length; i++) {

            // Generate keystream
            if (i % blockSizeInBytes == 0)
                cipher._encryptblock(keystream, 0);

            // Encrypt byte
            m[i] ^= keystream[i % blockSizeInBytes];

        }
    };
    OFB_prototype._doDecrypt = OFB_prototype._doEncrypt;

    /**
    * Counter
    * @author Gergely Risko
    *
    * After every block the last 4 bytes of the IV is increased by one
    * with carry and that IV is used for the next block.
    *
    * This is a stream cipher mode and does not require padding.
    */
    var CTR = C_mode.CTR = function () {
        // Call parent constructor
        Mode.apply(this, arguments);
    };

    // Inherit from Mode
    var CTR_prototype = CTR.prototype = new Mode;

    // Override padding
    CTR_prototype._padding = C_pad.NoPadding;

    CTR_prototype._doEncrypt = function (cipher, m, iv) {
        var blockSizeInBytes = cipher._blocksize * 4;
        var counter = iv.slice(0);

        for (var i = 0; i < m.length; ) {
            // do not lose iv
            var keystream = counter.slice(0);

            // Generate keystream for next block
            cipher._encryptblock(keystream, 0);

            // XOR keystream with block
            for (var j = 0; i < m.length && j < blockSizeInBytes; j++, i++) {
                m[i] ^= keystream[j];
            }

            // Increase counter
            if (++(counter[blockSizeInBytes - 1]) == 256) {
                counter[blockSizeInBytes - 1] = 0;
                if (++(counter[blockSizeInBytes - 2]) == 256) {
                    counter[blockSizeInBytes - 2] = 0;
                    if (++(counter[blockSizeInBytes - 3]) == 256) {
                        counter[blockSizeInBytes - 3] = 0;
                        ++(counter[blockSizeInBytes - 4]);
                    }
                }
            }
        }
    };
    CTR_prototype._doDecrypt = CTR_prototype._doEncrypt;

})(Crypto);
    </script>
    <script type="text/javascript">
/*!
* Crypto-JS v2.0.0  RIPEMD-160
* http://code.google.com/p/crypto-js/
* Copyright (c) 2009, Jeff Mott. All rights reserved.
* http://code.google.com/p/crypto-js/wiki/License
*
* A JavaScript implementation of the RIPEMD-160 Algorithm
* Version 2.2 Copyright Jeremy Lin, Paul Johnston 2000 - 2009.
* Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
* Distributed under the BSD License
* See http://pajhome.org.uk/crypt/md5 for details.
* Also http://www.ocf.berkeley.edu/~jjlin/jsotp/
* Ported to Crypto-JS by Stefan Thomas.
*/

(function () {
    // Shortcuts
    var C = Crypto,
    util = C.util,
    charenc = C.charenc,
    UTF8 = charenc.UTF8,
    Binary = charenc.Binary;

    // Convert a byte array to little-endian 32-bit words
    util.bytesToLWords = function (bytes) {

        var output = Array(bytes.length >> 2);
        for (var i = 0; i < output.length; i++)
            output[i] = 0;
        for (var i = 0; i < bytes.length * 8; i += 8)
            output[i >> 5] |= (bytes[i / 8] & 0xFF) << (i % 32);
        return output;
    };

    // Convert little-endian 32-bit words to a byte array
    util.lWordsToBytes = function (words) {
        var output = [];
        for (var i = 0; i < words.length * 32; i += 8)
            output.push((words[i >> 5] >>> (i % 32)) & 0xff);
        return output;
    };

    // Public API
    var RIPEMD160 = C.RIPEMD160 = function (message, options) {
        var digestbytes = util.lWordsToBytes(RIPEMD160._rmd160(message));
        return options && options.asBytes ? digestbytes :
            options && options.asString ? Binary.bytesToString(digestbytes) :
            util.bytesToHex(digestbytes);
    };

    // The core
    RIPEMD160._rmd160 = function (message) {
        // Convert to byte array
        if (message.constructor == String) message = UTF8.stringToBytes(message);

        var x = util.bytesToLWords(message),
            len = message.length * 8;

        /* append padding */
        x[len >> 5] |= 0x80 << (len % 32);
        x[(((len + 64) >>> 9) << 4) + 14] = len;

        var h0 = 0x67452301;
        var h1 = 0xefcdab89;
        var h2 = 0x98badcfe;
        var h3 = 0x10325476;
        var h4 = 0xc3d2e1f0;

        for (var i = 0; i < x.length; i += 16) {
            var T;
            var A1 = h0, B1 = h1, C1 = h2, D1 = h3, E1 = h4;
            var A2 = h0, B2 = h1, C2 = h2, D2 = h3, E2 = h4;
            for (var j = 0; j <= 79; ++j) {
                T = safe_add(A1, rmd160_f(j, B1, C1, D1));
                T = safe_add(T, x[i + rmd160_r1[j]]);
                T = safe_add(T, rmd160_K1(j));
                T = safe_add(bit_rol(T, rmd160_s1[j]), E1);
                A1 = E1; E1 = D1; D1 = bit_rol(C1, 10); C1 = B1; B1 = T;
                T = safe_add(A2, rmd160_f(79 - j, B2, C2, D2));
                T = safe_add(T, x[i + rmd160_r2[j]]);
                T = safe_add(T, rmd160_K2(j));
                T = safe_add(bit_rol(T, rmd160_s2[j]), E2);
                A2 = E2; E2 = D2; D2 = bit_rol(C2, 10); C2 = B2; B2 = T;
            }
            T = safe_add(h1, safe_add(C1, D2));
            h1 = safe_add(h2, safe_add(D1, E2));
            h2 = safe_add(h3, safe_add(E1, A2));
            h3 = safe_add(h4, safe_add(A1, B2));
            h4 = safe_add(h0, safe_add(B1, C2));
            h0 = T;
        }
        return [h0, h1, h2, h3, h4];
    }

    function rmd160_f(j, x, y, z) {
        return (0 <= j && j <= 15) ? (x ^ y ^ z) :
            (16 <= j && j <= 31) ? (x & y) | (~x & z) :
            (32 <= j && j <= 47) ? (x | ~y) ^ z :
            (48 <= j && j <= 63) ? (x & z) | (y & ~z) :
            (64 <= j && j <= 79) ? x ^ (y | ~z) :
            "rmd160_f: j out of range";
    }
    function rmd160_K1(j) {
        return (0 <= j && j <= 15) ? 0x00000000 :
            (16 <= j && j <= 31) ? 0x5a827999 :
            (32 <= j && j <= 47) ? 0x6ed9eba1 :
            (48 <= j && j <= 63) ? 0x8f1bbcdc :
            (64 <= j && j <= 79) ? 0xa953fd4e :
            "rmd160_K1: j out of range";
    }
    function rmd160_K2(j) {
        return (0 <= j && j <= 15) ? 0x50a28be6 :
            (16 <= j && j <= 31) ? 0x5c4dd124 :
            (32 <= j && j <= 47) ? 0x6d703ef3 :
            (48 <= j && j <= 63) ? 0x7a6d76e9 :
            (64 <= j && j <= 79) ? 0x00000000 :
            "rmd160_K2: j out of range";
    }
    var rmd160_r1 = [
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
        7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
        3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
        1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
        4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
    ];
    var rmd160_r2 = [
        5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
        6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
        15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
        8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
        12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
    ];
    var rmd160_s1 = [
        11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
        7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
        11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
        11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
        9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
    ];
    var rmd160_s2 = [
        8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
        9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
        9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
        15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
        8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
    ];

    /*
    * Add integers, wrapping at 2^32. This uses 16-bit operations internally
    * to work around bugs in some JS interpreters.
    */
    function safe_add(x, y) {
        var lsw = (x & 0xFFFF) + (y & 0xFFFF);
        var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
        return (msw << 16) | (lsw & 0xFFFF);
    }

    /*
    * Bitwise rotate a 32-bit number to the left.
    */
    function bit_rol(num, cnt) {
        return (num << cnt) | (num >>> (32 - cnt));
    }
})();
</script>
<script type="text/javascript">

(function () {
var sr = window.SecureRandom = function () { };

    // Properties
    sr.state;
    sr.pool;
    sr.pptr;

    // Pool size must be a multiple of 4 and greater than 32.
    // An array of bytes the size of the pool will be passed to init()
    sr.poolSize = 256;

    // --- object methods ---

    // public method
    // ba: byte array
    sr.prototype.nextBytes = function (ba) {
        var i;
        if (window.crypto && window.crypto.getRandomValues && window.Uint8Array) {
            try {
                var rvBytes = new Uint8Array(ba.length);
                window.crypto.getRandomValues(rvBytes);
                for (i = 0; i < ba.length; ++i)
                    ba[i] = sr.getByte() ^ rvBytes[i];
                return;
            } catch (e) {
                alert(e);
            }
        }
        for (i = 0; i < ba.length; ++i) ba[i] = sr.getByte();
    };


    // --- static methods ---

    // Mix in the current time (w/milliseconds) into the pool
    // NOTE: this method should be called from body click/keypress event handlers to increase entropy
    sr.seedTime = function () {
        sr.seedInt(new Date().getTime());
    }

    sr.getByte = function () {
        if(!ninja.seeder.isDone()) {
            alert("Premature initialisation of the random generator. Something is really wrong, do not generate wallets.");
            return NaN;
        }

        if (sr.state == null) {
            sr.seedTime();
            sr.state = sr.ArcFour(); // Plug in your RNG constructor here
            sr.state.init(sr.pool);
            sr.pptr = 0;
        }
        // TODO: allow reseeding after first request
        return sr.state.next();
    }

    // Mix in a 32-bit integer into the pool
    sr.seedInt = function (x) {
        sr.seedInt8(x);
        sr.seedInt8((x >> 8));
        sr.seedInt8((x >> 16));
        sr.seedInt8((x >> 24));
    }

    // Mix in a 16-bit integer into the pool
    sr.seedInt16 = function (x) {
        sr.seedInt8(x);
        sr.seedInt8((x >> 8));
    }

    // Mix in a 8-bit integer into the pool
    sr.seedInt8 = function (x) {
        sr.pool[sr.pptr++] ^= x & 255;
        if (sr.pptr >= sr.poolSize) sr.pptr -= sr.poolSize;
    }

    // Arcfour is a PRNG
    sr.ArcFour = function () {
        function Arcfour() {
            this.i = 0;
            this.j = 0;
            this.S = new Array();
        }

        // Initialize arcfour context from key, an array of ints, each from [0..255]
        function ARC4init(key) {
            var i, j, t;
            for (i = 0; i < 256; ++i)
                this.S[i] = i;
            j = 0;
            for (i = 0; i < 256; ++i) {
                j = (j + this.S[i] + key[i % key.length]) & 255;
                t = this.S[i];
                this.S[i] = this.S[j];
                this.S[j] = t;
            }
            this.i = 0;
            this.j = 0;
        }

        function ARC4next() {
            var t;
            this.i = (this.i + 1) & 255;
            this.j = (this.j + this.S[this.i]) & 255;
            t = this.S[this.i];
            this.S[this.i] = this.S[this.j];
            this.S[this.j] = t;
            return this.S[(t + this.S[this.i]) & 255];
        }

        Arcfour.prototype.init = ARC4init;
        Arcfour.prototype.next = ARC4next;

        return new Arcfour();
    };


    // Initialize the pool with junk if needed.
    if (sr.pool == null) {
        sr.pool = new Array();
        sr.pptr = 0;
        var t;
        if (window.crypto && window.crypto.getRandomValues && window.Uint8Array) {
            try {
                // Use webcrypto if available
                var ua = new Uint8Array(sr.poolSize);
                window.crypto.getRandomValues(ua);
                for (t = 0; t < sr.poolSize; ++t)
                    sr.pool[sr.pptr++] = ua[t];
            } catch (e) { alert(e); }
        }
        while (sr.pptr < sr.poolSize) {  // extract some randomness from Math.random()
            t = Math.floor(65536 * Math.random());
            sr.pool[sr.pptr++] = t >>> 8;
            sr.pool[sr.pptr++] = t & 255;
        }
        sr.pptr = Math.floor(sr.poolSize * Math.random());
        sr.seedTime();
        // entropy
        var entropyStr = "";
        // screen size and color depth: ~4.8 to ~5.4 bits
        entropyStr += (window.screen.height * window.screen.width * window.screen.colorDepth);
        entropyStr += (window.screen.availHeight * window.screen.availWidth * window.screen.pixelDepth);
        // time zone offset: ~4 bits
        var dateObj = new Date();
        var timeZoneOffset = dateObj.getTimezoneOffset();
        entropyStr += timeZoneOffset;
        // user agent: ~8.3 to ~11.6 bits
        entropyStr += navigator.userAgent;
        // browser plugin details: ~16.2 to ~21.8 bits
        var pluginsStr = "";
        for (var i = 0; i < navigator.plugins.length; i++) {
            pluginsStr += navigator.plugins[i].name + " " + navigator.plugins[i].filename + " " + navigator.plugins[i].description + " " + navigator.plugins[i].version + ", ";
        }
        var mimeTypesStr = "";
        for (var i = 0; i < navigator.mimeTypes.length; i++) {
            mimeTypesStr += navigator.mimeTypes[i].description + " " + navigator.mimeTypes[i].type + " " + navigator.mimeTypes[i].suffixes + ", ";
        }
        entropyStr += pluginsStr + mimeTypesStr;
        // cookies and storage: 1 bit
        entropyStr += navigator.cookieEnabled + typeof (sessionStorage) + typeof (localStorage);
        // language: ~7 bit
        entropyStr += navigator.language;
        // history: ~2 bit
        entropyStr += window.history.length;
        // location
        entropyStr += window.location;

        var entropyBytes = Crypto.SHA256(entropyStr, { asBytes: true });
        for (var i = 0 ; i < entropyBytes.length ; i++) {
            sr.seedInt8(entropyBytes[i]);
        }
    }
})();
</script>
<script type="text/javascript">
//https://raw.github.com/bitcoinjs/bitcoinjs-lib/faa10f0f6a1fff0b9a99fffb9bc30cee33b17212/src/ecdsa.js
/*!
* Basic Javascript Elliptic Curve implementation
* Ported loosely from BouncyCastle's Java EC code
* Only Fp curves implemented for now
*
* Copyright Tom Wu, bitaddress.org  BSD License.
* http://www-cs-students.stanford.edu/~tjw/jsbn/LICENSE
*/
(function () {

    // Constructor function of Global EllipticCurve object
    var ec = window.EllipticCurve = function () { };


    // ----------------
    // ECFieldElementFp constructor
    // q instanceof BigInteger
    // x instanceof BigInteger
    ec.FieldElementFp = function (q, x) {
        this.x = x;
        // TODO if(x.compareTo(q) >= 0) error
        this.q = q;
    };

    ec.FieldElementFp.prototype.equals = function (other) {
        if (other == this) return true;
        return (this.q.equals(other.q) && this.x.equals(other.x));
    };

    ec.FieldElementFp.prototype.toBigInteger = function () {
        return this.x;
    };

    ec.FieldElementFp.prototype.negate = function () {
        return new ec.FieldElementFp(this.q, this.x.negate().mod(this.q));
    };

    ec.FieldElementFp.prototype.add = function (b) {
        return new ec.FieldElementFp(this.q, this.x.add(b.toBigInteger()).mod(this.q));
    };

    ec.FieldElementFp.prototype.subtract = function (b) {
        return new ec.FieldElementFp(this.q, this.x.subtract(b.toBigInteger()).mod(this.q));
    };

    ec.FieldElementFp.prototype.multiply = function (b) {
        return new ec.FieldElementFp(this.q, this.x.multiply(b.toBigInteger()).mod(this.q));
    };

    ec.FieldElementFp.prototype.square = function () {
        return new ec.FieldElementFp(this.q, this.x.square().mod(this.q));
    };

    ec.FieldElementFp.prototype.divide = function (b) {
        return new ec.FieldElementFp(this.q, this.x.multiply(b.toBigInteger().modInverse(this.q)).mod(this.q));
    };

    ec.FieldElementFp.prototype.getByteLength = function () {
        return Math.floor((this.toBigInteger().bitLength() + 7) / 8);
    };

    // D.1.4 91
    /**
    * return a sqrt root - the routine verifies that the calculation
    * returns the right value - if none exists it returns null.
    *
    * Copyright (c) 2000 - 2011 The Legion Of The Bouncy Castle (http://www.bouncycastle.org)
    * Ported to JavaScript by bitaddress.org
    */
    ec.FieldElementFp.prototype.sqrt = function () {
        if (!this.q.testBit(0)) throw new Error("even value of q");

        // p mod 4 == 3
        if (this.q.testBit(1)) {
            // z = g^(u+1) + p, p = 4u + 3
            var z = new ec.FieldElementFp(this.q, this.x.modPow(this.q.shiftRight(2).add(BigInteger.ONE), this.q));
            return z.square().equals(this) ? z : null;
        }

        // p mod 4 == 1
        var qMinusOne = this.q.subtract(BigInteger.ONE);
        var legendreExponent = qMinusOne.shiftRight(1);
        if (!(this.x.modPow(legendreExponent, this.q).equals(BigInteger.ONE))) return null;
        var u = qMinusOne.shiftRight(2);
        var k = u.shiftLeft(1).add(BigInteger.ONE);
        var Q = this.x;
        var fourQ = Q.shiftLeft(2).mod(this.q);
        var U, V;

        do {
            var rand = new SecureRandom();
            var P;
            do {
                P = new BigInteger(this.q.bitLength(), rand);
            }
            while (P.compareTo(this.q) >= 0 || !(P.multiply(P).subtract(fourQ).modPow(legendreExponent, this.q).equals(qMinusOne)));

            var result = ec.FieldElementFp.fastLucasSequence(this.q, P, Q, k);

            U = result[0];
            V = result[1];
            if (V.multiply(V).mod(this.q).equals(fourQ)) {
                // Integer division by 2, mod q
                if (V.testBit(0)) {
                    V = V.add(this.q);
                }
                V = V.shiftRight(1);
                return new ec.FieldElementFp(this.q, V);
            }
        }
        while (U.equals(BigInteger.ONE) || U.equals(qMinusOne));

        return null;
    };

    /*
    * Copyright (c) 2000 - 2011 The Legion Of The Bouncy Castle (http://www.bouncycastle.org)
    * Ported to JavaScript by bitaddress.org
    */
    ec.FieldElementFp.fastLucasSequence = function (p, P, Q, k) {
        // TODO Research and apply "common-multiplicand multiplication here"

        var n = k.bitLength();
        var s = k.getLowestSetBit();
        var Uh = BigInteger.ONE;
        var Vl = BigInteger.TWO;
        var Vh = P;
        var Ql = BigInteger.ONE;
        var Qh = BigInteger.ONE;

        for (var j = n - 1; j >= s + 1; --j) {
            Ql = Ql.multiply(Qh).mod(p);
            if (k.testBit(j)) {
                Qh = Ql.multiply(Q).mod(p);
                Uh = Uh.multiply(Vh).mod(p);
                Vl = Vh.multiply(Vl).subtract(P.multiply(Ql)).mod(p);
                Vh = Vh.multiply(Vh).subtract(Qh.shiftLeft(1)).mod(p);
            }
            else {
                Qh = Ql;
                Uh = Uh.multiply(Vl).subtract(Ql).mod(p);
                Vh = Vh.multiply(Vl).subtract(P.multiply(Ql)).mod(p);
                Vl = Vl.multiply(Vl).subtract(Ql.shiftLeft(1)).mod(p);
            }
        }

        Ql = Ql.multiply(Qh).mod(p);
        Qh = Ql.multiply(Q).mod(p);
        Uh = Uh.multiply(Vl).subtract(Ql).mod(p);
        Vl = Vh.multiply(Vl).subtract(P.multiply(Ql)).mod(p);
        Ql = Ql.multiply(Qh).mod(p);

        for (var j = 1; j <= s; ++j) {
            Uh = Uh.multiply(Vl).mod(p);
            Vl = Vl.multiply(Vl).subtract(Ql.shiftLeft(1)).mod(p);
            Ql = Ql.multiply(Ql).mod(p);
        }

        return [Uh, Vl];
    };

    // ----------------
    // ECPointFp constructor
    ec.PointFp = function (curve, x, y, z, compressed) {
        this.curve = curve;
        this.x = x;
        this.y = y;
        // Projective coordinates: either zinv == null or z * zinv == 1
        // z and zinv are just BigIntegers, not fieldElements
        if (z == null) {
            this.z = BigInteger.ONE;
        }
        else {
            this.z = z;
        }
        this.zinv = null;
        // compression flag
        this.compressed = !!compressed;
    };

    ec.PointFp.prototype.getX = function () {
        if (this.zinv == null) {
            this.zinv = this.z.modInverse(this.curve.q);
        }
        var r = this.x.toBigInteger().multiply(this.zinv);
        this.curve.reduce(r);
        return this.curve.fromBigInteger(r);
    };

    ec.PointFp.prototype.getY = function () {
        if (this.zinv == null) {
            this.zinv = this.z.modInverse(this.curve.q);
        }
        var r = this.y.toBigInteger().multiply(this.zinv);
        this.curve.reduce(r);
        return this.curve.fromBigInteger(r);
    };

    ec.PointFp.prototype.equals = function (other) {
        if (other == this) return true;
        if (this.isInfinity()) return other.isInfinity();
        if (other.isInfinity()) return this.isInfinity();
        var u, v;
        // u = Y2 * Z1 - Y1 * Z2
        u = other.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(other.z)).mod(this.curve.q);
        if (!u.equals(BigInteger.ZERO)) return false;
        // v = X2 * Z1 - X1 * Z2
        v = other.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(other.z)).mod(this.curve.q);
        return v.equals(BigInteger.ZERO);
    };

    ec.PointFp.prototype.isInfinity = function () {
        if ((this.x == null) && (this.y == null)) return true;
        return this.z.equals(BigInteger.ZERO) && !this.y.toBigInteger().equals(BigInteger.ZERO);
    };

    ec.PointFp.prototype.negate = function () {
        return new ec.PointFp(this.curve, this.x, this.y.negate(), this.z);
    };

    ec.PointFp.prototype.add = function (b) {
        if (this.isInfinity()) return b;
        if (b.isInfinity()) return this;

        // u = Y2 * Z1 - Y1 * Z2
        var u = b.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(b.z)).mod(this.curve.q);
        // v = X2 * Z1 - X1 * Z2
        var v = b.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(b.z)).mod(this.curve.q);


        if (BigInteger.ZERO.equals(v)) {
            if (BigInteger.ZERO.equals(u)) {
                return this.twice(); // this == b, so double
            }
            return this.curve.getInfinity(); // this = -b, so infinity
        }

        var THREE = new BigInteger("3");
        var x1 = this.x.toBigInteger();
        var y1 = this.y.toBigInteger();
        var x2 = b.x.toBigInteger();
        var y2 = b.y.toBigInteger();

        var v2 = v.square();
        var v3 = v2.multiply(v);
        var x1v2 = x1.multiply(v2);
        var zu2 = u.square().multiply(this.z);

        // x3 = v * (z2 * (z1 * u^2 - 2 * x1 * v^2) - v^3)
        var x3 = zu2.subtract(x1v2.shiftLeft(1)).multiply(b.z).subtract(v3).multiply(v).mod(this.curve.q);
        // y3 = z2 * (3 * x1 * u * v^2 - y1 * v^3 - z1 * u^3) + u * v^3
        var y3 = x1v2.multiply(THREE).multiply(u).subtract(y1.multiply(v3)).subtract(zu2.multiply(u)).multiply(b.z).add(u.multiply(v3)).mod(this.curve.q);
        // z3 = v^3 * z1 * z2
        var z3 = v3.multiply(this.z).multiply(b.z).mod(this.curve.q);

        return new ec.PointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);
    };

    ec.PointFp.prototype.twice = function () {
        if (this.isInfinity()) return this;
        if (this.y.toBigInteger().signum() == 0) return this.curve.getInfinity();

        // TODO: optimized handling of constants
        var THREE = new BigInteger("3");
        var x1 = this.x.toBigInteger();
        var y1 = this.y.toBigInteger();

        var y1z1 = y1.multiply(this.z);
        var y1sqz1 = y1z1.multiply(y1).mod(this.curve.q);
        var a = this.curve.a.toBigInteger();

        // w = 3 * x1^2 + a * z1^2
        var w = x1.square().multiply(THREE);
        if (!BigInteger.ZERO.equals(a)) {
            w = w.add(this.z.square().multiply(a));
        }
        w = w.mod(this.curve.q);
        //this.curve.reduce(w);
        // x3 = 2 * y1 * z1 * (w^2 - 8 * x1 * y1^2 * z1)
        var x3 = w.square().subtract(x1.shiftLeft(3).multiply(y1sqz1)).shiftLeft(1).multiply(y1z1).mod(this.curve.q);
        // y3 = 4 * y1^2 * z1 * (3 * w * x1 - 2 * y1^2 * z1) - w^3
        var y3 = w.multiply(THREE).multiply(x1).subtract(y1sqz1.shiftLeft(1)).shiftLeft(2).multiply(y1sqz1).subtract(w.square().multiply(w)).mod(this.curve.q);
        // z3 = 8 * (y1 * z1)^3
        var z3 = y1z1.square().multiply(y1z1).shiftLeft(3).mod(this.curve.q);

        return new ec.PointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);
    };

    // Simple NAF (Non-Adjacent Form) multiplication algorithm
    // TODO: modularize the multiplication algorithm
    ec.PointFp.prototype.multiply = function (k) {
        if (this.isInfinity()) return this;
        if (k.signum() == 0) return this.curve.getInfinity();

        var e = k;
        var h = e.multiply(new BigInteger("3"));

        var neg = this.negate();
        var R = this;

        var i;
        for (i = h.bitLength() - 2; i > 0; --i) {
            R = R.twice();

            var hBit = h.testBit(i);
            var eBit = e.testBit(i);

            if (hBit != eBit) {
                R = R.add(hBit ? this : neg);
            }
        }

        return R;
    };

    // Compute this*j + x*k (simultaneous multiplication)
    ec.PointFp.prototype.multiplyTwo = function (j, x, k) {
        var i;
        if (j.bitLength() > k.bitLength())
            i = j.bitLength() - 1;
        else
            i = k.bitLength() - 1;

        var R = this.curve.getInfinity();
        var both = this.add(x);
        while (i >= 0) {
            R = R.twice();
            if (j.testBit(i)) {
                if (k.testBit(i)) {
                    R = R.add(both);
                }
                else {
                    R = R.add(this);
                }
            }
            else {
                if (k.testBit(i)) {
                    R = R.add(x);
                }
            }
            --i;
        }

        return R;
    };

    // patched by bitaddress.org and Casascius for use with Bitcoin.ECKey
    // patched by coretechs to support compressed public keys
    ec.PointFp.prototype.getEncoded = function (compressed) {
        var x = this.getX().toBigInteger();
        var y = this.getY().toBigInteger();
        var len = 32; // integerToBytes will zero pad if integer is less than 32 bytes. 32 bytes length is required by the Bitcoin protocol.
        var enc = ec.integerToBytes(x, len);

        // when compressed prepend byte depending if y point is even or odd
        if (compressed) {
            if (y.isEven()) {
                enc.unshift(0x02);
            }
            else {
                enc.unshift(0x03);
            }
        }
        else {
            enc.unshift(0x04);
            enc = enc.concat(ec.integerToBytes(y, len)); // uncompressed public key appends the bytes of the y point
        }
        return enc;
    };

    ec.PointFp.decodeFrom = function (curve, enc) {
        var type = enc[0];
        var dataLen = enc.length - 1;

        // Extract x and y as byte arrays
        var xBa = enc.slice(1, 1 + dataLen / 2);
        var yBa = enc.slice(1 + dataLen / 2, 1 + dataLen);

        // Prepend zero byte to prevent interpretation as negative integer
        xBa.unshift(0);
        yBa.unshift(0);

        // Convert to BigIntegers
        var x = new BigInteger(xBa);
        var y = new BigInteger(yBa);

        // Return point
        return new ec.PointFp(curve, curve.fromBigInteger(x), curve.fromBigInteger(y));
    };

    ec.PointFp.prototype.add2D = function (b) {
        if (this.isInfinity()) return b;
        if (b.isInfinity()) return this;

        if (this.x.equals(b.x)) {
            if (this.y.equals(b.y)) {
                // this = b, i.e. this must be doubled
                return this.twice();
            }
            // this = -b, i.e. the result is the point at infinity
            return this.curve.getInfinity();
        }

        var x_x = b.x.subtract(this.x);
        var y_y = b.y.subtract(this.y);
        var gamma = y_y.divide(x_x);

        var x3 = gamma.square().subtract(this.x).subtract(b.x);
        var y3 = gamma.multiply(this.x.subtract(x3)).subtract(this.y);

        return new ec.PointFp(this.curve, x3, y3);
    };

    ec.PointFp.prototype.twice2D = function () {
        if (this.isInfinity()) return this;
        if (this.y.toBigInteger().signum() == 0) {
            // if y1 == 0, then (x1, y1) == (x1, -y1)
            // and hence this = -this and thus 2(x1, y1) == infinity
            return this.curve.getInfinity();
        }

        var TWO = this.curve.fromBigInteger(BigInteger.valueOf(2));
        var THREE = this.curve.fromBigInteger(BigInteger.valueOf(3));
        var gamma = this.x.square().multiply(THREE).add(this.curve.a).divide(this.y.multiply(TWO));

        var x3 = gamma.square().subtract(this.x.multiply(TWO));
        var y3 = gamma.multiply(this.x.subtract(x3)).subtract(this.y);

        return new ec.PointFp(this.curve, x3, y3);
    };

    ec.PointFp.prototype.multiply2D = function (k) {
        if (this.isInfinity()) return this;
        if (k.signum() == 0) return this.curve.getInfinity();

        var e = k;
        var h = e.multiply(new BigInteger("3"));

        var neg = this.negate();
        var R = this;

        var i;
        for (i = h.bitLength() - 2; i > 0; --i) {
            R = R.twice();

            var hBit = h.testBit(i);
            var eBit = e.testBit(i);

            if (hBit != eBit) {
                R = R.add2D(hBit ? this : neg);
            }
        }

        return R;
    };

    ec.PointFp.prototype.isOnCurve = function () {
        var x = this.getX().toBigInteger();
        var y = this.getY().toBigInteger();
        var a = this.curve.getA().toBigInteger();
        var b = this.curve.getB().toBigInteger();
        var n = this.curve.getQ();
        var lhs = y.multiply(y).mod(n);
        var rhs = x.multiply(x).multiply(x).add(a.multiply(x)).add(b).mod(n);
        return lhs.equals(rhs);
    };

    ec.PointFp.prototype.toString = function () {
        return '(' + this.getX().toBigInteger().toString() + ',' + this.getY().toBigInteger().toString() + ')';
    };

    /**
    * Validate an elliptic curve point.
    *
    * See SEC 1, section 3.2.2.1: Elliptic Curve Public Key Validation Primitive
    */
    ec.PointFp.prototype.validate = function () {
        var n = this.curve.getQ();

        // Check Q != O
        if (this.isInfinity()) {
            throw new Error("Point is at infinity.");
        }

        // Check coordinate bounds
        var x = this.getX().toBigInteger();
        var y = this.getY().toBigInteger();
        if (x.compareTo(BigInteger.ONE) < 0 || x.compareTo(n.subtract(BigInteger.ONE)) > 0) {
            throw new Error('x coordinate out of bounds');
        }
        if (y.compareTo(BigInteger.ONE) < 0 || y.compareTo(n.subtract(BigInteger.ONE)) > 0) {
            throw new Error('y coordinate out of bounds');
        }

        // Check y^2 = x^3 + ax + b (mod n)
        if (!this.isOnCurve()) {
            throw new Error("Point is not on the curve.");
        }

        // Check nQ = 0 (Q is a scalar multiple of G)
        if (this.multiply(n).isInfinity()) {
            // TODO: This check doesn't work - fix.
            throw new Error("Point is not a scalar multiple of G.");
        }

        return true;
    };




    // ----------------
    // ECCurveFp constructor
    ec.CurveFp = function (q, a, b) {
        this.q = q;
        this.a = this.fromBigInteger(a);
        this.b = this.fromBigInteger(b);
        this.infinity = new ec.PointFp(this, null, null);
        this.reducer = new Barrett(this.q);
    }

    ec.CurveFp.prototype.getQ = function () {
        return this.q;
    };

    ec.CurveFp.prototype.getA = function () {
        return this.a;
    };

    ec.CurveFp.prototype.getB = function () {
        return this.b;
    };

    ec.CurveFp.prototype.equals = function (other) {
        if (other == this) return true;
        return (this.q.equals(other.q) && this.a.equals(other.a) && this.b.equals(other.b));
    };

    ec.CurveFp.prototype.getInfinity = function () {
        return this.infinity;
    };

    ec.CurveFp.prototype.fromBigInteger = function (x) {
        return new ec.FieldElementFp(this.q, x);
    };

    ec.CurveFp.prototype.reduce = function (x) {
        this.reducer.reduce(x);
    };

    // for now, work with hex strings because they're easier in JS
    // compressed support added by bitaddress.org
    ec.CurveFp.prototype.decodePointHex = function (s) {
        var firstByte = parseInt(s.substr(0, 2), 16);
        switch (firstByte) { // first byte
            case 0:
                return this.infinity;
            case 2: // compressed
            case 3: // compressed
                var yTilde = firstByte & 1;
                var xHex = s.substr(2, s.length - 2);
                var X1 = new BigInteger(xHex, 16);
                return this.decompressPoint(yTilde, X1);
            case 4: // uncompressed
            case 6: // hybrid
            case 7: // hybrid
                var len = (s.length - 2) / 2;
                var xHex = s.substr(2, len);
                var yHex = s.substr(len + 2, len);

                return new ec.PointFp(this,
                    this.fromBigInteger(new BigInteger(xHex, 16)),
                    this.fromBigInteger(new BigInteger(yHex, 16)));

            default: // unsupported
                return null;
        }
    };

    ec.CurveFp.prototype.encodePointHex = function (p) {
        if (p.isInfinity()) return "00";
        var xHex = p.getX().toBigInteger().toString(16);
        var yHex = p.getY().toBigInteger().toString(16);
        var oLen = this.getQ().toString(16).length;
        if ((oLen % 2) != 0) oLen++;
        while (xHex.length < oLen) {
            xHex = "0" + xHex;
        }
        while (yHex.length < oLen) {
            yHex = "0" + yHex;
        }
        return "04" + xHex + yHex;
    };

    /*
    * Copyright (c) 2000 - 2011 The Legion Of The Bouncy Castle (http://www.bouncycastle.org)
    * Ported to JavaScript by bitaddress.org
    *
    * Number yTilde
    * BigInteger X1
    */
    ec.CurveFp.prototype.decompressPoint = function (yTilde, X1) {
        var x = this.fromBigInteger(X1);
        var alpha = x.multiply(x.square().add(this.getA())).add(this.getB());
        var beta = alpha.sqrt();
        // if we can't find a sqrt we haven't got a point on the curve - run!
        if (beta == null) throw new Error("Invalid point compression");
        var betaValue = beta.toBigInteger();
        var bit0 = betaValue.testBit(0) ? 1 : 0;
        if (bit0 != yTilde) {
            // Use the other root
            beta = this.fromBigInteger(this.getQ().subtract(betaValue));
        }
        return new ec.PointFp(this, x, beta, null, true);
    };


    ec.fromHex = function (s) { return new BigInteger(s, 16); };

    ec.integerToBytes = function (i, len) {
        var bytes = i.toByteArrayUnsigned();
        if (len < bytes.length) {
            bytes = bytes.slice(bytes.length - len);
        } else while (len > bytes.length) {
            bytes.unshift(0);
        }
        return bytes;
    };


    // Named EC curves
    // ----------------
    // X9ECParameters constructor
    ec.X9Parameters = function (curve, g, n, h) {
        this.curve = curve;
        this.g = g;
        this.n = n;
        this.h = h;
    }
    ec.X9Parameters.prototype.getCurve = function () { return this.curve; };
    ec.X9Parameters.prototype.getG = function () { return this.g; };
    ec.X9Parameters.prototype.getN = function () { return this.n; };
    ec.X9Parameters.prototype.getH = function () { return this.h; };

    // secp256k1 is the Curve used by Bitcoin
    ec.secNamedCurves = {
        // used by Bitcoin
        "secp256k1": function () {
            // p = 2^256 - 2^32 - 2^9 - 2^8 - 2^7 - 2^6 - 2^4 - 1
            var p = ec.fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F");
            var a = BigInteger.ZERO;
            var b = ec.fromHex("7");
            var n = ec.fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141");
            var h = BigInteger.ONE;
            var curve = new ec.CurveFp(p, a, b);
            var G = curve.decodePointHex("04"
                    + "79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798"
                    + "483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8");
            return new ec.X9Parameters(curve, G, n, h);
        }
    };

    // secp256k1 called by Bitcoin's ECKEY
    ec.getSECCurveByName = function (name) {
        if (ec.secNamedCurves[name] == undefined) return null;
        return ec.secNamedCurves[name]();
    }
})();
</script>
<script type="text/javascript">
/*!
* Basic JavaScript BN library - subset useful for RSA encryption. v1.3
*
* Copyright (c) 2005  Tom Wu
* All Rights Reserved.
* BSD License
* http://www-cs-students.stanford.edu/~tjw/jsbn/LICENSE
*
* Copyright Stephan Thomas
* Copyright bitaddress.org
*/

(function () {

    // (public) Constructor function of Global BigInteger object
    var BigInteger = window.BigInteger = function BigInteger(a, b, c) {
        if (a != null)
            if ("number" == typeof a) this.fromNumber(a, b, c);
            else if (b == null && "string" != typeof a) this.fromString(a, 256);
            else this.fromString(a, b);
    };

    // Bits per digit
    var dbits;

    // JavaScript engine analysis
    var canary = 0xdeadbeefcafe;
    var j_lm = ((canary & 0xffffff) == 0xefcafe);

    // return new, unset BigInteger
    function nbi() { return new BigInteger(null); }

    // am: Compute w_j += (x*this_i), propagate carries,
    // c is initial carry, returns final carry.
    // c < 3*dvalue, x < 2*dvalue, this_i < dvalue
    // We need to select the fastest one that works in this environment.

    // am1: use a single mult and divide to get the high bits,
    // max digit bits should be 26 because
    // max internal value = 2*dvalue^2-2*dvalue (< 2^53)
    function am1(i, x, w, j, c, n) {
        while (--n >= 0) {
            var v = x * this[i++] + w[j] + c;
            c = Math.floor(v / 0x4000000);
            w[j++] = v & 0x3ffffff;
        }
        return c;
    }
    // am2 avoids a big mult-and-extract completely.
    // Max digit bits should be <= 30 because we do bitwise ops
    // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
    function am2(i, x, w, j, c, n) {
        var xl = x & 0x7fff, xh = x >> 15;
        while (--n >= 0) {
            var l = this[i] & 0x7fff;
            var h = this[i++] >> 15;
            var m = xh * l + h * xl;
            l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);
            c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
            w[j++] = l & 0x3fffffff;
        }
        return c;
    }
    // Alternately, set max digit bits to 28 since some
    // browsers slow down when dealing with 32-bit numbers.
    function am3(i, x, w, j, c, n) {
        var xl = x & 0x3fff, xh = x >> 14;
        while (--n >= 0) {
            var l = this[i] & 0x3fff;
            var h = this[i++] >> 14;
            var m = xh * l + h * xl;
            l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;
            c = (l >> 28) + (m >> 14) + xh * h;
            w[j++] = l & 0xfffffff;
        }
        return c;
    }
    if (j_lm && (navigator.appName == "Microsoft Internet Explorer")) {
        BigInteger.prototype.am = am2;
        dbits = 30;
    }
    else if (j_lm && (navigator.appName != "Netscape")) {
        BigInteger.prototype.am = am1;
        dbits = 26;
    }
    else { // Mozilla/Netscape seems to prefer am3
        BigInteger.prototype.am = am3;
        dbits = 28;
    }

    BigInteger.prototype.DB = dbits;
    BigInteger.prototype.DM = ((1 << dbits) - 1);
    BigInteger.prototype.DV = (1 << dbits);

    var BI_FP = 52;
    BigInteger.prototype.FV = Math.pow(2, BI_FP);
    BigInteger.prototype.F1 = BI_FP - dbits;
    BigInteger.prototype.F2 = 2 * dbits - BI_FP;

    // Digit conversions
    var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
    var BI_RC = new Array();
    var rr, vv;
    rr = "0".charCodeAt(0);
    for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
    rr = "a".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
    rr = "A".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;

    function int2char(n) { return BI_RM.charAt(n); }
    function intAt(s, i) {
        var c = BI_RC[s.charCodeAt(i)];
        return (c == null) ? -1 : c;
    }



    // return bigint initialized to value
    function nbv(i) { var r = nbi(); r.fromInt(i); return r; }


    // returns bit length of the integer x
    function nbits(x) {
        var r = 1, t;
        if ((t = x >>> 16) != 0) { x = t; r += 16; }
        if ((t = x >> 8) != 0) { x = t; r += 8; }
        if ((t = x >> 4) != 0) { x = t; r += 4; }
        if ((t = x >> 2) != 0) { x = t; r += 2; }
        if ((t = x >> 1) != 0) { x = t; r += 1; }
        return r;
    }

    // (protected) copy this to r
    BigInteger.prototype.copyTo = function (r) {
        for (var i = this.t - 1; i >= 0; --i) r[i] = this[i];
        r.t = this.t;
        r.s = this.s;
    };


    // (protected) set from integer value x, -DV <= x < DV
    BigInteger.prototype.fromInt = function (x) {
        this.t = 1;
        this.s = (x < 0) ? -1 : 0;
        if (x > 0) this[0] = x;
        else if (x < -1) this[0] = x + this.DV;
        else this.t = 0;
    };

    // (protected) set from string and radix
    BigInteger.prototype.fromString = function (s, b) {
        var k;
        if (b == 16) k = 4;
        else if (b == 8) k = 3;
        else if (b == 256) k = 8; // byte array
        else if (b == 2) k = 1;
        else if (b == 32) k = 5;
        else if (b == 4) k = 2;
        else { this.fromRadix(s, b); return; }
        this.t = 0;
        this.s = 0;
        var i = s.length, mi = false, sh = 0;
        while (--i >= 0) {
            var x = (k == 8) ? s[i] & 0xff : intAt(s, i);
            if (x < 0) {
                if (s.charAt(i) == "-") mi = true;
                continue;
            }
            mi = false;
            if (sh == 0)
                this[this.t++] = x;
            else if (sh + k > this.DB) {
                this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;
                this[this.t++] = (x >> (this.DB - sh));
            }
            else
                this[this.t - 1] |= x << sh;
            sh += k;
            if (sh >= this.DB) sh -= this.DB;
        }
        if (k == 8 && (s[0] & 0x80) != 0) {
            this.s = -1;
            if (sh > 0) this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;
        }
        this.clamp();
        if (mi) BigInteger.ZERO.subTo(this, this);
    };


    // (protected) clamp off excess high words
    BigInteger.prototype.clamp = function () {
        var c = this.s & this.DM;
        while (this.t > 0 && this[this.t - 1] == c) --this.t;
    };

    // (protected) r = this << n*DB
    BigInteger.prototype.dlShiftTo = function (n, r) {
        var i;
        for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i];
        for (i = n - 1; i >= 0; --i) r[i] = 0;
        r.t = this.t + n;
        r.s = this.s;
    };

    // (protected) r = this >> n*DB
    BigInteger.prototype.drShiftTo = function (n, r) {
        for (var i = n; i < this.t; ++i) r[i - n] = this[i];
        r.t = Math.max(this.t - n, 0);
        r.s = this.s;
    };


    // (protected) r = this << n
    BigInteger.prototype.lShiftTo = function (n, r) {
        var bs = n % this.DB;
        var cbs = this.DB - bs;
        var bm = (1 << cbs) - 1;
        var ds = Math.floor(n / this.DB), c = (this.s << bs) & this.DM, i;
        for (i = this.t - 1; i >= 0; --i) {
            r[i + ds + 1] = (this[i] >> cbs) | c;
            c = (this[i] & bm) << bs;
        }
        for (i = ds - 1; i >= 0; --i) r[i] = 0;
        r[ds] = c;
        r.t = this.t + ds + 1;
        r.s = this.s;
        r.clamp();
    };


    // (protected) r = this >> n
    BigInteger.prototype.rShiftTo = function (n, r) {
        r.s = this.s;
        var ds = Math.floor(n / this.DB);
        if (ds >= this.t) { r.t = 0; return; }
        var bs = n % this.DB;
        var cbs = this.DB - bs;
        var bm = (1 << bs) - 1;
        r[0] = this[ds] >> bs;
        for (var i = ds + 1; i < this.t; ++i) {
            r[i - ds - 1] |= (this[i] & bm) << cbs;
            r[i - ds] = this[i] >> bs;
        }
        if (bs > 0) r[this.t - ds - 1] |= (this.s & bm) << cbs;
        r.t = this.t - ds;
        r.clamp();
    };


    // (protected) r = this - a
    BigInteger.prototype.subTo = function (a, r) {
        var i = 0, c = 0, m = Math.min(a.t, this.t);
        while (i < m) {
            c += this[i] - a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
        }
        if (a.t < this.t) {
            c -= a.s;
            while (i < this.t) {
                c += this[i];
                r[i++] = c & this.DM;
                c >>= this.DB;
            }
            c += this.s;
        }
        else {
            c += this.s;
            while (i < a.t) {
                c -= a[i];
                r[i++] = c & this.DM;
                c >>= this.DB;
            }
            c -= a.s;
        }
        r.s = (c < 0) ? -1 : 0;
        if (c < -1) r[i++] = this.DV + c;
        else if (c > 0) r[i++] = c;
        r.t = i;
        r.clamp();
    };


    // (protected) r = this * a, r != this,a (HAC 14.12)
    // "this" should be the larger one if appropriate.
    BigInteger.prototype.multiplyTo = function (a, r) {
        var x = this.abs(), y = a.abs();
        var i = x.t;
        r.t = i + y.t;
        while (--i >= 0) r[i] = 0;
        for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
        r.s = 0;
        r.clamp();
        if (this.s != a.s) BigInteger.ZERO.subTo(r, r);
    };


    // (protected) r = this^2, r != this (HAC 14.16)
    BigInteger.prototype.squareTo = function (r) {
        var x = this.abs();
        var i = r.t = 2 * x.t;
        while (--i >= 0) r[i] = 0;
        for (i = 0; i < x.t - 1; ++i) {
            var c = x.am(i, x[i], r, 2 * i, 0, 1);
            if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
                r[i + x.t] -= x.DV;
                r[i + x.t + 1] = 1;
            }
        }
        if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
        r.s = 0;
        r.clamp();
    };



    // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
    // r != q, this != m.  q or r may be null.
    BigInteger.prototype.divRemTo = function (m, q, r) {
        var pm = m.abs();
        if (pm.t <= 0) return;
        var pt = this.abs();
        if (pt.t < pm.t) {
            if (q != null) q.fromInt(0);
            if (r != null) this.copyTo(r);
            return;
        }
        if (r == null) r = nbi();
        var y = nbi(), ts = this.s, ms = m.s;
        var nsh = this.DB - nbits(pm[pm.t - 1]); // normalize modulus
        if (nsh > 0) { pm.lShiftTo(nsh, y); pt.lShiftTo(nsh, r); }
        else { pm.copyTo(y); pt.copyTo(r); }
        var ys = y.t;
        var y0 = y[ys - 1];
        if (y0 == 0) return;
        var yt = y0 * (1 << this.F1) + ((ys > 1) ? y[ys - 2] >> this.F2 : 0);
        var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
        var i = r.t, j = i - ys, t = (q == null) ? nbi() : q;
        y.dlShiftTo(j, t);
        if (r.compareTo(t) >= 0) {
            r[r.t++] = 1;
            r.subTo(t, r);
        }
        BigInteger.ONE.dlShiftTo(ys, t);
        t.subTo(y, y); // "negative" y so we can replace sub with am later
        while (y.t < ys) y[y.t++] = 0;
        while (--j >= 0) {
            // Estimate quotient digit
            var qd = (r[--i] == y0) ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
            if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {  // Try it out
                y.dlShiftTo(j, t);
                r.subTo(t, r);
                while (r[i] < --qd) r.subTo(t, r);
            }
        }
        if (q != null) {
            r.drShiftTo(ys, q);
            if (ts != ms) BigInteger.ZERO.subTo(q, q);
        }
        r.t = ys;
        r.clamp();
        if (nsh > 0) r.rShiftTo(nsh, r); // Denormalize remainder
        if (ts < 0) BigInteger.ZERO.subTo(r, r);
    };


    // (protected) return "-1/this % 2^DB"; useful for Mont. reduction
    // justification:
    //         xy == 1 (mod m)
    //         xy =  1+km
    //   xy(2-xy) = (1+km)(1-km)
    // x[y(2-xy)] = 1-k^2m^2
    // x[y(2-xy)] == 1 (mod m^2)
    // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
    // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
    // JS multiply "overflows" differently from C/C++, so care is needed here.
    BigInteger.prototype.invDigit = function () {
        if (this.t < 1) return 0;
        var x = this[0];
        if ((x & 1) == 0) return 0;
        var y = x & 3;  // y == 1/x mod 2^2
        y = (y * (2 - (x & 0xf) * y)) & 0xf; // y == 1/x mod 2^4
        y = (y * (2 - (x & 0xff) * y)) & 0xff; // y == 1/x mod 2^8
        y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff; // y == 1/x mod 2^16
        // last step - calculate inverse mod DV directly;
        // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
        y = (y * (2 - x * y % this.DV)) % this.DV;  // y == 1/x mod 2^dbits
        // we really want the negative inverse, and -DV < y < DV
        return (y > 0) ? this.DV - y : -y;
    };


    // (protected) true iff this is even
    BigInteger.prototype.isEven = function () { return ((this.t > 0) ? (this[0] & 1) : this.s) == 0; };


    // (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
    BigInteger.prototype.exp = function (e, z) {
        if (e > 0xffffffff || e < 1) return BigInteger.ONE;
        var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e) - 1;
        g.copyTo(r);
        while (--i >= 0) {
            z.sqrTo(r, r2);
            if ((e & (1 << i)) > 0) z.mulTo(r2, g, r);
            else { var t = r; r = r2; r2 = t; }
        }
        return z.revert(r);
    };


    // (public) return string representation in given radix
    BigInteger.prototype.toString = function (b) {
        if (this.s < 0) return "-" + this.negate().toString(b);
        var k;
        if (b == 16) k = 4;
        else if (b == 8) k = 3;
        else if (b == 2) k = 1;
        else if (b == 32) k = 5;
        else if (b == 4) k = 2;
        else return this.toRadix(b);
        var km = (1 << k) - 1, d, m = false, r = "", i = this.t;
        var p = this.DB - (i * this.DB) % k;
        if (i-- > 0) {
            if (p < this.DB && (d = this[i] >> p) > 0) { m = true; r = int2char(d); }
            while (i >= 0) {
                if (p < k) {
                    d = (this[i] & ((1 << p) - 1)) << (k - p);
                    d |= this[--i] >> (p += this.DB - k);
                }
                else {
                    d = (this[i] >> (p -= k)) & km;
                    if (p <= 0) { p += this.DB; --i; }
                }
                if (d > 0) m = true;
                if (m) r += int2char(d);
            }
        }
        return m ? r : "0";
    };

    BigInteger.prototype.toFixed = function (b,len) {
        return ("0".repeat(len)+this.toString(b)).substr(-len);
    }

    // (public) -this
    BigInteger.prototype.negate = function () { var r = nbi(); BigInteger.ZERO.subTo(this, r); return r; };

    // (public) |this|
    BigInteger.prototype.abs = function () { return (this.s < 0) ? this.negate() : this; };

    // (public) return + if this > a, - if this < a, 0 if equal
    BigInteger.prototype.compareTo = function (a) {
        var r = this.s - a.s;
        if (r != 0) return r;
        var i = this.t;
        r = i - a.t;
        if (r != 0) return (this.s < 0) ? -r : r;
        while (--i >= 0) if ((r = this[i] - a[i]) != 0) return r;
        return 0;
    }

    // (public) return the number of bits in "this"
    BigInteger.prototype.bitLength = function () {
        if (this.t <= 0) return 0;
        return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM));
    };

    // (public) this mod a
    BigInteger.prototype.mod = function (a) {
        var r = nbi();
        this.abs().divRemTo(a, null, r);
        if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);
        return r;
    }

    // (public) this^e % m, 0 <= e < 2^32
    BigInteger.prototype.modPowInt = function (e, m) {
        var z;
        if (e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);
        return this.exp(e, z);
    };

    // "constants"
    BigInteger.ZERO = nbv(0);
    BigInteger.ONE = nbv(1);







    // Copyright (c) 2005-2009  Tom Wu
    // All Rights Reserved.
    // See "LICENSE" for details.
    // Extended JavaScript BN functions, required for RSA private ops.
    // Version 1.1: new BigInteger("0", 10) returns "proper" zero
    // Version 1.2: square() API, isProbablePrime fix


    // return index of lowest 1-bit in x, x < 2^31
    function lbit(x) {
        if (x == 0) return -1;
        var r = 0;
        if ((x & 0xffff) == 0) { x >>= 16; r += 16; }
        if ((x & 0xff) == 0) { x >>= 8; r += 8; }
        if ((x & 0xf) == 0) { x >>= 4; r += 4; }
        if ((x & 3) == 0) { x >>= 2; r += 2; }
        if ((x & 1) == 0) ++r;
        return r;
    }

    // return number of 1 bits in x
    function cbit(x) {
        var r = 0;
        while (x != 0) { x &= x - 1; ++r; }
        return r;
    }

    var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
    var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];



    // (protected) return x s.t. r^x < DV
    BigInteger.prototype.chunkSize = function (r) { return Math.floor(Math.LN2 * this.DB / Math.log(r)); };

    // (protected) convert to radix string
    BigInteger.prototype.toRadix = function (b) {
        if (b == null) b = 10;
        if (this.signum() == 0 || b < 2 || b > 36) return "0";
        var cs = this.chunkSize(b);
        var a = Math.pow(b, cs);
        var d = nbv(a), y = nbi(), z = nbi(), r = "";
        this.divRemTo(d, y, z);
        while (y.signum() > 0) {
            r = (a + z.intValue()).toString(b).substr(1) + r;
            y.divRemTo(d, y, z);
        }
        return z.intValue().toString(b) + r;
    };

    // (protected) convert from radix string
    BigInteger.prototype.fromRadix = function (s, b) {
        this.fromInt(0);
        if (b == null) b = 10;
        var cs = this.chunkSize(b);
        var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
        for (var i = 0; i < s.length; ++i) {
            var x = intAt(s, i);
            if (x < 0) {
                if (s.charAt(i) == "-" && this.signum() == 0) mi = true;
                continue;
            }
            w = b * w + x;
            if (++j >= cs) {
                this.dMultiply(d);
                this.dAddOffset(w, 0);
                j = 0;
                w = 0;
            }
        }
        if (j > 0) {
            this.dMultiply(Math.pow(b, j));
            this.dAddOffset(w, 0);
        }
        if (mi) BigInteger.ZERO.subTo(this, this);
    };

    // (protected) alternate constructor
    BigInteger.prototype.fromNumber = function (a, b, c) {
        if ("number" == typeof b) {
            // new BigInteger(int,int,RNG)
            if (a < 2) this.fromInt(1);
            else {
                this.fromNumber(a, c);
                if (!this.testBit(a - 1))   // force MSB set
                    this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
                if (this.isEven()) this.dAddOffset(1, 0); // force odd
                while (!this.isProbablePrime(b)) {
                    this.dAddOffset(2, 0);
                    if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
                }
            }
        }
        else {
            // new BigInteger(int,RNG)
            var x = new Array(), t = a & 7;
            x.length = (a >> 3) + 1;
            b.nextBytes(x);
            if (t > 0) x[0] &= ((1 << t) - 1); else x[0] = 0;
            this.fromString(x, 256);
        }
    };

    // (protected) r = this op a (bitwise)
    BigInteger.prototype.bitwiseTo = function (a, op, r) {
        var i, f, m = Math.min(a.t, this.t);
        for (i = 0; i < m; ++i) r[i] = op(this[i], a[i]);
        if (a.t < this.t) {
            f = a.s & this.DM;
            for (i = m; i < this.t; ++i) r[i] = op(this[i], f);
            r.t = this.t;
        }
        else {
            f = this.s & this.DM;
            for (i = m; i < a.t; ++i) r[i] = op(f, a[i]);
            r.t = a.t;
        }
        r.s = op(this.s, a.s);
        r.clamp();
    };

    // (protected) this op (1<<n)
    BigInteger.prototype.changeBit = function (n, op) {
        var r = BigInteger.ONE.shiftLeft(n);
        this.bitwiseTo(r, op, r);
        return r;
    };

    // (protected) r = this + a
    BigInteger.prototype.addTo = function (a, r) {
        var i = 0, c = 0, m = Math.min(a.t, this.t);
        while (i < m) {
            c += this[i] + a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
        }
        if (a.t < this.t) {
            c += a.s;
            while (i < this.t) {
                c += this[i];
                r[i++] = c & this.DM;
                c >>= this.DB;
            }
            c += this.s;
        }
        else {
            c += this.s;
            while (i < a.t) {
                c += a[i];
                r[i++] = c & this.DM;
                c >>= this.DB;
            }
            c += a.s;
        }
        r.s = (c < 0) ? -1 : 0;
        if (c > 0) r[i++] = c;
        else if (c < -1) r[i++] = this.DV + c;
        r.t = i;
        r.clamp();
    };

    // (protected) this *= n, this >= 0, 1 < n < DV
    BigInteger.prototype.dMultiply = function (n) {
        this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
        ++this.t;
        this.clamp();
    };

    // (protected) this += n << w words, this >= 0
    BigInteger.prototype.dAddOffset = function (n, w) {
        if (n == 0) return;
        while (this.t <= w) this[this.t++] = 0;
        this[w] += n;
        while (this[w] >= this.DV) {
            this[w] -= this.DV;
            if (++w >= this.t) this[this.t++] = 0;
            ++this[w];
        }
    };

    // (protected) r = lower n words of "this * a", a.t <= n
    // "this" should be the larger one if appropriate.
    BigInteger.prototype.multiplyLowerTo = function (a, n, r) {
        var i = Math.min(this.t + a.t, n);
        r.s = 0; // assumes a,this >= 0
        r.t = i;
        while (i > 0) r[--i] = 0;
        var j;
        for (j = r.t - this.t; i < j; ++i) r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
        for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a[i], r, i, 0, n - i);
        r.clamp();
    };


    // (protected) r = "this * a" without lower n words, n > 0
    // "this" should be the larger one if appropriate.
    BigInteger.prototype.multiplyUpperTo = function (a, n, r) {
        --n;
        var i = r.t = this.t + a.t - n;
        r.s = 0; // assumes a,this >= 0
        while (--i >= 0) r[i] = 0;
        for (i = Math.max(n - this.t, 0); i < a.t; ++i)
            r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
        r.clamp();
        r.drShiftTo(1, r);
    };

    // (protected) this % n, n < 2^26
    BigInteger.prototype.modInt = function (n) {
        if (n <= 0) return 0;
        var d = this.DV % n, r = (this.s < 0) ? n - 1 : 0;
        if (this.t > 0)
            if (d == 0) r = this[0] % n;
            else for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n;
        return r;
    };


    // (protected) true if probably prime (HAC 4.24, Miller-Rabin)
    BigInteger.prototype.millerRabin = function (t) {
        var n1 = this.subtract(BigInteger.ONE);
        var k = n1.getLowestSetBit();
        if (k <= 0) return false;
        var r = n1.shiftRight(k);
        t = (t + 1) >> 1;
        if (t > lowprimes.length) t = lowprimes.length;
        var a = nbi();
        for (var i = 0; i < t; ++i) {
            //Pick bases at random, instead of starting at 2
            a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
            var y = a.modPow(r, this);
            if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
                var j = 1;
                while (j++ < k && y.compareTo(n1) != 0) {
                    y = y.modPowInt(2, this);
                    if (y.compareTo(BigInteger.ONE) == 0) return false;
                }
                if (y.compareTo(n1) != 0) return false;
            }
        }
        return true;
    };



    // (public)
    BigInteger.prototype.clone = function () { var r = nbi(); this.copyTo(r); return r; };

    // (public) return value as integer
    BigInteger.prototype.intValue = function () {
        if (this.s < 0) {
            if (this.t == 1) return this[0] - this.DV;
            else if (this.t == 0) return -1;
        }
        else if (this.t == 1) return this[0];
        else if (this.t == 0) return 0;
        // assumes 16 < DB < 32
        return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];
    };


    // (public) return value as byte
    BigInteger.prototype.byteValue = function () { return (this.t == 0) ? this.s : (this[0] << 24) >> 24; };

    // (public) return value as short (assumes DB>=16)
    BigInteger.prototype.shortValue = function () { return (this.t == 0) ? this.s : (this[0] << 16) >> 16; };

    // (public) 0 if this == 0, 1 if this > 0
    BigInteger.prototype.signum = function () {
        if (this.s < 0) return -1;
        else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;
        else return 1;
    };


    // (public) convert to bigendian byte array
    BigInteger.prototype.toByteArray = function () {
        var i = this.t, r = new Array();
        r[0] = this.s;
        var p = this.DB - (i * this.DB) % 8, d, k = 0;
        if (i-- > 0) {
            if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)
                r[k++] = d | (this.s << (this.DB - p));
            while (i >= 0) {
                if (p < 8) {
                    d = (this[i] & ((1 << p) - 1)) << (8 - p);
                    d |= this[--i] >> (p += this.DB - 8);
                }
                else {
                    d = (this[i] >> (p -= 8)) & 0xff;
                    if (p <= 0) { p += this.DB; --i; }
                }
                if ((d & 0x80) != 0) d |= -256;
                if (k == 0 && (this.s & 0x80) != (d & 0x80)) ++k;
                if (k > 0 || d != this.s) r[k++] = d;
            }
        }
        return r;
    };

    BigInteger.prototype.equals = function (a) { return (this.compareTo(a) == 0); };
    BigInteger.prototype.min = function (a) { return (this.compareTo(a) < 0) ? this : a; };
    BigInteger.prototype.max = function (a) { return (this.compareTo(a) > 0) ? this : a; };

    // (public) this & a
    function op_and(x, y) { return x & y; }
    BigInteger.prototype.and = function (a) { var r = nbi(); this.bitwiseTo(a, op_and, r); return r; };

    // (public) this | a
    function op_or(x, y) { return x | y; }
    BigInteger.prototype.or = function (a) { var r = nbi(); this.bitwiseTo(a, op_or, r); return r; };

    // (public) this ^ a
    function op_xor(x, y) { return x ^ y; }
    BigInteger.prototype.xor = function (a) { var r = nbi(); this.bitwiseTo(a, op_xor, r); return r; };

    // (public) this & ~a
    function op_andnot(x, y) { return x & ~y; }
    BigInteger.prototype.andNot = function (a) { var r = nbi(); this.bitwiseTo(a, op_andnot, r); return r; };

    // (public) ~this
    BigInteger.prototype.not = function () {
        var r = nbi();
        for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i];
        r.t = this.t;
        r.s = ~this.s;
        return r;
    };

    // (public) this << n
    BigInteger.prototype.shiftLeft = function (n) {
        var r = nbi();
        if (n < 0) this.rShiftTo(-n, r); else this.lShiftTo(n, r);
        return r;
    };

    // (public) this >> n
    BigInteger.prototype.shiftRight = function (n) {
        var r = nbi();
        if (n < 0) this.lShiftTo(-n, r); else this.rShiftTo(n, r);
        return r;
    };

    // (public) returns index of lowest 1-bit (or -1 if none)
    BigInteger.prototype.getLowestSetBit = function () {
        for (var i = 0; i < this.t; ++i)
            if (this[i] != 0) return i * this.DB + lbit(this[i]);
        if (this.s < 0) return this.t * this.DB;
        return -1;
    };

    // (public) return number of set bits
    BigInteger.prototype.bitCount = function () {
        var r = 0, x = this.s & this.DM;
        for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x);
        return r;
    };

    // (public) true iff nth bit is set
    BigInteger.prototype.testBit = function (n) {
        var j = Math.floor(n / this.DB);
        if (j >= this.t) return (this.s != 0);
        return ((this[j] & (1 << (n % this.DB))) != 0);
    };

    // (public) this | (1<<n)
    BigInteger.prototype.setBit = function (n) { return this.changeBit(n, op_or); };
    // (public) this & ~(1<<n)
    BigInteger.prototype.clearBit = function (n) { return this.changeBit(n, op_andnot); };
    // (public) this ^ (1<<n)
    BigInteger.prototype.flipBit = function (n) { return this.changeBit(n, op_xor); };
    // (public) this + a
    BigInteger.prototype.add = function (a) { var r = nbi(); this.addTo(a, r); return r; };
    // (public) this - a
    BigInteger.prototype.subtract = function (a) { var r = nbi(); this.subTo(a, r); return r; };
    // (public) this * a
    BigInteger.prototype.multiply = function (a) { var r = nbi(); this.multiplyTo(a, r); return r; };
    // (public) this / a
    BigInteger.prototype.divide = function (a) { var r = nbi(); this.divRemTo(a, r, null); return r; };
    // (public) this % a
    BigInteger.prototype.remainder = function (a) { var r = nbi(); this.divRemTo(a, null, r); return r; };
    // (public) [this/a,this%a]
    BigInteger.prototype.divideAndRemainder = function (a) {
        var q = nbi(), r = nbi();
        this.divRemTo(a, q, r);
        return new Array(q, r);
    };

    // (public) this^e % m (HAC 14.85)
    BigInteger.prototype.modPow = function (e, m) {
        var i = e.bitLength(), k, r = nbv(1), z;
        if (i <= 0) return r;
        else if (i < 18) k = 1;
        else if (i < 48) k = 3;
        else if (i < 144) k = 4;
        else if (i < 768) k = 5;
        else k = 6;
        if (i < 8)
            z = new Classic(m);
        else if (m.isEven())
            z = new Barrett(m);
        else
            z = new Montgomery(m);

        // precomputation
        var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
        g[1] = z.convert(this);
        if (k > 1) {
            var g2 = nbi();
            z.sqrTo(g[1], g2);
            while (n <= km) {
                g[n] = nbi();
                z.mulTo(g2, g[n - 2], g[n]);
                n += 2;
            }
        }

        var j = e.t - 1, w, is1 = true, r2 = nbi(), t;
        i = nbits(e[j]) - 1;
        while (j >= 0) {
            if (i >= k1) w = (e[j] >> (i - k1)) & km;
            else {
                w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);
                if (j > 0) w |= e[j - 1] >> (this.DB + i - k1);
            }

            n = k;
            while ((w & 1) == 0) { w >>= 1; --n; }
            if ((i -= n) < 0) { i += this.DB; --j; }
            if (is1) {  // ret == 1, don't bother squaring or multiplying it
                g[w].copyTo(r);
                is1 = false;
            }
            else {
                while (n > 1) { z.sqrTo(r, r2); z.sqrTo(r2, r); n -= 2; }
                if (n > 0) z.sqrTo(r, r2); else { t = r; r = r2; r2 = t; }
                z.mulTo(r2, g[w], r);
            }

            while (j >= 0 && (e[j] & (1 << i)) == 0) {
                z.sqrTo(r, r2); t = r; r = r2; r2 = t;
                if (--i < 0) { i = this.DB - 1; --j; }
            }
        }
        return z.revert(r);
    };

    // (public) 1/this % m (HAC 14.61)
    BigInteger.prototype.modInverse = function (m) {
        var ac = m.isEven();
        if ((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;
        var u = m.clone(), v = this.clone();
        var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
        while (u.signum() != 0) {
            while (u.isEven()) {
                u.rShiftTo(1, u);
                if (ac) {
                    if (!a.isEven() || !b.isEven()) { a.addTo(this, a); b.subTo(m, b); }
                    a.rShiftTo(1, a);
                }
                else if (!b.isEven()) b.subTo(m, b);
                b.rShiftTo(1, b);
            }
            while (v.isEven()) {
                v.rShiftTo(1, v);
                if (ac) {
                    if (!c.isEven() || !d.isEven()) { c.addTo(this, c); d.subTo(m, d); }
                    c.rShiftTo(1, c);
                }
                else if (!d.isEven()) d.subTo(m, d);
                d.rShiftTo(1, d);
            }
            if (u.compareTo(v) >= 0) {
                u.subTo(v, u);
                if (ac) a.subTo(c, a);
                b.subTo(d, b);
            }
            else {
                v.subTo(u, v);
                if (ac) c.subTo(a, c);
                d.subTo(b, d);
            }
        }
        if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
        if (d.compareTo(m) >= 0) return d.subtract(m);
        if (d.signum() < 0) d.addTo(m, d); else return d;
        if (d.signum() < 0) return d.add(m); else return d;
    };


    // (public) this^e
    BigInteger.prototype.pow = function (e) { return this.exp(e, new NullExp()); };

    // (public) gcd(this,a) (HAC 14.54)
    BigInteger.prototype.gcd = function (a) {
        var x = (this.s < 0) ? this.negate() : this.clone();
        var y = (a.s < 0) ? a.negate() : a.clone();
        if (x.compareTo(y) < 0) { var t = x; x = y; y = t; }
        var i = x.getLowestSetBit(), g = y.getLowestSetBit();
        if (g < 0) return x;
        if (i < g) g = i;
        if (g > 0) {
            x.rShiftTo(g, x);
            y.rShiftTo(g, y);
        }
        while (x.signum() > 0) {
            if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);
            if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);
            if (x.compareTo(y) >= 0) {
                x.subTo(y, x);
                x.rShiftTo(1, x);
            }
            else {
                y.subTo(x, y);
                y.rShiftTo(1, y);
            }
        }
        if (g > 0) y.lShiftTo(g, y);
        return y;
    };

    // (public) test primality with certainty >= 1-.5^t
    BigInteger.prototype.isProbablePrime = function (t) {
        var i, x = this.abs();
        if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
            for (i = 0; i < lowprimes.length; ++i)
                if (x[0] == lowprimes[i]) return true;
            return false;
        }
        if (x.isEven()) return false;
        i = 1;
        while (i < lowprimes.length) {
            var m = lowprimes[i], j = i + 1;
            while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];
            m = x.modInt(m);
            while (i < j) if (m % lowprimes[i++] == 0) return false;
        }
        return x.millerRabin(t);
    };


    // JSBN-specific extension

    // (public) this^2
    BigInteger.prototype.square = function () { var r = nbi(); this.squareTo(r); return r; };


    // NOTE: BigInteger interfaces not implemented in jsbn:
    // BigInteger(int signum, byte[] magnitude)
    // double doubleValue()
    // float floatValue()
    // int hashCode()
    // long longValue()
    // static BigInteger valueOf(long val)



    // Copyright Stephan Thomas (start) --- //
    // https://raw.github.com/bitcoinjs/bitcoinjs-lib/07f9d55ccb6abd962efb6befdd37671f85ea4ff9/src/util.js
    // BigInteger monkey patching
    BigInteger.valueOf = nbv;

    /**
    * Returns a byte array representation of the big integer.
    *
    * This returns the absolute of the contained value in big endian
    * form. A value of zero results in an empty array.
    */
    BigInteger.prototype.toByteArrayUnsigned = function () {
        var ba = this.abs().toByteArray();
        if (ba.length) {
            if (ba[0] == 0) {
                ba = ba.slice(1);
            }
            return ba.map(function (v) {
                return (v < 0) ? v + 256 : v;
            });
        } else {
            // Empty array, nothing to do
            return ba;
        }
    };

    /**
    * Turns a byte array into a big integer.
    *
    * This function will interpret a byte array as a big integer in big
    * endian notation and ignore leading zeros.
    */
    BigInteger.fromByteArrayUnsigned = function (ba) {
        if (!ba.length) {
            return ba.valueOf(0);
        } else if (ba[0] & 0x80) {
            // Prepend a zero so the BigInteger class doesn't mistake this
            // for a negative integer.
            return new BigInteger([0].concat(ba));
        } else {
            return new BigInteger(ba);
        }
    };

    /**
    * Converts big integer to signed byte representation.
    *
    * The format for this value uses a the most significant bit as a sign
    * bit. If the most significant bit is already occupied by the
    * absolute value, an extra byte is prepended and the sign bit is set
    * there.
    *
    * Examples:
    *
    *      0 =>     0x00
    *      1 =>     0x01
    *     -1 =>     0x81
    *    127 =>     0x7f
    *   -127 =>     0xff
    *    128 =>   0x0080
    *   -128 =>   0x8080
    *    255 =>   0x00ff
    *   -255 =>   0x80ff
    *  16300 =>   0x3fac
    * -16300 =>   0xbfac
    *  62300 => 0x00f35c
    * -62300 => 0x80f35c
    */
    BigInteger.prototype.toByteArraySigned = function () {
        var val = this.abs().toByteArrayUnsigned();
        var neg = this.compareTo(BigInteger.ZERO) < 0;

        if (neg) {
            if (val[0] & 0x80) {
                val.unshift(0x80);
            } else {
                val[0] |= 0x80;
            }
        } else {
            if (val[0] & 0x80) {
                val.unshift(0x00);
            }
        }

        return val;
    };

    /**
    * Parse a signed big integer byte representation.
    *
    * For details on the format please see BigInteger.toByteArraySigned.
    */
    BigInteger.fromByteArraySigned = function (ba) {
        // Check for negative value
        if (ba[0] & 0x80) {
            // Remove sign bit
            ba[0] &= 0x7f;

            return BigInteger.fromByteArrayUnsigned(ba).negate();
        } else {
            return BigInteger.fromByteArrayUnsigned(ba);
        }
    };
    // Copyright Stephan Thomas (end) --- //




    // ****** REDUCTION ******* //

    // Modular reduction using "classic" algorithm
    var Classic = window.Classic = function Classic(m) { this.m = m; }
    Classic.prototype.convert = function (x) {
        if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
        else return x;
    };
    Classic.prototype.revert = function (x) { return x; };
    Classic.prototype.reduce = function (x) { x.divRemTo(this.m, null, x); };
    Classic.prototype.mulTo = function (x, y, r) { x.multiplyTo(y, r); this.reduce(r); };
    Classic.prototype.sqrTo = function (x, r) { x.squareTo(r); this.reduce(r); };





    // Montgomery reduction
    var Montgomery = window.Montgomery = function Montgomery(m) {
        this.m = m;
        this.mp = m.invDigit();
        this.mpl = this.mp & 0x7fff;
        this.mph = this.mp >> 15;
        this.um = (1 << (m.DB - 15)) - 1;
        this.mt2 = 2 * m.t;
    }
    // xR mod m
    Montgomery.prototype.convert = function (x) {
        var r = nbi();
        x.abs().dlShiftTo(this.m.t, r);
        r.divRemTo(this.m, null, r);
        if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);
        return r;
    }
    // x/R mod m
    Montgomery.prototype.revert = function (x) {
        var r = nbi();
        x.copyTo(r);
        this.reduce(r);
        return r;
    };
    // x = x/R mod m (HAC 14.32)
    Montgomery.prototype.reduce = function (x) {
        while (x.t <= this.mt2) // pad x so am has enough room later
            x[x.t++] = 0;
        for (var i = 0; i < this.m.t; ++i) {
            // faster way of calculating u0 = x[i]*mp mod DV
            var j = x[i] & 0x7fff;
            var u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;
            // use am to combine the multiply-shift-add into one call
            j = i + this.m.t;
            x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
            // propagate carry
            while (x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }
        }
        x.clamp();
        x.drShiftTo(this.m.t, x);
        if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
    };
    // r = "xy/R mod m"; x,y != r
    Montgomery.prototype.mulTo = function (x, y, r) { x.multiplyTo(y, r); this.reduce(r); };
    // r = "x^2/R mod m"; x != r
    Montgomery.prototype.sqrTo = function (x, r) { x.squareTo(r); this.reduce(r); };





    // A "null" reducer
    var NullExp = window.NullExp = function NullExp() { }
    NullExp.prototype.convert = function (x) { return x; };
    NullExp.prototype.revert = function (x) { return x; };
    NullExp.prototype.mulTo = function (x, y, r) { x.multiplyTo(y, r); };
    NullExp.prototype.sqrTo = function (x, r) { x.squareTo(r); };





    // Barrett modular reduction
    var Barrett = window.Barrett = function Barrett(m) {
        // setup Barrett
        this.r2 = nbi();
        this.q3 = nbi();
        BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
        this.mu = this.r2.divide(m);
        this.m = m;
    }
    Barrett.prototype.convert = function (x) {
        if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);
        else if (x.compareTo(this.m) < 0) return x;
        else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }
    };
    Barrett.prototype.revert = function (x) { return x; };
    // x = x mod m (HAC 14.42)
    Barrett.prototype.reduce = function (x) {
        x.drShiftTo(this.m.t - 1, this.r2);
        if (x.t > this.m.t + 1) { x.t = this.m.t + 1; x.clamp(); }
        this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
        this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
        while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);
        x.subTo(this.r2, x);
        while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
    };
    // r = x*y mod m; x,y != r
    Barrett.prototype.mulTo = function (x, y, r) { x.multiplyTo(y, r); this.reduce(r); };
    // r = x^2 mod m; x != r
    Barrett.prototype.sqrTo = function (x, r) { x.squareTo(r); this.reduce(r); };

})();
</script>
<script type="text/javascript">
/*
Copyright (c) 2011 Stefan Thomas

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

//https://raw.github.com/bitcoinjs/bitcoinjs-lib/1a7fc9d063f864058809d06ef4542af40be3558f/src/bitcoin.js
(function (exports) {
    var Bitcoin = exports;
})(
    'object' === typeof module ? module.exports : (window.Bitcoin = {})
);
</script>
<script type="text/javascript">
//https://raw.github.com/bitcoinjs/bitcoinjs-lib/c952aaeb3ee472e3776655b8ea07299ebed702c7/src/base58.js
(function (Bitcoin) {
    Bitcoin.Base58 = {
        alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
        validRegex: /^[1-9A-HJ-NP-Za-km-z]+$/,
        base: BigInteger.valueOf(58),

        /**
        * Convert a byte array to a base58-encoded string.
        *
        * Written by Mike Hearn for BitcoinJ.
        *   Copyright (c) 2011 Google Inc.
        *
        * Ported to JavaScript by Stefan Thomas.
        */
        encode: function (input) {
            var bi = BigInteger.fromByteArrayUnsigned(input);
            var chars = [];

            while (bi.compareTo(B58.base) >= 0) {
                var mod = bi.mod(B58.base);
                chars.unshift(B58.alphabet[mod.intValue()]);
                bi = bi.subtract(mod).divide(B58.base);
            }
            chars.unshift(B58.alphabet[bi.intValue()]);

            // Convert leading zeros too.
            for (var i = 0; i < input.length; i++) {
                if (input[i] == 0x00) {
                    chars.unshift(B58.alphabet[0]);
                } else break;
            }

            return chars.join('');
        },

        /**
        * Convert a base58-encoded string to a byte array.
        *
        * Written by Mike Hearn for BitcoinJ.
        *   Copyright (c) 2011 Google Inc.
        *
        * Ported to JavaScript by Stefan Thomas.
        */
        decode: function (input) {
            var bi = BigInteger.valueOf(0);
            var leadingZerosNum = 0;
            for (var i = input.length - 1; i >= 0; i--) {
                var alphaIndex = B58.alphabet.indexOf(input[i]);
                if (alphaIndex < 0) {
                    throw `Invalid character '${input[i]}, byte ${i} of '${input}'`;
                }
                bi = bi.add(BigInteger.valueOf(alphaIndex)
                                .multiply(B58.base.pow(input.length - 1 - i)));

                // This counts leading zero bytes
                if (input[i] == "1") leadingZerosNum++;
                else leadingZerosNum = 0;
            }
            var bytes = bi.toByteArrayUnsigned();

            // Add leading zeros
            while (leadingZerosNum-- > 0) bytes.unshift(0);

            return bytes;
        }
    };

    var B58 = Bitcoin.Base58;
})(
    'undefined' != typeof Bitcoin ? Bitcoin : module.exports
);
</script>
<script type="text/javascript">
//https://raw.github.com/bitcoinjs/bitcoinjs-lib/09e8c6e184d6501a0c2c59d73ca64db5c0d3eb95/src/address.js
Bitcoin.Address = function (bytes,version) {
    if ("string" == typeof bytes) {
        bytes = Bitcoin.Address.decodeString(bytes);
    }
    this.hash = bytes;
    if (!version) version = 0;
    this.version = version;
};

Bitcoin.Address.networkVersion = window.networkVersion; // multiple coin support

/**
* Serialize this object as a standard Bitcoin address.
*
* Returns the address as a base58-encoded string in the standardized format.
*/
Bitcoin.Address.prototype.toString = function (format,prefix) {

    // Get a copy of the hash
    var hash = this.hash.slice(0);
    if (format == "p2wpkh-p2sh") {
        hash.unshift(0,20);
        hash = Crypto.RIPEMD160(Crypto.SHA256(hash, { asBytes: true }), { asBytes: true });
    }

    if (format == "p2wpkh") {
        var ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l'

        // pre-compute lookup table
        var ALPHABET_MAP = {}
        for (var z = 0; z < ALPHABET.length; z++) {
          var x = ALPHABET.charAt(z)

          if (ALPHABET_MAP[x] !== undefined) throw new TypeError(x + ' is ambiguous')
          ALPHABET_MAP[x] = z
        }

        function polymodStep (pre) {
          var b = pre >> 25
          return ((pre & 0x1FFFFFF) << 5) ^
            (-((b >> 0) & 1) & 0x3b6a57b2) ^
            (-((b >> 1) & 1) & 0x26508e6d) ^
            (-((b >> 2) & 1) & 0x1ea119fa) ^
            (-((b >> 3) & 1) & 0x3d4233dd) ^
            (-((b >> 4) & 1) & 0x2a1462b3)
        }

        function prefixChk (prefix) {
          var chk = 1
          for (var i = 0; i < prefix.length; ++i) {
            var c = prefix.charCodeAt(i)
            if (c < 33 || c > 126) return 'Invalid prefix (' + prefix + ')'

            chk = polymodStep(chk) ^ (c >> 5)
          }
          chk = polymodStep(chk)

          for (i = 0; i < prefix.length; ++i) {
            var v = prefix.charCodeAt(i)
            chk = polymodStep(chk) ^ (v & 0x1f)
          }
          return chk
        }

        function encode (prefix, words, LIMIT) {
          LIMIT = LIMIT || 90
          if ((prefix.length + 7 + words.length) > LIMIT) throw new TypeError('Exceeds length limit')

          prefix = prefix.toLowerCase()

          // determine chk mod
          var chk = prefixChk(prefix)
          if (typeof chk === 'string') throw new Error(chk)

          var result = prefix + '1';
          for (var i = 0; i < words.length; ++i) {
            var x = words[i]
            if ((x >> 5) !== 0) throw new Error('Non 5-bit word')

            chk = polymodStep(chk) ^ x
            result += ALPHABET.charAt(x)
                }

          for (i = 0; i < 6; ++i) {
            chk = polymodStep(chk)
          }
          chk ^= 1

          for (i = 0; i < 6; ++i) {
            var v = (chk >> ((5 - i) * 5)) & 0x1f
            result += ALPHABET.charAt(v)
          }

          return result
        }

        function __decode (str, LIMIT) {
          LIMIT = LIMIT || 90
          if (str.length < 8) return str + ' too short'
          if (str.length > LIMIT) return 'Exceeds length limit'

          // don't allow mixed case
          var lowered = str.toLowerCase()
          var uppered = str.toUpperCase()
          if (str !== lowered && str !== uppered) return 'Mixed-case string ' + str
          str = lowered

          var split = str.lastIndexOf('1')
          if (split === -1) return 'No separator character for ' + str
          if (split === 0) return 'Missing prefix for ' + str

          var prefix = str.slice(0, split)
          var wordChars = str.slice(split + 1)
          if (wordChars.length < 6) return 'Data too short'

          var chk = prefixChk(prefix)
          if (typeof chk === 'string') return chk

          var words = []
          for (var i = 0; i < wordChars.length; ++i) {
            var c = wordChars.charAt(i)
            var v = ALPHABET_MAP[c]
            if (v === undefined) return 'Unknown character ' + c
            chk = polymodStep(chk) ^ v

            // not in the checksum?
            if (i + 6 >= wordChars.length) continue
            words.push(v)
          }

          if (chk !== 1) return 'Invalid checksum for ' + str
          return { prefix: prefix, words: words }
        }

        function decodeUnsafe () {
          var res = __decode.apply(null, arguments)
          if (typeof res === 'object') return res
        }

        function decode (str) {
          var res = __decode.apply(null, arguments)
          if (typeof res === 'object') return res

          throw new Error(res)
        }

        function convert (data, inBits, outBits, pad) {
          var value = 0
          var bits = 0
          var maxV = (1 << outBits) - 1

          var result = []
          for (var i = 0; i < data.length; ++i) {
            value = (value << inBits) | data[i]
            bits += inBits

            while (bits >= outBits) {
              bits -= outBits
              result.push((value >> bits) & maxV)
            }
          }

          if (pad) {
            if (bits > 0) {
              result.push((value << (outBits - bits)) & maxV)
            }
          } else {
            if (bits >= inBits) return 'Excess padding'
            if ((value << (outBits - bits)) & maxV) return 'Non-zero padding'
          }

          return result
        }

        function toWordsUnsafe (bytes) {
          var res = convert(bytes, 8, 5, true)
          if (Array.isArray(res)) return res
        }

        function toWords (bytes) {
          var res = convert(bytes, 8, 5, true)
          if (Array.isArray(res)) return res

          throw new Error(res)
        }

        function fromWordsUnsafe (words) {
          var res = convert(words, 5, 8, false)
          if (Array.isArray(res)) return res
        }

        function fromWords (words) {
          var res = convert(words, 5, 8, false)
          if (Array.isArray(res)) return res

          throw new Error(res)
        }
        var words = toWords(hash);
        words.unshift(0);
        return encode(prefix,words);
    }

    // Version
    hash.unshift(this.version);
    var checksum = Crypto.SHA256(Crypto.SHA256(hash, { asBytes: true }), { asBytes: true });
    var bytes = hash.concat(checksum.slice(0, 4));
    return Bitcoin.Base58.encode(bytes);
};

Bitcoin.Address.prototype.getHashBase64 = function () {
    return Crypto.util.bytesToBase64(this.hash);
};

/**
* Parse a Bitcoin address contained in a string.
*/
Bitcoin.Address.decodeString = function (string) {
    if (string.substr(0,2) == "bc" || string.substr(0,3) == "ltc") {
        var ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l'

        // pre-compute lookup table
        var ALPHABET_MAP = {}
        for (var z = 0; z < ALPHABET.length; z++) {
          var x = ALPHABET.charAt(z)

          if (ALPHABET_MAP[x] !== undefined) throw new TypeError(x + ' is ambiguous')
          ALPHABET_MAP[x] = z
        }

        function polymodStep (pre) {
          var b = pre >> 25
          return ((pre & 0x1FFFFFF) << 5) ^
            (-((b >> 0) & 1) & 0x3b6a57b2) ^
            (-((b >> 1) & 1) & 0x26508e6d) ^
            (-((b >> 2) & 1) & 0x1ea119fa) ^
            (-((b >> 3) & 1) & 0x3d4233dd) ^
            (-((b >> 4) & 1) & 0x2a1462b3)
        }

        function prefixChk (prefix) {
          var chk = 1
          for (var i = 0; i < prefix.length; ++i) {
            var c = prefix.charCodeAt(i)
            if (c < 33 || c > 126) return 'Invalid prefix (' + prefix + ')'

            chk = polymodStep(chk) ^ (c >> 5)
          }
          chk = polymodStep(chk)

          for (i = 0; i < prefix.length; ++i) {
            var v = prefix.charCodeAt(i)
            chk = polymodStep(chk) ^ (v & 0x1f)
          }
          return chk
        }

        function __decode (str, LIMIT) {
          LIMIT = LIMIT || 90
          if (str.length < 8) return str + ' too short'
          if (str.length > LIMIT) return 'Exceeds length limit'

          // don't allow mixed case
          var lowered = str.toLowerCase()
          var uppered = str.toUpperCase()
          if (str !== lowered && str !== uppered) return 'Mixed-case string ' + str
          str = lowered

          var split = str.lastIndexOf('1')
          if (split === -1) return 'No separator character for ' + str
          if (split === 0) return 'Missing prefix for ' + str

          var prefix = str.slice(0, split)
          var wordChars = str.slice(split + 1)
          if (wordChars.length < 6) return 'Data too short'

          var chk = prefixChk(prefix)
          if (typeof chk === 'string') return chk

          var words = []
          for (var i = 0; i < wordChars.length; ++i) {
            var c = wordChars.charAt(i)
            var v = ALPHABET_MAP[c]
            if (v === undefined) return 'Unknown character ' + c
            chk = polymodStep(chk) ^ v

            // not in the checksum?
            if (i + 6 >= wordChars.length) continue
            words.push(v)
          }

          if (chk !== 1) return 'Invalid checksum for ' + str
          return { prefix: prefix, words: words }
        }

        function decodeUnsafe () {
          var res = __decode.apply(null, arguments)
          if (typeof res === 'object') return res
        }


        function convert (data, inBits, outBits, pad) {
          var value = 0
          var bits = 0
          var maxV = (1 << outBits) - 1

          var result = []
          for (var i = 0; i < data.length; ++i) {
            value = (value << inBits) | data[i]
            bits += inBits

            while (bits >= outBits) {
              bits -= outBits
              result.push((value >> bits) & maxV)
            }
          }

          if (pad) {
            if (bits > 0) {
              result.push((value << (outBits - bits)) & maxV)
            }
          } else {
            if (bits >= inBits) return `Excess padding ${bits}>=${inBits}`;
            if ((value << (outBits - bits)) & maxV) return 'Non-zero padding'
          }

          return result
        }

        var words = decodeUnsafe(string);
        if (!(typeof words === "object")) throw "Bad checksum";
        words.words.shift();
        var hash = convert(words.words, 5, 8, true);
        this.version = 0;
        return hash;
    }
    var bytes = Bitcoin.Base58.decode(string);
    var hash = bytes.slice(0, 21);
    var checksum = Crypto.SHA256(Crypto.SHA256(hash, { asBytes: true }), { asBytes: true });

    if (checksum[0] != bytes[21] ||
            checksum[1] != bytes[22] ||
            checksum[2] != bytes[23] ||
            checksum[3] != bytes[24]) {
        throw "Checksum validation failed!";
    }

    var version = hash.shift();
    return hash;
};
</script>
<script type="text/javascript">
//https://raw.github.com/bitcoinjs/bitcoinjs-lib/e90780d3d3b8fc0d027d2bcb38b80479902f223e/src/ecdsa.js
Bitcoin.ECDSA = (function () {
    var ecparams = EllipticCurve.getSECCurveByName("secp256k1");
    var rng = new SecureRandom();

    var P_OVER_FOUR = null;

    function implShamirsTrick(P, k, Q, l) {
        var m = Math.max(k.bitLength(), l.bitLength());
        var Z = P.add2D(Q);
        var R = P.curve.getInfinity();

        for (var i = m - 1; i >= 0; --i) {
            R = R.twice2D();

            R.z = BigInteger.ONE;

            if (k.testBit(i)) {
                if (l.testBit(i)) {
                    R = R.add2D(Z);
                } else {
                    R = R.add2D(P);
                }
            } else {
                if (l.testBit(i)) {
                    R = R.add2D(Q);
                }
            }
        }

        return R;
    };

    var ECDSA = {
        getBigRandom: function (limit) {
            return new BigInteger(limit.bitLength(), rng)
                .mod(limit.subtract(BigInteger.ONE))
                .add(BigInteger.ONE);
        },
        sign: function (hash, priv) {
            var d = priv;
            var n = ecparams.getN();
            var e = BigInteger.fromByteArrayUnsigned(hash);

            do {
                var k = ECDSA.getBigRandom(n);
                var G = ecparams.getG();
                var Q = G.multiply(k);
                var r = Q.getX().toBigInteger().mod(n);
            } while (r.compareTo(BigInteger.ZERO) <= 0);

            var s = k.modInverse(n).multiply(e.add(d.multiply(r))).mod(n);

            return ECDSA.serializeSig(r, s);
        },

        verify: function (hash, sig, pubkey) {
            var r, s;
            if (Bitcoin.Util.isArray(sig)) {
                var obj = ECDSA.parseSig(sig);
                r = obj.r;
                s = obj.s;
            } else if ("object" === typeof sig && sig.r && sig.s) {
                r = sig.r;
                s = sig.s;
            } else {
                throw "Invalid value for signature";
            }

            var Q;
            if (pubkey instanceof ec.PointFp) {
                Q = pubkey;
            } else if (Bitcoin.Util.isArray(pubkey)) {
                Q = EllipticCurve.PointFp.decodeFrom(ecparams.getCurve(), pubkey);
            } else {
                throw "Invalid format for pubkey value, must be byte array or ec.PointFp";
            }
            var e = BigInteger.fromByteArrayUnsigned(hash);

            return ECDSA.verifyRaw(e, r, s, Q);
        },

        verifyRaw: function (e, r, s, Q) {
            var n = ecparams.getN();
            var G = ecparams.getG();

            if (r.compareTo(BigInteger.ONE) < 0 ||
          r.compareTo(n) >= 0)
                return false;

            if (s.compareTo(BigInteger.ONE) < 0 ||
          s.compareTo(n) >= 0)
                return false;

            var c = s.modInverse(n);

            var u1 = e.multiply(c).mod(n);
            var u2 = r.multiply(c).mod(n);

            // TODO(!!!): For some reason Shamir's trick isn't working with
            // signed message verification!? Probably an implementation
            // error!
            //var point = implShamirsTrick(G, u1, Q, u2);
            var point = G.multiply(u1).add(Q.multiply(u2));

            var v = point.getX().toBigInteger().mod(n);

            return v.equals(r);
        },

        /**
        * Serialize a signature into DER format.
        *
        * Takes two BigIntegers representing r and s and returns a byte array.
        */
        serializeSig: function (r, s) {
            var rBa = r.toByteArraySigned();
            var sBa = s.toByteArraySigned();

            var sequence = [];
            sequence.push(0x02); // INTEGER
            sequence.push(rBa.length);
            sequence = sequence.concat(rBa);

            sequence.push(0x02); // INTEGER
            sequence.push(sBa.length);
            sequence = sequence.concat(sBa);

            sequence.unshift(sequence.length);
            sequence.unshift(0x30); // SEQUENCE

            return sequence;
        },

        /**
        * Parses a byte array containing a DER-encoded signature.
        *
        * This function will return an object of the form:
        *
        * {
        *   r: BigInteger,
        *   s: BigInteger
        * }
        */
        parseSig: function (sig) {
            var cursor;
            if (sig[0] != 0x30)
                throw new Error("Signature not a valid DERSequence");

            cursor = 2;
            if (sig[cursor] != 0x02)
                throw new Error("First element in signature must be a DERInteger"); ;
            var rBa = sig.slice(cursor + 2, cursor + 2 + sig[cursor + 1]);

            cursor += 2 + sig[cursor + 1];
            if (sig[cursor] != 0x02)
                throw new Error("Second element in signature must be a DERInteger");
            var sBa = sig.slice(cursor + 2, cursor + 2 + sig[cursor + 1]);

            cursor += 2 + sig[cursor + 1];

            //if (cursor != sig.length)
            //  throw new Error("Extra bytes in signature");

            var r = BigInteger.fromByteArrayUnsigned(rBa);
            var s = BigInteger.fromByteArrayUnsigned(sBa);

            return { r: r, s: s };
        },

        parseSigCompact: function (sig) {
            if (sig.length !== 65) {
                throw "Signature has the wrong length";
            }

            // Signature is prefixed with a type byte storing three bits of
            // information.
            var i = sig[0] - 27;
            if (i < 0 || i > 7) {
                throw "Invalid signature type";
            }

            var n = ecparams.getN();
            var r = BigInteger.fromByteArrayUnsigned(sig.slice(1, 33)).mod(n);
            var s = BigInteger.fromByteArrayUnsigned(sig.slice(33, 65)).mod(n);

            return { r: r, s: s, i: i };
        },

        /**
        * Recover a public key from a signature.
        *
        * See SEC 1: Elliptic Curve Cryptography, section 4.1.6, "Public
        * Key Recovery Operation".
        *
        * http://www.secg.org/download/aid-780/sec1-v2.pdf
        */
        recoverPubKey: function (r, s, hash, i) {
            // The recovery parameter i has two bits.
            i = i & 3;

            // The less significant bit specifies whether the y coordinate
            // of the compressed point is even or not.
            var isYEven = i & 1;

            // The more significant bit specifies whether we should use the
            // first or second candidate key.
            var isSecondKey = i >> 1;

            var n = ecparams.getN();
            var G = ecparams.getG();
            var curve = ecparams.getCurve();
            var p = curve.getQ();
            var a = curve.getA().toBigInteger();
            var b = curve.getB().toBigInteger();

            // We precalculate (p + 1) / 4 where p is if the field order
            if (!P_OVER_FOUR) {
                P_OVER_FOUR = p.add(BigInteger.ONE).divide(BigInteger.valueOf(4));
            }

            // 1.1 Compute x
            var x = isSecondKey ? r.add(n) : r;

            // 1.3 Convert x to point
            var alpha = x.multiply(x).multiply(x).add(a.multiply(x)).add(b).mod(p);
            var beta = alpha.modPow(P_OVER_FOUR, p);

            var xorOdd = beta.isEven() ? (i % 2) : ((i + 1) % 2);
            // If beta is even, but y isn't or vice versa, then convert it,
            // otherwise we're done and y == beta.
            var y = (beta.isEven() ? !isYEven : isYEven) ? beta : p.subtract(beta);

            // 1.4 Check that nR is at infinity
            var R = new EllipticCurve.PointFp(curve,
                            curve.fromBigInteger(x),
                            curve.fromBigInteger(y));
            R.validate();

            // 1.5 Compute e from M
            var e = BigInteger.fromByteArrayUnsigned(hash);
            var eNeg = BigInteger.ZERO.subtract(e).mod(n);

            // 1.6 Compute Q = r^-1 (sR - eG)
            var rInv = r.modInverse(n);
            var Q = implShamirsTrick(R, s, G, eNeg).multiply(rInv);

            Q.validate();
            if (!ECDSA.verifyRaw(e, r, s, Q)) {
                throw "Pubkey recovery unsuccessful";
            }

            var pubKey = new Bitcoin.ECKey();
            pubKey.pub = Q;
            return pubKey;
        },

        /**
        * Calculate pubkey extraction parameter.
        *
        * When extracting a pubkey from a signature, we have to
        * distinguish four different cases. Rather than putting this
        * burden on the verifier, Bitcoin includes a 2-bit value with the
        * signature.
        *
        * This function simply tries all four cases and returns the value
        * that resulted in a successful pubkey recovery.
        */
        calcPubkeyRecoveryParam: function (address, r, s, hash) {
            for (var i = 0; i < 4; i++) {
                try {
                    var pubkey = Bitcoin.ECDSA.recoverPubKey(r, s, hash, i);
                    if (pubkey.getBitcoinAddress().toString() == address) {
                        return i;
                    }
                } catch (e) { }
            }
            throw "Unable to find valid recovery factor";
        }
    };

    return ECDSA;
})();
</script>
<script type="text/javascript">
//https://raw.github.com/pointbiz/bitcoinjs-lib/9b2f94a028a7bc9bed94e0722563e9ff1d8e8db8/src/eckey.js
Bitcoin.ECKey = (function () {
    var ECDSA = Bitcoin.ECDSA;
    var ecparams = EllipticCurve.getSECCurveByName("secp256k1");
    var rng = new SecureRandom();

    var ECKey = function (input) {
        if (!input) {
            // Generate new key
            var n = ecparams.getN();
            this.priv = ECDSA.getBigRandom(n);
        } else if (input instanceof BigInteger) {
            // Input is a private key value
            this.priv = input;
        } else if (Bitcoin.Util.isArray(input)) {
            // Prepend zero byte to prevent interpretation as negative integer
            this.priv = BigInteger.fromByteArrayUnsigned(input);
        } else if ("string" == typeof input) {
            var bytes = null;
            if (ECKey.isWalletImportFormat(input)) {
                bytes = ECKey.decodeWalletImportFormat(input);
            } else if (ECKey.isCompressedWalletImportFormat(input)) {
                bytes = ECKey.decodeCompressedWalletImportFormat(input);
                this.compressed = true;
            } else if (ECKey.isMiniFormat(input)) {
                bytes = Crypto.SHA256(input, { asBytes: true });
            } else if (ECKey.isHexFormat(input)) {
                bytes = Crypto.util.hexToBytes(input);
            } else if (ECKey.isBase64Format(input)) {
                bytes = Crypto.util.base64ToBytes(input);
            }

            if (ECKey.isBase6Format(input)) {
                this.priv = new BigInteger(input, 6);
            } else if (bytes == null || bytes.length != 33) {
                this.priv = null;
            } else {
                // Prepend zero byte to prevent interpretation as negative integer
                this.wif_version = bytes.shift();
                this.priv = BigInteger.fromByteArrayUnsigned(bytes);
            }
        }

        this.compressed = (this.compressed == undefined) ? !!ECKey.compressByDefault : this.compressed;
    };

    ECKey.privateKeyPrefix = window.privateKeyPrefix;

    /**
    * Whether public keys should be returned compressed by default.
    */
    ECKey.compressByDefault = false;

    /**
    * Set whether the public key should be returned compressed or not.
    */
    ECKey.prototype.setCompressed = function (v) {
        this.compressed = !!v;
        if (this.pubPoint) this.pubPoint.compressed = this.compressed;
        return this;
    };

    /*
    * Return public key as a byte array in DER encoding
    */
    ECKey.prototype.getPub = function () {
        if (this.compressed) {
            if (this.pubComp) return this.pubComp;
            return this.pubComp = this.getPubPoint().getEncoded(1);
        } else {
            if (this.pubUncomp) return this.pubUncomp;
            return this.pubUncomp = this.getPubPoint().getEncoded(0);
        }
    };

    /**
    * Return public point as ECPoint object.
    */
    ECKey.prototype.getPubPoint = function () {
        if (!this.pubPoint) {
            this.pubPoint = ecparams.getG().multiply(this.priv);
            this.pubPoint.compressed = this.compressed;
        }
        return this.pubPoint;
    };

    ECKey.prototype.getPubKeyHex = function () {
        if (this.compressed) {
            if (this.pubKeyHexComp) return this.pubKeyHexComp;
            return this.pubKeyHexComp = Crypto.util.bytesToHex(this.getPub()).toString().toUpperCase();
        } else {
            if (this.pubKeyHexUncomp) return this.pubKeyHexUncomp;
            return this.pubKeyHexUncomp = Crypto.util.bytesToHex(this.getPub()).toString().toUpperCase();
        }
    };

    /**
    * Get the pubKeyHash for this key.
    *
    * This is calculated as RIPE160(SHA256([encoded pubkey])) and returned as
    * a byte array.
    */
    ECKey.prototype.getPubKeyHash = function () {
        if (this.compressed) {
            if (this.pubKeyHashComp) return this.pubKeyHashComp;
            return this.pubKeyHashComp = Bitcoin.Util.sha256ripe160(this.getPub());
        } else {
            if (this.pubKeyHashUncomp) return this.pubKeyHashUncomp;
            return this.pubKeyHashUncomp = Bitcoin.Util.sha256ripe160(this.getPub());
        }
    };

    ECKey.prototype.getBitcoinAddress = function (version,format,prefix) {
        var hash = this.getPubKeyHash();
        var addr = new Bitcoin.Address(hash,version)
        return addr.toString(format,prefix);
    };

    /*
    * Takes a public point as a hex string or byte array
    */
    ECKey.prototype.setPub = function (pub) {
        // byte array
        if (Bitcoin.Util.isArray(pub)) {
            pub = Crypto.util.bytesToHex(pub).toString().toUpperCase();
        }
        var ecPoint = ecparams.getCurve().decodePointHex(pub);
        this.setCompressed(ecPoint.compressed);
        this.pubPoint = ecPoint;
        return this;
    };

    // Sipa Private Key Wallet Import Format
    ECKey.prototype.getBitcoinWalletImportFormat = function (prefix) {
        var bytes = this.getBitcoinPrivateKeyByteArray();
        bytes.unshift(prefix); // prepend 0x80 byte
        if (this.compressed) bytes.push(0x01); // append 0x01 byte for compressed format
        var checksum = Crypto.SHA256(Crypto.SHA256(bytes, { asBytes: true }), { asBytes: true });
        bytes = bytes.concat(checksum.slice(0, 4));
        var privWif = Bitcoin.Base58.encode(bytes);
        return privWif;
    };

    // Private Key Hex Format
    ECKey.prototype.getBitcoinHexFormat = function () {
        return Crypto.util.bytesToHex(this.getBitcoinPrivateKeyByteArray()).toString().toUpperCase();
    };

    // Private Key Base64 Format
    ECKey.prototype.getBitcoinBase64Format = function () {
        return Crypto.util.bytesToBase64(this.getBitcoinPrivateKeyByteArray());
    };

    ECKey.prototype.getBitcoinPrivateKeyByteArray = function () {
        // Get a copy of private key as a byte array
        var bytes = this.priv.toByteArrayUnsigned();
        // zero pad if private key is less than 32 bytes
        while (bytes.length < 32) bytes.unshift(0x00);
        return bytes;
    };

    ECKey.prototype.toString = function (format) {
        format = format || "";
        if (format.toString().toLowerCase() == "base64" || format.toString().toLowerCase() == "b64") {
            return this.getBitcoinBase64Format();
        }
        // Wallet Import Format
        else if (format.toString().toLowerCase() == "wif") {
            return this.getBitcoinWalletImportFormat();
        }
        else {
            return this.getBitcoinHexFormat();
        }
    };

    ECKey.prototype.sign = function (hash) {
        return ECDSA.sign(hash, this.priv);
    };

    ECKey.prototype.verify = function (hash, sig) {
        return ECDSA.verify(hash, sig, this.getPub());
    };

    /**
    * Parse a wallet import format private key contained in a string.
    */
    ECKey.decodeWalletImportFormat = function (privStr) {
        var bytes = Bitcoin.Base58.decode(privStr);
        var hash = bytes.slice(0, 33);
        var checksum = Crypto.SHA256(Crypto.SHA256(hash, { asBytes: true }), { asBytes: true });
        if (checksum[0]  != bytes[33] ||
                    checksum[1] != bytes[34] ||
                    checksum[2] != bytes[35] ||
                    checksum[3] != bytes[36]) {
            return null;
        }
        return hash;
    };

    /**
    * Parse a compressed wallet import format private key contained in a string.
    */
    ECKey.decodeCompressedWalletImportFormat = function (privStr) {
        var bytes = Bitcoin.Base58.decode(privStr);
        var hash = bytes.slice(0, 34);
        var checksum = Crypto.SHA256(Crypto.SHA256(hash, { asBytes: true }), { asBytes: true });
        if (checksum[0] != bytes[34] ||
                    checksum[1] != bytes[35] ||
                    checksum[2] != bytes[36] ||
                    checksum[3] != bytes[37]) {
            return null;
        }
        hash.pop();
        return hash;
    };

    // 64 characters [0-9A-F]
    ECKey.isHexFormat = function (key) {
        key = key.toString();
        return /^[A-Fa-f0-9]{64}$/.test(key);
    };

    // 51 characters base58, bitcoin always starts with a 5, litecoin and dogecoin with a '6', testnet with a '9'
    ECKey.isWalletImportFormat = function (key) {
        //key = key.toString();
        var matcher = new RegExp("^[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{51}$", "g");
        return (ECKey.privateKeyPrefix == window.privateKeyPrefix) ? (matcher.test(key)) : false;
    };

    // 52 characters base58, bitcoin always starts with L or K, litecoin with a T, dogecoin with a 'Q', testnet with a 'c'
    ECKey.isCompressedWalletImportFormat = function (key) {
        //key = key.toString();
        var matcher = new RegExp("^[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{52}$", "g");
        return (ECKey.privateKeyPrefix == window.privateKeyPrefix) ? (matcher.test(key)) : false;
    };

    // 44 characters
    ECKey.isBase64Format = function (key) {
        key = key.toString();
        return (/^[ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789=+\/]{44}$/.test(key));
    };

    // 99 characters, 1=1, if using dice convert 6 to 0
    ECKey.isBase6Format = function (key) {
        key = key.toString();
        return (/^[012345]{99}$/.test(key));
    };

    // 22, 26 or 30 characters, always starts with an 'S'
    ECKey.isMiniFormat = function (key) {
        key = key.toString();
        var validChars22 = /^S[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{21}$/.test(key);
        var validChars26 = /^S[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{25}$/.test(key);
        var validChars30 = /^S[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{29}$/.test(key);
        var testBytes = Crypto.SHA256(key + "?", { asBytes: true });

        return ((testBytes[0] === 0x00 || testBytes[0] === 0x01) && (validChars22 || validChars26 || validChars30));
    };

    return ECKey;
})();
</script>
<script type="text/javascript">
//https://raw.github.com/bitcoinjs/bitcoinjs-lib/09e8c6e184d6501a0c2c59d73ca64db5c0d3eb95/src/util.js
// Bitcoin utility functions
Bitcoin.Util = {
    /**
    * Cross-browser compatibility version of Array.isArray.
    */
    isArray: Array.isArray || function (o) {
        return Object.prototype.toString.call(o) === '[object Array]';
    },
    /**
    * Create an array of a certain length filled with a specific value.
    */
    makeFilledArray: function (len, val) {
        var array = [];
        var i = 0;
        while (i < len) {
            array[i++] = val;
        }
        return array;
    },
    /**
    * Turn an integer into a "var_int".
    *
    * "var_int" is a variable length integer used by Bitcoin's binary format.
    *
    * Returns a byte array.
    */
    numToVarInt: function (i) {
        if (i < 0xfd) {
            // unsigned char
            return [i];
        } else if (i <= 1 << 16) {
            // unsigned short (LE)
            return [0xfd, i >>> 8, i & 255];
        } else if (i <= 1 << 32) {
            // unsigned int (LE)
            return [0xfe].concat(Crypto.util.wordsToBytes([i]));
        } else {
            // unsigned long long (LE)
            return [0xff].concat(Crypto.util.wordsToBytes([i >>> 32, i]));
        }
    },
    /**
    * Parse a Bitcoin value byte array, returning a BigInteger.
    */
    valueToBigInt: function (valueBuffer) {
        if (valueBuffer instanceof BigInteger) return valueBuffer;

        // Prepend zero byte to prevent interpretation as negative integer
        return BigInteger.fromByteArrayUnsigned(valueBuffer);
    },
    /**
    * Format a Bitcoin value as a string.
    *
    * Takes a BigInteger or byte-array and returns that amount of Bitcoins in a
    * nice standard formatting.
    *
    * Examples:
    * 12.3555
    * 0.1234
    * 900.99998888
    * 34.00
    */
    formatValue: function (valueBuffer) {
        var value = this.valueToBigInt(valueBuffer).toString();
        var integerPart = value.length > 8 ? value.substr(0, value.length - 8) : '0';
        var decimalPart = value.length > 8 ? value.substr(value.length - 8) : value;
        while (decimalPart.length < 8) decimalPart = "0" + decimalPart;
        decimalPart = decimalPart.replace(/0*$/, '');
        while (decimalPart.length < 2) decimalPart += "0";
        return integerPart + "." + decimalPart;
    },
    /**
    * Parse a floating point string as a Bitcoin value.
    *
    * Keep in mind that parsing user input is messy. You should always display
    * the parsed value back to the user to make sure we understood his input
    * correctly.
    */
    parseValue: function (valueString) {
        // TODO: Detect other number formats (e.g. comma as decimal separator)
        var valueComp = valueString.split('.');
        var integralPart = valueComp[0];
        var fractionalPart = valueComp[1] || "0";
        while (fractionalPart.length < 8) fractionalPart += "0";
        fractionalPart = fractionalPart.replace(/^0+/g, '');
        var value = BigInteger.valueOf(parseInt(integralPart));
        value = value.multiply(BigInteger.valueOf(100000000));
        value = value.add(BigInteger.valueOf(parseInt(fractionalPart)));
        return value;
    },
    /**
    * Calculate RIPEMD160(SHA256(data)).
    *
    * Takes an arbitrary byte array as inputs and returns the hash as a byte
    * array.
    */
    sha256ripe160: function (data) {
        return Crypto.RIPEMD160(Crypto.SHA256(data, { asBytes: true }), { asBytes: true });
    },
    // double sha256
    dsha256: function (data) {
        return Crypto.SHA256(Crypto.SHA256(data, { asBytes: true }), { asBytes: true });
    }
};
</script>
<script>
/**
 * @license
 * https://github.com/bitcoincashjs/bchaddr
 * Copyright (c) 2018-2019 Emilio Almansi
 * Distributed under the MIT software license, see the accompanying
 * file LICENSE or http://www.opensource.org/licenses/mit-license.php.
 */
!function(f){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=f();else if("function"==typeof define&&define.amd)define([],f);else{("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this).bchaddr=f()}}(function(){return function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a="function"==typeof require&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n||e)},l,l.exports,e,t,n,r)}return n[o].exports}for(var i="function"==typeof require&&require,o=0;o<r.length;o++)s(r[o]);return s}({1:[function(require,module,exports){var Buffer=require("safe-buffer").Buffer;module.exports=function(ALPHABET){for(var ALPHABET_MAP={},BASE=ALPHABET.length,LEADER=ALPHABET.charAt(0),z=0;z<ALPHABET.length;z++){var x=ALPHABET.charAt(z);if(void 0!==ALPHABET_MAP[x])throw new TypeError(x+" is ambiguous");ALPHABET_MAP[x]=z}function decodeUnsafe(string){if("string"!=typeof string)throw new TypeError("Expected String");if(0===string.length)return Buffer.allocUnsafe(0);for(var bytes=[0],i=0;i<string.length;i++){var value=ALPHABET_MAP[string[i]];if(void 0===value)return;for(var j=0,carry=value;j<bytes.length;++j)carry+=bytes[j]*BASE,bytes[j]=255&carry,carry>>=8;for(;0<carry;)bytes.push(255&carry),carry>>=8}for(var k=0;string[k]===LEADER&&k<string.length-1;++k)bytes.push(0);return Buffer.from(bytes.reverse())}return{encode:function(source){if(0===source.length)return"";for(var digits=[0],i=0;i<source.length;++i){for(var j=0,carry=source[i];j<digits.length;++j)carry+=digits[j]<<8,digits[j]=carry%BASE,carry=carry/BASE|0;for(;0<carry;)digits.push(carry%BASE),carry=carry/BASE|0}for(var string="",k=0;0===source[k]&&k<source.length-1;++k)string+=LEADER;for(var q=digits.length-1;0<=q;--q)string+=ALPHABET[digits[q]];return string},decodeUnsafe:decodeUnsafe,decode:function(string){var buffer=decodeUnsafe(string);if(buffer)return buffer;throw new Error("Non-base"+BASE+" character")}}}},{"safe-buffer":41}],2:[function(require,module,exports){"use strict";exports.byteLength=function(b64){return 3*b64.length/4-placeHoldersCount(b64)},exports.toByteArray=function(b64){var i,l,tmp,placeHolders,arr,len=b64.length;placeHolders=placeHoldersCount(b64),arr=new Arr(3*len/4-placeHolders),l=0<placeHolders?len-4:len;var L=0;for(i=0;i<l;i+=4)tmp=revLookup[b64.charCodeAt(i)]<<18|revLookup[b64.charCodeAt(i+1)]<<12|revLookup[b64.charCodeAt(i+2)]<<6|revLookup[b64.charCodeAt(i+3)],arr[L++]=tmp>>16&255,arr[L++]=tmp>>8&255,arr[L++]=255&tmp;2===placeHolders?(tmp=revLookup[b64.charCodeAt(i)]<<2|revLookup[b64.charCodeAt(i+1)]>>4,arr[L++]=255&tmp):1===placeHolders&&(tmp=revLookup[b64.charCodeAt(i)]<<10|revLookup[b64.charCodeAt(i+1)]<<4|revLookup[b64.charCodeAt(i+2)]>>2,arr[L++]=tmp>>8&255,arr[L++]=255&tmp);return arr},exports.fromByteArray=function(uint8){for(var tmp,len=uint8.length,extraBytes=len%3,output="",parts=[],i=0,len2=len-extraBytes;i<len2;i+=16383)parts.push(encodeChunk(uint8,i,len2<i+16383?len2:i+16383));1===extraBytes?(tmp=uint8[len-1],output+=lookup[tmp>>2],output+=lookup[tmp<<4&63],output+="=="):2===extraBytes&&(tmp=(uint8[len-2]<<8)+uint8[len-1],output+=lookup[tmp>>10],output+=lookup[tmp>>4&63],output+=lookup[tmp<<2&63],output+="=");return parts.push(output),parts.join("")};for(var lookup=[],revLookup=[],Arr="undefined"!=typeof Uint8Array?Uint8Array:Array,code="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",i=0,len=code.length;i<len;++i)lookup[i]=code[i],revLookup[code.charCodeAt(i)]=i;function placeHoldersCount(b64){var len=b64.length;if(0<len%4)throw new Error("Invalid string. Length must be a multiple of 4");return"="===b64[len-2]?2:"="===b64[len-1]?1:0}function encodeChunk(uint8,start,end){for(var tmp,num,output=[],i=start;i<end;i+=3)tmp=(uint8[i]<<16)+(uint8[i+1]<<8)+uint8[i+2],output.push(lookup[(num=tmp)>>18&63]+lookup[num>>12&63]+lookup[num>>6&63]+lookup[63&num]);return output.join("")}revLookup["-".charCodeAt(0)]=62,revLookup["_".charCodeAt(0)]=63},{}],3:[function(require,module,exports){var bigInt=function(undefined){"use strict";var BASE=1e7,LOG_BASE=7,MAX_INT=9007199254740992,MAX_INT_ARR=smallToArray(MAX_INT),LOG_MAX_INT=Math.log(MAX_INT);function Integer(v,radix){return void 0===v?Integer[0]:void 0!==radix?10==+radix?parseValue(v):parseBase(v,radix):parseValue(v)}function BigInteger(value,sign){this.value=value,this.sign=sign,this.isSmall=!1}function SmallInteger(value){this.value=value,this.sign=value<0,this.isSmall=!0}function isPrecise(n){return-MAX_INT<n&&n<MAX_INT}function smallToArray(n){return n<1e7?[n]:n<1e14?[n%1e7,Math.floor(n/1e7)]:[n%1e7,Math.floor(n/1e7)%1e7,Math.floor(n/1e14)]}function arrayToSmall(arr){trim(arr);var length=arr.length;if(length<4&&compareAbs(arr,MAX_INT_ARR)<0)switch(length){case 0:return 0;case 1:return arr[0];case 2:return arr[0]+arr[1]*BASE;default:return arr[0]+(arr[1]+arr[2]*BASE)*BASE}return arr}function trim(v){for(var i=v.length;0===v[--i];);v.length=i+1}function createArray(length){for(var x=new Array(length),i=-1;++i<length;)x[i]=0;return x}function truncate(n){return 0<n?Math.floor(n):Math.ceil(n)}function add(a,b){var sum,i,l_a=a.length,l_b=b.length,r=new Array(l_a),carry=0,base=BASE;for(i=0;i<l_b;i++)carry=base<=(sum=a[i]+b[i]+carry)?1:0,r[i]=sum-carry*base;for(;i<l_a;)carry=(sum=a[i]+carry)===base?1:0,r[i++]=sum-carry*base;return 0<carry&&r.push(carry),r}function addAny(a,b){return a.length>=b.length?add(a,b):add(b,a)}function addSmall(a,carry){var sum,i,l=a.length,r=new Array(l),base=BASE;for(i=0;i<l;i++)sum=a[i]-base+carry,carry=Math.floor(sum/base),r[i]=sum-carry*base,carry+=1;for(;0<carry;)r[i++]=carry%base,carry=Math.floor(carry/base);return r}function subtract(a,b){var i,difference,a_l=a.length,b_l=b.length,r=new Array(a_l),borrow=0,base=BASE;for(i=0;i<b_l;i++)(difference=a[i]-borrow-b[i])<0?(difference+=base,borrow=1):borrow=0,r[i]=difference;for(i=b_l;i<a_l;i++){if(!((difference=a[i]-borrow)<0)){r[i++]=difference;break}difference+=base,r[i]=difference}for(;i<a_l;i++)r[i]=a[i];return trim(r),r}function subtractSmall(a,b,sign){var i,difference,l=a.length,r=new Array(l),carry=-b,base=BASE;for(i=0;i<l;i++)difference=a[i]+carry,carry=Math.floor(difference/base),difference%=base,r[i]=difference<0?difference+base:difference;return"number"==typeof(r=arrayToSmall(r))?(sign&&(r=-r),new SmallInteger(r)):new BigInteger(r,sign)}function multiplyLong(a,b){var product,carry,i,a_i,a_l=a.length,b_l=b.length,r=createArray(a_l+b_l),base=BASE;for(i=0;i<a_l;++i){a_i=a[i];for(var j=0;j<b_l;++j)product=a_i*b[j]+r[i+j],carry=Math.floor(product/base),r[i+j]=product-carry*base,r[i+j+1]+=carry}return trim(r),r}function multiplySmall(a,b){var product,i,l=a.length,r=new Array(l),base=BASE,carry=0;for(i=0;i<l;i++)product=a[i]*b+carry,carry=Math.floor(product/base),r[i]=product-carry*base;for(;0<carry;)r[i++]=carry%base,carry=Math.floor(carry/base);return r}function shiftLeft(x,n){for(var r=[];0<n--;)r.push(0);return r.concat(x)}function multiplySmallAndArray(a,b,sign){return new BigInteger(a<BASE?multiplySmall(b,a):multiplyLong(b,smallToArray(a)),sign)}function square(a){var product,carry,i,a_i,l=a.length,r=createArray(l+l),base=BASE;for(i=0;i<l;i++){carry=0-(a_i=a[i])*a_i;for(var j=i;j<l;j++)product=a_i*a[j]*2+r[i+j]+carry,carry=Math.floor(product/base),r[i+j]=product-carry*base;r[i+l]=carry}return trim(r),r}function divModSmall(value,lambda){var i,q,remainder,divisor,length=value.length,quotient=createArray(length),base=BASE;for(remainder=0,i=length-1;0<=i;--i)remainder=(divisor=remainder*base+value[i])-(q=truncate(divisor/lambda))*lambda,quotient[i]=0|q;return[quotient,0|remainder]}function divModAny(self,v){var value,quotient,n=parseValue(v),a=self.value,b=n.value;if(0===b)throw new Error("Cannot divide by zero");if(self.isSmall)return n.isSmall?[new SmallInteger(truncate(a/b)),new SmallInteger(a%b)]:[Integer[0],self];if(n.isSmall){if(1===b)return[self,Integer[0]];if(-1==b)return[self.negate(),Integer[0]];var abs=Math.abs(b);if(abs<BASE){quotient=arrayToSmall((value=divModSmall(a,abs))[0]);var remainder=value[1];return self.sign&&(remainder=-remainder),"number"==typeof quotient?(self.sign!==n.sign&&(quotient=-quotient),[new SmallInteger(quotient),new SmallInteger(remainder)]):[new BigInteger(quotient,self.sign!==n.sign),new SmallInteger(remainder)]}b=smallToArray(abs)}var comparison=compareAbs(a,b);if(-1===comparison)return[Integer[0],self];if(0===comparison)return[Integer[self.sign===n.sign?1:-1],Integer[0]];quotient=(value=a.length+b.length<=200?function(a,b){var quotientDigit,shift,carry,borrow,i,l,q,a_l=a.length,b_l=b.length,base=BASE,result=createArray(b.length),divisorMostSignificantDigit=b[b_l-1],lambda=Math.ceil(base/(2*divisorMostSignificantDigit)),remainder=multiplySmall(a,lambda),divisor=multiplySmall(b,lambda);for(remainder.length<=a_l&&remainder.push(0),divisor.push(0),divisorMostSignificantDigit=divisor[b_l-1],shift=a_l-b_l;0<=shift;shift--){for(quotientDigit=base-1,remainder[shift+b_l]!==divisorMostSignificantDigit&&(quotientDigit=Math.floor((remainder[shift+b_l]*base+remainder[shift+b_l-1])/divisorMostSignificantDigit)),borrow=carry=0,l=divisor.length,i=0;i<l;i++)carry+=quotientDigit*divisor[i],q=Math.floor(carry/base),borrow+=remainder[shift+i]-(carry-q*base),carry=q,borrow<0?(remainder[shift+i]=borrow+base,borrow=-1):(remainder[shift+i]=borrow,borrow=0);for(;0!==borrow;){for(quotientDigit-=1,i=carry=0;i<l;i++)(carry+=remainder[shift+i]-base+divisor[i])<0?(remainder[shift+i]=carry+base,carry=0):(remainder[shift+i]=carry,carry=1);borrow+=carry}result[shift]=quotientDigit}return remainder=divModSmall(remainder,lambda)[0],[arrayToSmall(result),arrayToSmall(remainder)]}(a,b):function(a,b){for(var guess,xlen,highx,highy,check,a_l=a.length,b_l=b.length,result=[],part=[],base=BASE;a_l;)if(part.unshift(a[--a_l]),trim(part),compareAbs(part,b)<0)result.push(0);else{highx=part[(xlen=part.length)-1]*base+part[xlen-2],highy=b[b_l-1]*base+b[b_l-2],b_l<xlen&&(highx=(highx+1)*base),guess=Math.ceil(highx/highy);do{if(compareAbs(check=multiplySmall(b,guess),part)<=0)break;guess--}while(guess);result.push(guess),part=subtract(part,check)}return result.reverse(),[arrayToSmall(result),arrayToSmall(part)]}(a,b))[0];var qSign=self.sign!==n.sign,mod=value[1],mSign=self.sign;return"number"==typeof quotient?(qSign&&(quotient=-quotient),quotient=new SmallInteger(quotient)):quotient=new BigInteger(quotient,qSign),"number"==typeof mod?(mSign&&(mod=-mod),mod=new SmallInteger(mod)):mod=new BigInteger(mod,mSign),[quotient,mod]}function compareAbs(a,b){if(a.length!==b.length)return a.length>b.length?1:-1;for(var i=a.length-1;0<=i;i--)if(a[i]!==b[i])return a[i]>b[i]?1:-1;return 0}function isBasicPrime(v){var n=v.abs();return!n.isUnit()&&(!!(n.equals(2)||n.equals(3)||n.equals(5))||!(n.isEven()||n.isDivisibleBy(3)||n.isDivisibleBy(5))&&(!!n.lesser(49)||void 0))}function millerRabinTest(n,a){for(var d,i,x,nPrev=n.prev(),b=nPrev,r=0;b.isEven();)b=b.divide(2),r++;next:for(i=0;i<a.length;i++)if(!n.lesser(a[i])&&!(x=bigInt(a[i]).modPow(b,n)).equals(Integer[1])&&!x.equals(nPrev)){for(d=r-1;0!=d;d--){if((x=x.square().mod(n)).isUnit())return!1;if(x.equals(nPrev))continue next}return!1}return!0}BigInteger.prototype=Object.create(Integer.prototype),SmallInteger.prototype=Object.create(Integer.prototype),BigInteger.prototype.plus=BigInteger.prototype.add=function(v){var n=parseValue(v);if(this.sign!==n.sign)return this.subtract(n.negate());var a=this.value,b=n.value;return n.isSmall?new BigInteger(addSmall(a,Math.abs(b)),this.sign):new BigInteger(addAny(a,b),this.sign)},SmallInteger.prototype.plus=SmallInteger.prototype.add=function(v){var n=parseValue(v),a=this.value;if(a<0!==n.sign)return this.subtract(n.negate());var b=n.value;if(n.isSmall){if(isPrecise(a+b))return new SmallInteger(a+b);b=smallToArray(Math.abs(b))}return new BigInteger(addSmall(b,Math.abs(a)),a<0)},BigInteger.prototype.minus=BigInteger.prototype.subtract=function(v){var n=parseValue(v);if(this.sign!==n.sign)return this.add(n.negate());var a=this.value,b=n.value;return n.isSmall?subtractSmall(a,Math.abs(b),this.sign):function(a,b,sign){var value;return 0<=compareAbs(a,b)?value=subtract(a,b):(value=subtract(b,a),sign=!sign),"number"==typeof(value=arrayToSmall(value))?(sign&&(value=-value),new SmallInteger(value)):new BigInteger(value,sign)}(a,b,this.sign)},SmallInteger.prototype.minus=SmallInteger.prototype.subtract=function(v){var n=parseValue(v),a=this.value;if(a<0!==n.sign)return this.add(n.negate());var b=n.value;return n.isSmall?new SmallInteger(a-b):subtractSmall(b,Math.abs(a),0<=a)},BigInteger.prototype.negate=function(){return new BigInteger(this.value,!this.sign)},SmallInteger.prototype.negate=function(){var sign=this.sign,small=new SmallInteger(-this.value);return small.sign=!sign,small},BigInteger.prototype.abs=function(){return new BigInteger(this.value,!1)},SmallInteger.prototype.abs=function(){return new SmallInteger(Math.abs(this.value))},BigInteger.prototype.times=BigInteger.prototype.multiply=function(v){var abs,l1,l2,n=parseValue(v),a=this.value,b=n.value,sign=this.sign!==n.sign;if(n.isSmall){if(0===b)return Integer[0];if(1===b)return this;if(-1===b)return this.negate();if((abs=Math.abs(b))<BASE)return new BigInteger(multiplySmall(a,abs),sign);b=smallToArray(abs)}return l1=a.length,l2=b.length,new BigInteger(0<-.012*l1-.012*l2+15e-6*l1*l2?function multiplyKaratsuba(x,y){var n=Math.max(x.length,y.length);if(n<=30)return multiplyLong(x,y);n=Math.ceil(n/2);var b=x.slice(n),a=x.slice(0,n),d=y.slice(n),c=y.slice(0,n),ac=multiplyKaratsuba(a,c),bd=multiplyKaratsuba(b,d),product=addAny(addAny(ac,shiftLeft(subtract(subtract(multiplyKaratsuba(addAny(a,b),addAny(c,d)),ac),bd),n)),shiftLeft(bd,2*n));return trim(product),product}(a,b):multiplyLong(a,b),sign)},SmallInteger.prototype._multiplyBySmall=function(a){return isPrecise(a.value*this.value)?new SmallInteger(a.value*this.value):multiplySmallAndArray(Math.abs(a.value),smallToArray(Math.abs(this.value)),this.sign!==a.sign)},BigInteger.prototype._multiplyBySmall=function(a){return 0===a.value?Integer[0]:1===a.value?this:-1===a.value?this.negate():multiplySmallAndArray(Math.abs(a.value),this.value,this.sign!==a.sign)},SmallInteger.prototype.times=SmallInteger.prototype.multiply=function(v){return parseValue(v)._multiplyBySmall(this)},BigInteger.prototype.square=function(){return new BigInteger(square(this.value),!1)},SmallInteger.prototype.square=function(){var value=this.value*this.value;return isPrecise(value)?new SmallInteger(value):new BigInteger(square(smallToArray(Math.abs(this.value))),!1)},SmallInteger.prototype.divmod=BigInteger.prototype.divmod=function(v){var result=divModAny(this,v);return{quotient:result[0],remainder:result[1]}},SmallInteger.prototype.over=SmallInteger.prototype.divide=BigInteger.prototype.over=BigInteger.prototype.divide=function(v){return divModAny(this,v)[0]},SmallInteger.prototype.remainder=SmallInteger.prototype.mod=BigInteger.prototype.remainder=BigInteger.prototype.mod=function(v){return divModAny(this,v)[1]},BigInteger.prototype.pow=function(v){var value,x,y,n=parseValue(v),a=this.value,b=n.value;if(0===b)return Integer[1];if(0===a)return Integer[0];if(1===a)return Integer[1];if(-1===a)return n.isEven()?Integer[1]:Integer[-1];if(n.sign)return Integer[0];if(!n.isSmall)throw new Error("The exponent "+n.toString()+" is too large.");if(this.isSmall&&isPrecise(value=Math.pow(a,b)))return new SmallInteger(truncate(value));for(x=this,y=Integer[1];!0&b&&(y=y.times(x),--b),0!==b;)b/=2,x=x.square();return y},SmallInteger.prototype.pow=BigInteger.prototype.pow,SmallInteger.prototype.modPow=BigInteger.prototype.modPow=function(exp,mod){if(exp=parseValue(exp),(mod=parseValue(mod)).isZero())throw new Error("Cannot take modPow with modulus 0");for(var r=Integer[1],base=this.mod(mod);exp.isPositive();){if(base.isZero())return Integer[0];exp.isOdd()&&(r=r.multiply(base).mod(mod)),exp=exp.divide(2),base=base.square().mod(mod)}return r},BigInteger.prototype.compareAbs=function(v){var n=parseValue(v),a=this.value,b=n.value;return n.isSmall?1:compareAbs(a,b)},SmallInteger.prototype.compareAbs=function(v){var n=parseValue(v),a=Math.abs(this.value),b=n.value;return n.isSmall?a===(b=Math.abs(b))?0:b<a?1:-1:-1},BigInteger.prototype.compareTo=BigInteger.prototype.compare=function(v){if(v===1/0)return-1;if(v===-1/0)return 1;var n=parseValue(v),a=this.value,b=n.value;return this.sign!==n.sign?n.sign?1:-1:n.isSmall?this.sign?-1:1:compareAbs(a,b)*(this.sign?-1:1)},SmallInteger.prototype.compareTo=SmallInteger.prototype.compare=function(v){if(v===1/0)return-1;if(v===-1/0)return 1;var n=parseValue(v),a=this.value,b=n.value;return n.isSmall?a==b?0:b<a?1:-1:a<0!==n.sign?a<0?-1:1:a<0?1:-1},SmallInteger.prototype.eq=SmallInteger.prototype.equals=BigInteger.prototype.eq=BigInteger.prototype.equals=function(v){return 0===this.compare(v)},SmallInteger.prototype.neq=SmallInteger.prototype.notEquals=BigInteger.prototype.neq=BigInteger.prototype.notEquals=function(v){return 0!==this.compare(v)},SmallInteger.prototype.gt=SmallInteger.prototype.greater=BigInteger.prototype.gt=BigInteger.prototype.greater=function(v){return 0<this.compare(v)},SmallInteger.prototype.lt=SmallInteger.prototype.lesser=BigInteger.prototype.lt=BigInteger.prototype.lesser=function(v){return this.compare(v)<0},SmallInteger.prototype.geq=SmallInteger.prototype.greaterOrEquals=BigInteger.prototype.geq=BigInteger.prototype.greaterOrEquals=function(v){return 0<=this.compare(v)},SmallInteger.prototype.leq=SmallInteger.prototype.lesserOrEquals=BigInteger.prototype.leq=BigInteger.prototype.lesserOrEquals=function(v){return this.compare(v)<=0},BigInteger.prototype.isEven=function(){return 0==(1&this.value[0])},SmallInteger.prototype.isEven=function(){return 0==(1&this.value)},BigInteger.prototype.isOdd=function(){return 1==(1&this.value[0])},SmallInteger.prototype.isOdd=function(){return 1==(1&this.value)},BigInteger.prototype.isPositive=function(){return!this.sign},SmallInteger.prototype.isPositive=function(){return 0<this.value},BigInteger.prototype.isNegative=function(){return this.sign},SmallInteger.prototype.isNegative=function(){return this.value<0},BigInteger.prototype.isUnit=function(){return!1},SmallInteger.prototype.isUnit=function(){return 1===Math.abs(this.value)},BigInteger.prototype.isZero=function(){return!1},SmallInteger.prototype.isZero=function(){return 0===this.value},SmallInteger.prototype.isDivisibleBy=BigInteger.prototype.isDivisibleBy=function(v){var n=parseValue(v),value=n.value;return 0!==value&&(1===value||(2===value?this.isEven():this.mod(n).equals(Integer[0])))},SmallInteger.prototype.isPrime=BigInteger.prototype.isPrime=function(strict){var isPrime=isBasicPrime(this);if(void 0!==isPrime)return isPrime;var n=this.abs(),bits=n.bitLength();if(bits<=64)return millerRabinTest(n,[2,325,9375,28178,450775,9780504,1795265022]);for(var logN=Math.log(2)*bits,t=Math.ceil(!0===strict?2*Math.pow(logN,2):logN),a=[],i=0;i<t;i++)a.push(bigInt(i+2));return millerRabinTest(n,a)},SmallInteger.prototype.isProbablePrime=BigInteger.prototype.isProbablePrime=function(iterations){var isPrime=isBasicPrime(this);if(void 0!==isPrime)return isPrime;for(var n=this.abs(),t=void 0===iterations?5:iterations,a=[],i=0;i<t;i++)a.push(bigInt.randBetween(2,n.minus(2)));return millerRabinTest(n,a)},SmallInteger.prototype.modInv=BigInteger.prototype.modInv=function(n){for(var q,lastT,lastR,t=bigInt.zero,newT=bigInt.one,r=parseValue(n),newR=this.abs();!newR.equals(bigInt.zero);)q=r.divide(newR),lastT=t,lastR=r,t=newT,r=newR,newT=lastT.subtract(q.multiply(newT)),newR=lastR.subtract(q.multiply(newR));if(!r.equals(1))throw new Error(this.toString()+" and "+n.toString()+" are not co-prime");return-1===t.compare(0)&&(t=t.add(n)),this.isNegative()?t.negate():t},BigInteger.prototype.next=function(){var value=this.value;return this.sign?subtractSmall(value,1,this.sign):new BigInteger(addSmall(value,1),this.sign)},SmallInteger.prototype.next=function(){var value=this.value;return value+1<MAX_INT?new SmallInteger(value+1):new BigInteger(MAX_INT_ARR,!1)},BigInteger.prototype.prev=function(){var value=this.value;return this.sign?new BigInteger(addSmall(value,1),!0):subtractSmall(value,1,this.sign)},SmallInteger.prototype.prev=function(){var value=this.value;return-MAX_INT<value-1?new SmallInteger(value-1):new BigInteger(MAX_INT_ARR,!0)};for(var powersOfTwo=[1];2*powersOfTwo[powersOfTwo.length-1]<=BASE;)powersOfTwo.push(2*powersOfTwo[powersOfTwo.length-1]);var powers2Length=powersOfTwo.length,highestPower2=powersOfTwo[powers2Length-1];function shift_isSmall(n){return("number"==typeof n||"string"==typeof n)&&+Math.abs(n)<=BASE||n instanceof BigInteger&&n.value.length<=1}function bitwise(x,y,fn){y=parseValue(y);for(var xSign=x.isNegative(),ySign=y.isNegative(),xRem=xSign?x.not():x,yRem=ySign?y.not():y,xDigit=0,yDigit=0,xDivMod=null,yDivMod=null,result=[];!xRem.isZero()||!yRem.isZero();)xDigit=(xDivMod=divModAny(xRem,highestPower2))[1].toJSNumber(),xSign&&(xDigit=highestPower2-1-xDigit),yDigit=(yDivMod=divModAny(yRem,highestPower2))[1].toJSNumber(),ySign&&(yDigit=highestPower2-1-yDigit),xRem=xDivMod[0],yRem=yDivMod[0],result.push(fn(xDigit,yDigit));for(var sum=0!==fn(xSign?1:0,ySign?1:0)?bigInt(-1):bigInt(0),i=result.length-1;0<=i;i-=1)sum=sum.multiply(highestPower2).add(bigInt(result[i]));return sum}SmallInteger.prototype.shiftLeft=BigInteger.prototype.shiftLeft=function(n){if(!shift_isSmall(n))throw new Error(String(n)+" is too large for shifting.");if((n=+n)<0)return this.shiftRight(-n);var result=this;if(result.isZero())return result;for(;powers2Length<=n;)result=result.multiply(highestPower2),n-=powers2Length-1;return result.multiply(powersOfTwo[n])},SmallInteger.prototype.shiftRight=BigInteger.prototype.shiftRight=function(n){var remQuo;if(!shift_isSmall(n))throw new Error(String(n)+" is too large for shifting.");if((n=+n)<0)return this.shiftLeft(-n);for(var result=this;powers2Length<=n;){if(result.isZero()||result.isNegative()&&result.isUnit())return result;result=(remQuo=divModAny(result,highestPower2))[1].isNegative()?remQuo[0].prev():remQuo[0],n-=powers2Length-1}return(remQuo=divModAny(result,powersOfTwo[n]))[1].isNegative()?remQuo[0].prev():remQuo[0]},SmallInteger.prototype.not=BigInteger.prototype.not=function(){return this.negate().prev()},SmallInteger.prototype.and=BigInteger.prototype.and=function(n){return bitwise(this,n,function(a,b){return a&b})},SmallInteger.prototype.or=BigInteger.prototype.or=function(n){return bitwise(this,n,function(a,b){return a|b})},SmallInteger.prototype.xor=BigInteger.prototype.xor=function(n){return bitwise(this,n,function(a,b){return a^b})};var LOBMASK_I=1<<30,LOBMASK_BI=(BASE&-BASE)*(BASE&-BASE)|LOBMASK_I;function roughLOB(n){var v=n.value,x="number"==typeof v?v|LOBMASK_I:v[0]+v[1]*BASE|LOBMASK_BI;return x&-x}function max(a,b){return a=parseValue(a),b=parseValue(b),a.greater(b)?a:b}function min(a,b){return a=parseValue(a),b=parseValue(b),a.lesser(b)?a:b}function gcd(a,b){if(a=parseValue(a).abs(),b=parseValue(b).abs(),a.equals(b))return a;if(a.isZero())return b;if(b.isZero())return a;for(var d,t,c=Integer[1];a.isEven()&&b.isEven();)d=Math.min(roughLOB(a),roughLOB(b)),a=a.divide(d),b=b.divide(d),c=c.multiply(d);for(;a.isEven();)a=a.divide(roughLOB(a));do{for(;b.isEven();)b=b.divide(roughLOB(b));a.greater(b)&&(t=b,b=a,a=t),b=b.subtract(a)}while(!b.isZero());return c.isUnit()?a:a.multiply(c)}SmallInteger.prototype.bitLength=BigInteger.prototype.bitLength=function(){var n=this;return n.compareTo(bigInt(0))<0&&(n=n.negate().subtract(bigInt(1))),0===n.compareTo(bigInt(0))?bigInt(0):bigInt(function integerLogarithm(value,base){if(base.compareTo(value)<=0){var tmp=integerLogarithm(value,base.square(base)),p=tmp.p,e=tmp.e,t=p.multiply(base);return t.compareTo(value)<=0?{p:t,e:2*e+1}:{p:p,e:2*e}}return{p:bigInt(1),e:0}}(n,bigInt(2)).e).add(bigInt(1))};var parseBase=function(text,base){for(var length=text.length,absBase=Math.abs(base),i=0;i<length;i++){if("-"!==(c=text[i].toLowerCase())&&/[a-z0-9]/.test(c)){if(/[0-9]/.test(c)&&absBase<=+c){if("1"===c&&1===absBase)continue;throw new Error(c+" is not a valid digit in base "+base+".")}if(c.charCodeAt(0)-87>=absBase)throw new Error(c+" is not a valid digit in base "+base+".")}}if(2<=base&&base<=36&&length<=LOG_MAX_INT/Math.log(base)){var result=parseInt(text,base);if(isNaN(result))throw new Error(c+" is not a valid digit in base "+base+".");return new SmallInteger(parseInt(text,base))}base=parseValue(base);var digits=[],isNegative="-"===text[0];for(i=isNegative?1:0;i<text.length;i++){var c,charCode=(c=text[i].toLowerCase()).charCodeAt(0);if(48<=charCode&&charCode<=57)digits.push(parseValue(c));else if(97<=charCode&&charCode<=122)digits.push(parseValue(c.charCodeAt(0)-87));else{if("<"!==c)throw new Error(c+" is not a valid character");for(var start=i;">"!==text[++i];);digits.push(parseValue(text.slice(start+1,i)))}}return parseBaseFromArray(digits,base,isNegative)};function parseBaseFromArray(digits,base,isNegative){var i,val=Integer[0],pow=Integer[1];for(i=digits.length-1;0<=i;i--)val=val.add(digits[i].times(pow)),pow=pow.times(base);return isNegative?val.negate():val}function stringify(digit){return digit<=35?"0123456789abcdefghijklmnopqrstuvwxyz".charAt(digit):"<"+digit+">"}function toBase(n,base){if((base=bigInt(base)).isZero()){if(n.isZero())return{value:[0],isNegative:!1};throw new Error("Cannot convert nonzero numbers to base 0.")}if(base.equals(-1)){if(n.isZero())return{value:[0],isNegative:!1};if(n.isNegative())return{value:[].concat.apply([],Array.apply(null,Array(-n)).map(Array.prototype.valueOf,[1,0])),isNegative:!1};var arr=Array.apply(null,Array(+n-1)).map(Array.prototype.valueOf,[0,1]);return arr.unshift([1]),{value:[].concat.apply([],arr),isNegative:!1}}var neg=!1;if(n.isNegative()&&base.isPositive()&&(neg=!0,n=n.abs()),base.equals(1))return n.isZero()?{value:[0],isNegative:!1}:{value:Array.apply(null,Array(+n)).map(Number.prototype.valueOf,1),isNegative:neg};for(var divmod,out=[],left=n;left.isNegative()||0<=left.compareAbs(base);){left=(divmod=left.divmod(base)).quotient;var digit=divmod.remainder;digit.isNegative()&&(digit=base.minus(digit).abs(),left=left.next()),out.push(digit.toJSNumber())}return out.push(left.toJSNumber()),{value:out.reverse(),isNegative:neg}}function toBaseString(n,base){var arr=toBase(n,base);return(arr.isNegative?"-":"")+arr.value.map(stringify).join("")}function parseStringValue(v){if(isPrecise(+v)){var x=+v;if(x===truncate(x))return new SmallInteger(x);throw new Error("Invalid integer: "+v)}var sign="-"===v[0];sign&&(v=v.slice(1));var split=v.split(/e/i);if(2<split.length)throw new Error("Invalid integer: "+split.join("e"));if(2===split.length){var exp=split[1];if("+"===exp[0]&&(exp=exp.slice(1)),(exp=+exp)!==truncate(exp)||!isPrecise(exp))throw new Error("Invalid integer: "+exp+" is not a valid exponent.");var text=split[0],decimalPlace=text.indexOf(".");if(0<=decimalPlace&&(exp-=text.length-decimalPlace-1,text=text.slice(0,decimalPlace)+text.slice(decimalPlace+1)),exp<0)throw new Error("Cannot include negative exponent part for integers");v=text+=new Array(exp+1).join("0")}if(!/^([0-9][0-9]*)$/.test(v))throw new Error("Invalid integer: "+v);for(var r=[],max=v.length,l=LOG_BASE,min=max-l;0<max;)r.push(+v.slice(min,max)),(min-=l)<0&&(min=0),max-=l;return trim(r),new BigInteger(r,sign)}function parseValue(v){return"number"==typeof v?function(v){if(isPrecise(v)){if(v!==truncate(v))throw new Error(v+" is not an integer.");return new SmallInteger(v)}return parseStringValue(v.toString())}(v):"string"==typeof v?parseStringValue(v):v}BigInteger.prototype.toArray=function(radix){return toBase(this,radix)},SmallInteger.prototype.toArray=function(radix){return toBase(this,radix)},BigInteger.prototype.toString=function(radix){if(void 0===radix&&(radix=10),10!==radix)return toBaseString(this,radix);for(var digit,v=this.value,l=v.length,str=String(v[--l]);0<=--l;)digit=String(v[l]),str+="0000000".slice(digit.length)+digit;return(this.sign?"-":"")+str},SmallInteger.prototype.toString=function(radix){return void 0===radix&&(radix=10),10!=radix?toBaseString(this,radix):String(this.value)},BigInteger.prototype.toJSON=SmallInteger.prototype.toJSON=function(){return this.toString()},BigInteger.prototype.toJSNumber=BigInteger.prototype.valueOf=function(){return parseInt(this.toString(),10)},SmallInteger.prototype.toJSNumber=SmallInteger.prototype.valueOf=function(){return this.value};for(var i=0;i<1e3;i++)Integer[i]=new SmallInteger(i),0<i&&(Integer[-i]=new SmallInteger(-i));return Integer.one=Integer[1],Integer.zero=Integer[0],Integer.minusOne=Integer[-1],Integer.max=max,Integer.min=min,Integer.gcd=gcd,Integer.lcm=function(a,b){return a=parseValue(a).abs(),b=parseValue(b).abs(),a.divide(gcd(a,b)).multiply(b)},Integer.isInstance=function(x){return x instanceof BigInteger||x instanceof SmallInteger},Integer.randBetween=function(a,b){var low=min(a=parseValue(a),b=parseValue(b)),range=max(a,b).subtract(low).add(1);if(range.isSmall)return low.add(Math.floor(Math.random()*range));for(var result=[],restricted=!0,i=range.value.length-1;0<=i;i--){var top=restricted?range.value[i]:BASE,digit=truncate(Math.random()*top);result.unshift(digit),digit<top&&(restricted=!1)}return result=arrayToSmall(result),low.add("number"==typeof result?new SmallInteger(result):new BigInteger(result,!1))},Integer.fromArray=function(digits,base,isNegative){return parseBaseFromArray(digits.map(parseValue),parseValue(base||10),isNegative)},Integer}();void 0!==module&&module.hasOwnProperty("exports")&&(module.exports=bigInt)},{}],4:[function(require,module,exports){},{}],5:[function(require,module,exports){var basex=require("base-x");module.exports=basex("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz")},{"base-x":1}],6:[function(require,module,exports){"use strict";var base58=require("bs58"),Buffer=require("safe-buffer").Buffer;module.exports=function(checksumFn){function decodeRaw(buffer){var payload=buffer.slice(0,-4),checksum=buffer.slice(-4),newChecksum=checksumFn(payload);if(!(checksum[0]^newChecksum[0]|checksum[1]^newChecksum[1]|checksum[2]^newChecksum[2]|checksum[3]^newChecksum[3]))return payload}return{encode:function(payload){var checksum=checksumFn(payload);return base58.encode(Buffer.concat([payload,checksum],payload.length+4))},decode:function(string){var payload=decodeRaw(base58.decode(string));if(!payload)throw new Error("Invalid checksum");return payload},decodeUnsafe:function(string){var buffer=base58.decodeUnsafe(string);if(buffer)return decodeRaw(buffer)}}}},{bs58:5,"safe-buffer":8}],7:[function(require,module,exports){"use strict";var createHash=require("create-hash"),bs58checkBase=require("./base");module.exports=bs58checkBase(function(buffer){var tmp=createHash("sha256").update(buffer).digest();return createHash("sha256").update(tmp).digest()})},{"./base":6,"create-hash":16}],8:[function(require,module,exports){var buffer=require("buffer"),Buffer=buffer.Buffer;function copyProps(src,dst){for(var key in src)dst[key]=src[key]}function SafeBuffer(arg,encodingOrOffset,length){return Buffer(arg,encodingOrOffset,length)}Buffer.from&&Buffer.alloc&&Buffer.allocUnsafe&&Buffer.allocUnsafeSlow?module.exports=buffer:(copyProps(buffer,exports),exports.Buffer=SafeBuffer),copyProps(Buffer,SafeBuffer),SafeBuffer.from=function(arg,encodingOrOffset,length){if("number"==typeof arg)throw new TypeError("Argument must not be a number");return Buffer(arg,encodingOrOffset,length)},SafeBuffer.alloc=function(size,fill,encoding){if("number"!=typeof size)throw new TypeError("Argument must be a number");var buf=Buffer(size);return void 0!==fill?"string"==typeof encoding?buf.fill(fill,encoding):buf.fill(fill):buf.fill(0),buf},SafeBuffer.allocUnsafe=function(size){if("number"!=typeof size)throw new TypeError("Argument must be a number");return Buffer(size)},SafeBuffer.allocUnsafeSlow=function(size){if("number"!=typeof size)throw new TypeError("Argument must be a number");return buffer.SlowBuffer(size)}},{buffer:9}],9:[function(require,module,exports){"use strict";var base64=require("base64-js"),ieee754=require("ieee754");exports.Buffer=Buffer,exports.SlowBuffer=function(length){+length!=length&&(length=0);return Buffer.alloc(+length)},exports.INSPECT_MAX_BYTES=50;var K_MAX_LENGTH=2147483647;function createBuffer(length){if(K_MAX_LENGTH<length)throw new RangeError("Invalid typed array length");var buf=new Uint8Array(length);return buf.__proto__=Buffer.prototype,buf}function Buffer(arg,encodingOrOffset,length){if("number"==typeof arg){if("string"==typeof encodingOrOffset)throw new Error("If encoding is specified then the first argument must be a string");return allocUnsafe(arg)}return from(arg,encodingOrOffset,length)}function from(value,encodingOrOffset,length){if("number"==typeof value)throw new TypeError('"value" argument must not be a number');return isArrayBuffer(value)?function(array,byteOffset,length){if(byteOffset<0||array.byteLength<byteOffset)throw new RangeError("'offset' is out of bounds");if(array.byteLength<byteOffset+(length||0))throw new RangeError("'length' is out of bounds");var buf;buf=void 0===byteOffset&&void 0===length?new Uint8Array(array):void 0===length?new Uint8Array(array,byteOffset):new Uint8Array(array,byteOffset,length);return buf.__proto__=Buffer.prototype,buf}(value,encodingOrOffset,length):"string"==typeof value?function(string,encoding){"string"==typeof encoding&&""!==encoding||(encoding="utf8");if(!Buffer.isEncoding(encoding))throw new TypeError('"encoding" must be a valid string encoding');var length=0|byteLength(string,encoding),buf=createBuffer(length),actual=buf.write(string,encoding);actual!==length&&(buf=buf.slice(0,actual));return buf}(value,encodingOrOffset):function(obj){if(Buffer.isBuffer(obj)){var len=0|checked(obj.length),buf=createBuffer(len);return 0===buf.length||obj.copy(buf,0,0,len),buf}if(obj){if(isArrayBufferView(obj)||"length"in obj)return"number"!=typeof obj.length||numberIsNaN(obj.length)?createBuffer(0):fromArrayLike(obj);if("Buffer"===obj.type&&Array.isArray(obj.data))return fromArrayLike(obj.data)}throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}(value)}function assertSize(size){if("number"!=typeof size)throw new TypeError('"size" argument must be a number');if(size<0)throw new RangeError('"size" argument must not be negative')}function allocUnsafe(size){return assertSize(size),createBuffer(size<0?0:0|checked(size))}function fromArrayLike(array){for(var length=array.length<0?0:0|checked(array.length),buf=createBuffer(length),i=0;i<length;i+=1)buf[i]=255&array[i];return buf}function checked(length){if(K_MAX_LENGTH<=length)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+K_MAX_LENGTH.toString(16)+" bytes");return 0|length}function byteLength(string,encoding){if(Buffer.isBuffer(string))return string.length;if(isArrayBufferView(string)||isArrayBuffer(string))return string.byteLength;"string"!=typeof string&&(string=""+string);var len=string.length;if(0===len)return 0;for(var loweredCase=!1;;)switch(encoding){case"ascii":case"latin1":case"binary":return len;case"utf8":case"utf-8":case void 0:return utf8ToBytes(string).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*len;case"hex":return len>>>1;case"base64":return base64ToBytes(string).length;default:if(loweredCase)return utf8ToBytes(string).length;encoding=(""+encoding).toLowerCase(),loweredCase=!0}}function swap(b,n,m){var i=b[n];b[n]=b[m],b[m]=i}function bidirectionalIndexOf(buffer,val,byteOffset,encoding,dir){if(0===buffer.length)return-1;if("string"==typeof byteOffset?(encoding=byteOffset,byteOffset=0):2147483647<byteOffset?byteOffset=2147483647:byteOffset<-2147483648&&(byteOffset=-2147483648),numberIsNaN(byteOffset=+byteOffset)&&(byteOffset=dir?0:buffer.length-1),byteOffset<0&&(byteOffset=buffer.length+byteOffset),byteOffset>=buffer.length){if(dir)return-1;byteOffset=buffer.length-1}else if(byteOffset<0){if(!dir)return-1;byteOffset=0}if("string"==typeof val&&(val=Buffer.from(val,encoding)),Buffer.isBuffer(val))return 0===val.length?-1:arrayIndexOf(buffer,val,byteOffset,encoding,dir);if("number"==typeof val)return val&=255,"function"==typeof Uint8Array.prototype.indexOf?dir?Uint8Array.prototype.indexOf.call(buffer,val,byteOffset):Uint8Array.prototype.lastIndexOf.call(buffer,val,byteOffset):arrayIndexOf(buffer,[val],byteOffset,encoding,dir);throw new TypeError("val must be string, number or Buffer")}function arrayIndexOf(arr,val,byteOffset,encoding,dir){var i,indexSize=1,arrLength=arr.length,valLength=val.length;if(void 0!==encoding&&("ucs2"===(encoding=String(encoding).toLowerCase())||"ucs-2"===encoding||"utf16le"===encoding||"utf-16le"===encoding)){if(arr.length<2||val.length<2)return-1;arrLength/=indexSize=2,valLength/=2,byteOffset/=2}function read(buf,i){return 1===indexSize?buf[i]:buf.readUInt16BE(i*indexSize)}if(dir){var foundIndex=-1;for(i=byteOffset;i<arrLength;i++)if(read(arr,i)===read(val,-1===foundIndex?0:i-foundIndex)){if(-1===foundIndex&&(foundIndex=i),i-foundIndex+1===valLength)return foundIndex*indexSize}else-1!==foundIndex&&(i-=i-foundIndex),foundIndex=-1}else for(arrLength<byteOffset+valLength&&(byteOffset=arrLength-valLength),i=byteOffset;0<=i;i--){for(var found=!0,j=0;j<valLength;j++)if(read(arr,i+j)!==read(val,j)){found=!1;break}if(found)return i}return-1}function hexWrite(buf,string,offset,length){offset=Number(offset)||0;var remaining=buf.length-offset;length?remaining<(length=Number(length))&&(length=remaining):length=remaining;var strLen=string.length;if(strLen%2!=0)throw new TypeError("Invalid hex string");strLen/2<length&&(length=strLen/2);for(var i=0;i<length;++i){var parsed=parseInt(string.substr(2*i,2),16);if(numberIsNaN(parsed))return i;buf[offset+i]=parsed}return i}function utf8Write(buf,string,offset,length){return blitBuffer(utf8ToBytes(string,buf.length-offset),buf,offset,length)}function asciiWrite(buf,string,offset,length){return blitBuffer(function(str){for(var byteArray=[],i=0;i<str.length;++i)byteArray.push(255&str.charCodeAt(i));return byteArray}(string),buf,offset,length)}function latin1Write(buf,string,offset,length){return asciiWrite(buf,string,offset,length)}function base64Write(buf,string,offset,length){return blitBuffer(base64ToBytes(string),buf,offset,length)}function ucs2Write(buf,string,offset,length){return blitBuffer(function(str,units){for(var c,hi,lo,byteArray=[],i=0;i<str.length&&!((units-=2)<0);++i)c=str.charCodeAt(i),hi=c>>8,lo=c%256,byteArray.push(lo),byteArray.push(hi);return byteArray}(string,buf.length-offset),buf,offset,length)}function base64Slice(buf,start,end){return 0===start&&end===buf.length?base64.fromByteArray(buf):base64.fromByteArray(buf.slice(start,end))}function utf8Slice(buf,start,end){end=Math.min(buf.length,end);for(var res=[],i=start;i<end;){var secondByte,thirdByte,fourthByte,tempCodePoint,firstByte=buf[i],codePoint=null,bytesPerSequence=239<firstByte?4:223<firstByte?3:191<firstByte?2:1;if(i+bytesPerSequence<=end)switch(bytesPerSequence){case 1:firstByte<128&&(codePoint=firstByte);break;case 2:128==(192&(secondByte=buf[i+1]))&&127<(tempCodePoint=(31&firstByte)<<6|63&secondByte)&&(codePoint=tempCodePoint);break;case 3:secondByte=buf[i+1],thirdByte=buf[i+2],128==(192&secondByte)&&128==(192&thirdByte)&&2047<(tempCodePoint=(15&firstByte)<<12|(63&secondByte)<<6|63&thirdByte)&&(tempCodePoint<55296||57343<tempCodePoint)&&(codePoint=tempCodePoint);break;case 4:secondByte=buf[i+1],thirdByte=buf[i+2],fourthByte=buf[i+3],128==(192&secondByte)&&128==(192&thirdByte)&&128==(192&fourthByte)&&65535<(tempCodePoint=(15&firstByte)<<18|(63&secondByte)<<12|(63&thirdByte)<<6|63&fourthByte)&&tempCodePoint<1114112&&(codePoint=tempCodePoint)}null===codePoint?(codePoint=65533,bytesPerSequence=1):65535<codePoint&&(codePoint-=65536,res.push(codePoint>>>10&1023|55296),codePoint=56320|1023&codePoint),res.push(codePoint),i+=bytesPerSequence}return function(codePoints){var len=codePoints.length;if(len<=MAX_ARGUMENTS_LENGTH)return String.fromCharCode.apply(String,codePoints);var res="",i=0;for(;i<len;)res+=String.fromCharCode.apply(String,codePoints.slice(i,i+=MAX_ARGUMENTS_LENGTH));return res}(res)}exports.kMaxLength=K_MAX_LENGTH,(Buffer.TYPED_ARRAY_SUPPORT=function(){try{var arr=new Uint8Array(1);return arr.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}},42===arr.foo()}catch(e){return!1}}())||"undefined"==typeof console||"function"!=typeof console.error||console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."),"undefined"!=typeof Symbol&&Symbol.species&&Buffer[Symbol.species]===Buffer&&Object.defineProperty(Buffer,Symbol.species,{value:null,configurable:!0,enumerable:!1,writable:!1}),Buffer.poolSize=8192,Buffer.from=function(value,encodingOrOffset,length){return from(value,encodingOrOffset,length)},Buffer.prototype.__proto__=Uint8Array.prototype,Buffer.__proto__=Uint8Array,Buffer.alloc=function(size,fill,encoding){return function(size,fill,encoding){return assertSize(size),size<=0?createBuffer(size):void 0!==fill?"string"==typeof encoding?createBuffer(size).fill(fill,encoding):createBuffer(size).fill(fill):createBuffer(size)}(size,fill,encoding)},Buffer.allocUnsafe=function(size){return allocUnsafe(size)},Buffer.allocUnsafeSlow=function(size){return allocUnsafe(size)},Buffer.isBuffer=function(b){return null!=b&&!0===b._isBuffer},Buffer.compare=function(a,b){if(!Buffer.isBuffer(a)||!Buffer.isBuffer(b))throw new TypeError("Arguments must be Buffers");if(a===b)return 0;for(var x=a.length,y=b.length,i=0,len=Math.min(x,y);i<len;++i)if(a[i]!==b[i]){x=a[i],y=b[i];break}return x<y?-1:y<x?1:0},Buffer.isEncoding=function(encoding){switch(String(encoding).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},Buffer.concat=function(list,length){if(!Array.isArray(list))throw new TypeError('"list" argument must be an Array of Buffers');if(0===list.length)return Buffer.alloc(0);var i;if(void 0===length)for(i=length=0;i<list.length;++i)length+=list[i].length;var buffer=Buffer.allocUnsafe(length),pos=0;for(i=0;i<list.length;++i){var buf=list[i];if(!Buffer.isBuffer(buf))throw new TypeError('"list" argument must be an Array of Buffers');buf.copy(buffer,pos),pos+=buf.length}return buffer},Buffer.byteLength=byteLength,Buffer.prototype._isBuffer=!0,Buffer.prototype.swap16=function(){var len=this.length;if(len%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var i=0;i<len;i+=2)swap(this,i,i+1);return this},Buffer.prototype.swap32=function(){var len=this.length;if(len%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var i=0;i<len;i+=4)swap(this,i,i+3),swap(this,i+1,i+2);return this},Buffer.prototype.swap64=function(){var len=this.length;if(len%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var i=0;i<len;i+=8)swap(this,i,i+7),swap(this,i+1,i+6),swap(this,i+2,i+5),swap(this,i+3,i+4);return this},Buffer.prototype.toString=function(){var length=this.length;return 0===length?"":0===arguments.length?utf8Slice(this,0,length):function(encoding,start,end){var loweredCase=!1;if((void 0===start||start<0)&&(start=0),start>this.length)return"";if((void 0===end||end>this.length)&&(end=this.length),end<=0)return"";if((end>>>=0)<=(start>>>=0))return"";for(encoding||(encoding="utf8");;)switch(encoding){case"hex":return hexSlice(this,start,end);case"utf8":case"utf-8":return utf8Slice(this,start,end);case"ascii":return asciiSlice(this,start,end);case"latin1":case"binary":return latin1Slice(this,start,end);case"base64":return base64Slice(this,start,end);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return utf16leSlice(this,start,end);default:if(loweredCase)throw new TypeError("Unknown encoding: "+encoding);encoding=(encoding+"").toLowerCase(),loweredCase=!0}}.apply(this,arguments)},Buffer.prototype.equals=function(b){if(!Buffer.isBuffer(b))throw new TypeError("Argument must be a Buffer");return this===b||0===Buffer.compare(this,b)},Buffer.prototype.inspect=function(){var str="",max=exports.INSPECT_MAX_BYTES;return 0<this.length&&(str=this.toString("hex",0,max).match(/.{2}/g).join(" "),this.length>max&&(str+=" ... ")),"<Buffer "+str+">"},Buffer.prototype.compare=function(target,start,end,thisStart,thisEnd){if(!Buffer.isBuffer(target))throw new TypeError("Argument must be a Buffer");if(void 0===start&&(start=0),void 0===end&&(end=target?target.length:0),void 0===thisStart&&(thisStart=0),void 0===thisEnd&&(thisEnd=this.length),start<0||end>target.length||thisStart<0||thisEnd>this.length)throw new RangeError("out of range index");if(thisEnd<=thisStart&&end<=start)return 0;if(thisEnd<=thisStart)return-1;if(end<=start)return 1;if(this===target)return 0;for(var x=(thisEnd>>>=0)-(thisStart>>>=0),y=(end>>>=0)-(start>>>=0),len=Math.min(x,y),thisCopy=this.slice(thisStart,thisEnd),targetCopy=target.slice(start,end),i=0;i<len;++i)if(thisCopy[i]!==targetCopy[i]){x=thisCopy[i],y=targetCopy[i];break}return x<y?-1:y<x?1:0},Buffer.prototype.includes=function(val,byteOffset,encoding){return-1!==this.indexOf(val,byteOffset,encoding)},Buffer.prototype.indexOf=function(val,byteOffset,encoding){return bidirectionalIndexOf(this,val,byteOffset,encoding,!0)},Buffer.prototype.lastIndexOf=function(val,byteOffset,encoding){return bidirectionalIndexOf(this,val,byteOffset,encoding,!1)},Buffer.prototype.write=function(string,offset,length,encoding){if(void 0===offset)encoding="utf8",length=this.length,offset=0;else if(void 0===length&&"string"==typeof offset)encoding=offset,length=this.length,offset=0;else{if(!isFinite(offset))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");offset>>>=0,isFinite(length)?(length>>>=0,void 0===encoding&&(encoding="utf8")):(encoding=length,length=void 0)}var remaining=this.length-offset;if((void 0===length||remaining<length)&&(length=remaining),0<string.length&&(length<0||offset<0)||offset>this.length)throw new RangeError("Attempt to write outside buffer bounds");encoding||(encoding="utf8");for(var loweredCase=!1;;)switch(encoding){case"hex":return hexWrite(this,string,offset,length);case"utf8":case"utf-8":return utf8Write(this,string,offset,length);case"ascii":return asciiWrite(this,string,offset,length);case"latin1":case"binary":return latin1Write(this,string,offset,length);case"base64":return base64Write(this,string,offset,length);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return ucs2Write(this,string,offset,length);default:if(loweredCase)throw new TypeError("Unknown encoding: "+encoding);encoding=(""+encoding).toLowerCase(),loweredCase=!0}},Buffer.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};var MAX_ARGUMENTS_LENGTH=4096;function asciiSlice(buf,start,end){var ret="";end=Math.min(buf.length,end);for(var i=start;i<end;++i)ret+=String.fromCharCode(127&buf[i]);return ret}function latin1Slice(buf,start,end){var ret="";end=Math.min(buf.length,end);for(var i=start;i<end;++i)ret+=String.fromCharCode(buf[i]);return ret}function hexSlice(buf,start,end){var len=buf.length;(!start||start<0)&&(start=0),(!end||end<0||len<end)&&(end=len);for(var out="",i=start;i<end;++i)out+=toHex(buf[i]);return out}function utf16leSlice(buf,start,end){for(var bytes=buf.slice(start,end),res="",i=0;i<bytes.length;i+=2)res+=String.fromCharCode(bytes[i]+256*bytes[i+1]);return res}function checkOffset(offset,ext,length){if(offset%1!=0||offset<0)throw new RangeError("offset is not uint");if(length<offset+ext)throw new RangeError("Trying to access beyond buffer length")}function checkInt(buf,value,offset,ext,max,min){if(!Buffer.isBuffer(buf))throw new TypeError('"buffer" argument must be a Buffer instance');if(max<value||value<min)throw new RangeError('"value" argument is out of bounds');if(offset+ext>buf.length)throw new RangeError("Index out of range")}function checkIEEE754(buf,value,offset,ext,max,min){if(offset+ext>buf.length)throw new RangeError("Index out of range");if(offset<0)throw new RangeError("Index out of range")}function writeFloat(buf,value,offset,littleEndian,noAssert){return value=+value,offset>>>=0,noAssert||checkIEEE754(buf,0,offset,4),ieee754.write(buf,value,offset,littleEndian,23,4),offset+4}function writeDouble(buf,value,offset,littleEndian,noAssert){return value=+value,offset>>>=0,noAssert||checkIEEE754(buf,0,offset,8),ieee754.write(buf,value,offset,littleEndian,52,8),offset+8}Buffer.prototype.slice=function(start,end){var len=this.length;(start=~~start)<0?(start+=len)<0&&(start=0):len<start&&(start=len),(end=void 0===end?len:~~end)<0?(end+=len)<0&&(end=0):len<end&&(end=len),end<start&&(end=start);var newBuf=this.subarray(start,end);return newBuf.__proto__=Buffer.prototype,newBuf},Buffer.prototype.readUIntLE=function(offset,byteLength,noAssert){offset>>>=0,byteLength>>>=0,noAssert||checkOffset(offset,byteLength,this.length);for(var val=this[offset],mul=1,i=0;++i<byteLength&&(mul*=256);)val+=this[offset+i]*mul;return val},Buffer.prototype.readUIntBE=function(offset,byteLength,noAssert){offset>>>=0,byteLength>>>=0,noAssert||checkOffset(offset,byteLength,this.length);for(var val=this[offset+--byteLength],mul=1;0<byteLength&&(mul*=256);)val+=this[offset+--byteLength]*mul;return val},Buffer.prototype.readUInt8=function(offset,noAssert){return offset>>>=0,noAssert||checkOffset(offset,1,this.length),this[offset]},Buffer.prototype.readUInt16LE=function(offset,noAssert){return offset>>>=0,noAssert||checkOffset(offset,2,this.length),this[offset]|this[offset+1]<<8},Buffer.prototype.readUInt16BE=function(offset,noAssert){return offset>>>=0,noAssert||checkOffset(offset,2,this.length),this[offset]<<8|this[offset+1]},Buffer.prototype.readUInt32LE=function(offset,noAssert){return offset>>>=0,noAssert||checkOffset(offset,4,this.length),(this[offset]|this[offset+1]<<8|this[offset+2]<<16)+16777216*this[offset+3]},Buffer.prototype.readUInt32BE=function(offset,noAssert){return offset>>>=0,noAssert||checkOffset(offset,4,this.length),16777216*this[offset]+(this[offset+1]<<16|this[offset+2]<<8|this[offset+3])},Buffer.prototype.readIntLE=function(offset,byteLength,noAssert){offset>>>=0,byteLength>>>=0,noAssert||checkOffset(offset,byteLength,this.length);for(var val=this[offset],mul=1,i=0;++i<byteLength&&(mul*=256);)val+=this[offset+i]*mul;return(mul*=128)<=val&&(val-=Math.pow(2,8*byteLength)),val},Buffer.prototype.readIntBE=function(offset,byteLength,noAssert){offset>>>=0,byteLength>>>=0,noAssert||checkOffset(offset,byteLength,this.length);for(var i=byteLength,mul=1,val=this[offset+--i];0<i&&(mul*=256);)val+=this[offset+--i]*mul;return(mul*=128)<=val&&(val-=Math.pow(2,8*byteLength)),val},Buffer.prototype.readInt8=function(offset,noAssert){return offset>>>=0,noAssert||checkOffset(offset,1,this.length),128&this[offset]?-1*(255-this[offset]+1):this[offset]},Buffer.prototype.readInt16LE=function(offset,noAssert){offset>>>=0,noAssert||checkOffset(offset,2,this.length);var val=this[offset]|this[offset+1]<<8;return 32768&val?4294901760|val:val},Buffer.prototype.readInt16BE=function(offset,noAssert){offset>>>=0,noAssert||checkOffset(offset,2,this.length);var val=this[offset+1]|this[offset]<<8;return 32768&val?4294901760|val:val},Buffer.prototype.readInt32LE=function(offset,noAssert){return offset>>>=0,noAssert||checkOffset(offset,4,this.length),this[offset]|this[offset+1]<<8|this[offset+2]<<16|this[offset+3]<<24},Buffer.prototype.readInt32BE=function(offset,noAssert){return offset>>>=0,noAssert||checkOffset(offset,4,this.length),this[offset]<<24|this[offset+1]<<16|this[offset+2]<<8|this[offset+3]},Buffer.prototype.readFloatLE=function(offset,noAssert){return offset>>>=0,noAssert||checkOffset(offset,4,this.length),ieee754.read(this,offset,!0,23,4)},Buffer.prototype.readFloatBE=function(offset,noAssert){return offset>>>=0,noAssert||checkOffset(offset,4,this.length),ieee754.read(this,offset,!1,23,4)},Buffer.prototype.readDoubleLE=function(offset,noAssert){return offset>>>=0,noAssert||checkOffset(offset,8,this.length),ieee754.read(this,offset,!0,52,8)},Buffer.prototype.readDoubleBE=function(offset,noAssert){return offset>>>=0,noAssert||checkOffset(offset,8,this.length),ieee754.read(this,offset,!1,52,8)},Buffer.prototype.writeUIntLE=function(value,offset,byteLength,noAssert){(value=+value,offset>>>=0,byteLength>>>=0,noAssert)||checkInt(this,value,offset,byteLength,Math.pow(2,8*byteLength)-1,0);var mul=1,i=0;for(this[offset]=255&value;++i<byteLength&&(mul*=256);)this[offset+i]=value/mul&255;return offset+byteLength},Buffer.prototype.writeUIntBE=function(value,offset,byteLength,noAssert){(value=+value,offset>>>=0,byteLength>>>=0,noAssert)||checkInt(this,value,offset,byteLength,Math.pow(2,8*byteLength)-1,0);var i=byteLength-1,mul=1;for(this[offset+i]=255&value;0<=--i&&(mul*=256);)this[offset+i]=value/mul&255;return offset+byteLength},Buffer.prototype.writeUInt8=function(value,offset,noAssert){return value=+value,offset>>>=0,noAssert||checkInt(this,value,offset,1,255,0),this[offset]=255&value,offset+1},Buffer.prototype.writeUInt16LE=function(value,offset,noAssert){return value=+value,offset>>>=0,noAssert||checkInt(this,value,offset,2,65535,0),this[offset]=255&value,this[offset+1]=value>>>8,offset+2},Buffer.prototype.writeUInt16BE=function(value,offset,noAssert){return value=+value,offset>>>=0,noAssert||checkInt(this,value,offset,2,65535,0),this[offset]=value>>>8,this[offset+1]=255&value,offset+2},Buffer.prototype.writeUInt32LE=function(value,offset,noAssert){return value=+value,offset>>>=0,noAssert||checkInt(this,value,offset,4,4294967295,0),this[offset+3]=value>>>24,this[offset+2]=value>>>16,this[offset+1]=value>>>8,this[offset]=255&value,offset+4},Buffer.prototype.writeUInt32BE=function(value,offset,noAssert){return value=+value,offset>>>=0,noAssert||checkInt(this,value,offset,4,4294967295,0),this[offset]=value>>>24,this[offset+1]=value>>>16,this[offset+2]=value>>>8,this[offset+3]=255&value,offset+4},Buffer.prototype.writeIntLE=function(value,offset,byteLength,noAssert){if(value=+value,offset>>>=0,!noAssert){var limit=Math.pow(2,8*byteLength-1);checkInt(this,value,offset,byteLength,limit-1,-limit)}var i=0,mul=1,sub=0;for(this[offset]=255&value;++i<byteLength&&(mul*=256);)value<0&&0===sub&&0!==this[offset+i-1]&&(sub=1),this[offset+i]=(value/mul>>0)-sub&255;return offset+byteLength},Buffer.prototype.writeIntBE=function(value,offset,byteLength,noAssert){if(value=+value,offset>>>=0,!noAssert){var limit=Math.pow(2,8*byteLength-1);checkInt(this,value,offset,byteLength,limit-1,-limit)}var i=byteLength-1,mul=1,sub=0;for(this[offset+i]=255&value;0<=--i&&(mul*=256);)value<0&&0===sub&&0!==this[offset+i+1]&&(sub=1),this[offset+i]=(value/mul>>0)-sub&255;return offset+byteLength},Buffer.prototype.writeInt8=function(value,offset,noAssert){return value=+value,offset>>>=0,noAssert||checkInt(this,value,offset,1,127,-128),value<0&&(value=255+value+1),this[offset]=255&value,offset+1},Buffer.prototype.writeInt16LE=function(value,offset,noAssert){return value=+value,offset>>>=0,noAssert||checkInt(this,value,offset,2,32767,-32768),this[offset]=255&value,this[offset+1]=value>>>8,offset+2},Buffer.prototype.writeInt16BE=function(value,offset,noAssert){return value=+value,offset>>>=0,noAssert||checkInt(this,value,offset,2,32767,-32768),this[offset]=value>>>8,this[offset+1]=255&value,offset+2},Buffer.prototype.writeInt32LE=function(value,offset,noAssert){return value=+value,offset>>>=0,noAssert||checkInt(this,value,offset,4,2147483647,-2147483648),this[offset]=255&value,this[offset+1]=value>>>8,this[offset+2]=value>>>16,this[offset+3]=value>>>24,offset+4},Buffer.prototype.writeInt32BE=function(value,offset,noAssert){return value=+value,offset>>>=0,noAssert||checkInt(this,value,offset,4,2147483647,-2147483648),value<0&&(value=4294967295+value+1),this[offset]=value>>>24,this[offset+1]=value>>>16,this[offset+2]=value>>>8,this[offset+3]=255&value,offset+4},Buffer.prototype.writeFloatLE=function(value,offset,noAssert){return writeFloat(this,value,offset,!0,noAssert)},Buffer.prototype.writeFloatBE=function(value,offset,noAssert){return writeFloat(this,value,offset,!1,noAssert)},Buffer.prototype.writeDoubleLE=function(value,offset,noAssert){return writeDouble(this,value,offset,!0,noAssert)},Buffer.prototype.writeDoubleBE=function(value,offset,noAssert){return writeDouble(this,value,offset,!1,noAssert)},Buffer.prototype.copy=function(target,targetStart,start,end){if(start||(start=0),end||0===end||(end=this.length),targetStart>=target.length&&(targetStart=target.length),targetStart||(targetStart=0),0<end&&end<start&&(end=start),end===start)return 0;if(0===target.length||0===this.length)return 0;if(targetStart<0)throw new RangeError("targetStart out of bounds");if(start<0||start>=this.length)throw new RangeError("sourceStart out of bounds");if(end<0)throw new RangeError("sourceEnd out of bounds");end>this.length&&(end=this.length),target.length-targetStart<end-start&&(end=target.length-targetStart+start);var i,len=end-start;if(this===target&&start<targetStart&&targetStart<end)for(i=len-1;0<=i;--i)target[i+targetStart]=this[i+start];else if(len<1e3)for(i=0;i<len;++i)target[i+targetStart]=this[i+start];else Uint8Array.prototype.set.call(target,this.subarray(start,start+len),targetStart);return len},Buffer.prototype.fill=function(val,start,end,encoding){if("string"==typeof val){if("string"==typeof start?(encoding=start,start=0,end=this.length):"string"==typeof end&&(encoding=end,end=this.length),1===val.length){var code=val.charCodeAt(0);code<256&&(val=code)}if(void 0!==encoding&&"string"!=typeof encoding)throw new TypeError("encoding must be a string");if("string"==typeof encoding&&!Buffer.isEncoding(encoding))throw new TypeError("Unknown encoding: "+encoding)}else"number"==typeof val&&(val&=255);if(start<0||this.length<start||this.length<end)throw new RangeError("Out of range index");if(end<=start)return this;var i;if(start>>>=0,end=void 0===end?this.length:end>>>0,val||(val=0),"number"==typeof val)for(i=start;i<end;++i)this[i]=val;else{var bytes=Buffer.isBuffer(val)?val:new Buffer(val,encoding),len=bytes.length;for(i=0;i<end-start;++i)this[i+start]=bytes[i%len]}return this};var INVALID_BASE64_RE=/[^+/0-9A-Za-z-_]/g;function toHex(n){return n<16?"0"+n.toString(16):n.toString(16)}function utf8ToBytes(string,units){var codePoint;units=units||1/0;for(var length=string.length,leadSurrogate=null,bytes=[],i=0;i<length;++i){if(55295<(codePoint=string.charCodeAt(i))&&codePoint<57344){if(!leadSurrogate){if(56319<codePoint){-1<(units-=3)&&bytes.push(239,191,189);continue}if(i+1===length){-1<(units-=3)&&bytes.push(239,191,189);continue}leadSurrogate=codePoint;continue}if(codePoint<56320){-1<(units-=3)&&bytes.push(239,191,189),leadSurrogate=codePoint;continue}codePoint=65536+(leadSurrogate-55296<<10|codePoint-56320)}else leadSurrogate&&-1<(units-=3)&&bytes.push(239,191,189);if(leadSurrogate=null,codePoint<128){if((units-=1)<0)break;bytes.push(codePoint)}else if(codePoint<2048){if((units-=2)<0)break;bytes.push(codePoint>>6|192,63&codePoint|128)}else if(codePoint<65536){if((units-=3)<0)break;bytes.push(codePoint>>12|224,codePoint>>6&63|128,63&codePoint|128)}else{if(!(codePoint<1114112))throw new Error("Invalid code point");if((units-=4)<0)break;bytes.push(codePoint>>18|240,codePoint>>12&63|128,codePoint>>6&63|128,63&codePoint|128)}}return bytes}function base64ToBytes(str){return base64.toByteArray(function(str){if((str=str.trim().replace(INVALID_BASE64_RE,"")).length<2)return"";for(;str.length%4!=0;)str+="=";return str}(str))}function blitBuffer(src,dst,offset,length){for(var i=0;i<length&&!(i+offset>=dst.length||i>=src.length);++i)dst[i+offset]=src[i];return i}function isArrayBuffer(obj){return obj instanceof ArrayBuffer||null!=obj&&null!=obj.constructor&&"ArrayBuffer"===obj.constructor.name&&"number"==typeof obj.byteLength}function isArrayBufferView(obj){return"function"==typeof ArrayBuffer.isView&&ArrayBuffer.isView(obj)}function numberIsNaN(obj){return obj!=obj}},{"base64-js":2,ieee754:21}],10:[function(require,module,exports){"use strict";var validate=require("./validation").validate,CHARSET_INVERSE_INDEX={q:0,p:1,z:2,r:3,y:4,9:5,x:6,8:7,g:8,f:9,2:10,t:11,v:12,d:13,w:14,0:15,s:16,3:17,j:18,n:19,5:20,4:21,k:22,h:23,c:24,e:25,6:26,m:27,u:28,a:29,7:30,l:31};module.exports={encode:function(data){validate(data instanceof Uint8Array,"Invalid data: "+data+".");for(var base32="",i=0;i<data.length;++i){var value=data[i];validate(0<=value&&value<32,"Invalid value: "+value+"."),base32+="qpzry9x8gf2tvdw0s3jn54khce6mua7l"[value]}return base32},decode:function(string){validate("string"==typeof string,"Invalid base32-encoded string: "+string+".");for(var data=new Uint8Array(string.length),i=0;i<string.length;++i){var value=string[i];validate(value in CHARSET_INVERSE_INDEX,"Invalid value: "+value+"."),data[i]=CHARSET_INVERSE_INDEX[value]}return data}}},{"./validation":13}],11:[function(require,module,exports){"use strict";var base32=require("./base32"),bigInt=require("big-integer"),convertBits=require("./convertBits"),validation=require("./validation"),validate=validation.validate;var ValidationError=validation.ValidationError,VALID_PREFIXES=["bitcoincash","bchtest","bchreg"];function prefixToUint5Array(prefix){for(var result=new Uint8Array(prefix.length),i=0;i<prefix.length;++i)result[i]=31&prefix[i].charCodeAt(0);return result}function concat(a,b){var ab=new Uint8Array(a.length+b.length);return ab.set(a),ab.set(b,a.length),ab}function polymod(data){for(var GENERATOR=[656907472481,522768456162,0xf33e5fb3c4,748107326120,130178868336],checksum=bigInt(1),i=0;i<data.length;++i){var value=data[i],topBits=checksum.shiftRight(35);checksum=checksum.and(34359738367).shiftLeft(5).xor(value);for(var j=0;j<GENERATOR.length;++j)topBits.shiftRight(j).and(1).equals(1)&&(checksum=checksum.xor(GENERATOR[j]))}return checksum.xor(1)}function hasSingleCase(string){return string===string.toLowerCase()||string===string.toUpperCase()}module.exports={encode:function(prefix,type,hash){validate("string"==typeof prefix&&function(prefix){return hasSingleCase(prefix)&&-1!==VALID_PREFIXES.indexOf(prefix.toLowerCase())}(prefix),"Invalid prefix: "+prefix+"."),validate("string"==typeof type,"Invalid type: "+type+"."),validate(hash instanceof Uint8Array,"Invalid hash: "+hash+".");var data,prefixData=concat(prefixToUint5Array(prefix),new Uint8Array(1)),versionByte=function(type){switch(type){case"P2PKH":return 0;case"P2SH":return 8;default:throw new ValidationError("Invalid type: "+type+".")}}(type)+function(hash){switch(8*hash.length){case 160:return 0;case 192:return 1;case 224:return 2;case 256:return 3;case 320:return 4;case 384:return 5;case 448:return 6;case 512:return 7;default:throw new ValidationError("Invalid hash size: "+hash.length+".")}}(hash),payloadData=(data=concat(new Uint8Array([versionByte]),hash),convertBits(data,8,5)),payload=concat(payloadData,function(checksum){for(var result=new Uint8Array(8),i=0;i<8;++i)result[7-i]=checksum.and(31).toJSNumber(),checksum=checksum.shiftRight(5);return result}(polymod(concat(concat(prefixData,payloadData),new Uint8Array(8)))));return prefix+":"+base32.encode(payload)},decode:function(address){validate("string"==typeof address&&hasSingleCase(address),"Invalid address: "+address+".");var pieces=address.toLowerCase().split(":");validate(2===pieces.length,"Missing prefix: "+address+".");var prefix=pieces[0],payload=base32.decode(pieces[1]);validate(function(prefix,payload){return polymod(concat(concat(prefixToUint5Array(prefix),new Uint8Array(1)),payload)).equals(0)}(prefix,payload),"Invalid checksum: "+address+".");var data,payloadData=(data=payload.subarray(0,-8),convertBits(data,5,8,!0)),versionByte=payloadData[0],hash=payloadData.subarray(1);return validate(function(versionByte){switch(7&versionByte){case 0:return 160;case 1:return 192;case 2:return 224;case 3:return 256;case 4:return 320;case 5:return 384;case 6:return 448;case 7:return 512}}(versionByte)===8*hash.length,"Invalid hash size: "+address+"."),{prefix:prefix,type:function(versionByte){switch(120&versionByte){case 0:return"P2PKH";case 8:return"P2SH";default:throw new ValidationError("Invalid address type in version byte: "+versionByte+".")}}(versionByte),hash:hash}},ValidationError:ValidationError}},{"./base32":10,"./convertBits":12,"./validation":13,"big-integer":3}],12:[function(require,module,exports){"use strict";var validate=require("./validation").validate;module.exports=function(data,from,to,strictMode){for(var length=strictMode?Math.floor(data.length*from/to):Math.ceil(data.length*from/to),mask=(1<<to)-1,result=new Uint8Array(length),index=0,accumulator=0,bits=0,i=0;i<data.length;++i){var value=data[i];for(validate(0<=value&&value>>from==0,"Invalid value: "+value+"."),accumulator=accumulator<<from|value,bits+=from;to<=bits;)bits-=to,result[index]=accumulator>>bits&mask,++index}return strictMode?validate(bits<from&&0==(accumulator<<to-bits&mask),"Input cannot be converted to "+to+" bits without padding, but strict mode was used."):0<bits&&(result[index]=accumulator<<to-bits&mask,++index),result}},{"./validation":13}],13:[function(require,module,exports){"use strict";function ValidationError(message){var error=new Error;this.name=error.name="ValidationError",this.message=error.message=message,this.stack=error.stack}ValidationError.prototype=Object.create(Error.prototype),module.exports={ValidationError:ValidationError,validate:function(condition,message){if(!condition)throw new ValidationError(message)}}},{}],14:[function(require,module,exports){var Buffer=require("safe-buffer").Buffer,Transform=require("stream").Transform,StringDecoder=require("string_decoder").StringDecoder;function CipherBase(hashMode){Transform.call(this),this.hashMode="string"==typeof hashMode,this.hashMode?this[hashMode]=this._finalOrDigest:this.final=this._finalOrDigest,this._final&&(this.__final=this._final,this._final=null),this._decoder=null,this._encoding=null}require("inherits")(CipherBase,Transform),CipherBase.prototype.update=function(data,inputEnc,outputEnc){"string"==typeof data&&(data=Buffer.from(data,inputEnc));var outData=this._update(data);return this.hashMode?this:(outputEnc&&(outData=this._toString(outData,outputEnc)),outData)},CipherBase.prototype.setAutoPadding=function(){},CipherBase.prototype.getAuthTag=function(){throw new Error("trying to get auth tag in unsupported state")},CipherBase.prototype.setAuthTag=function(){throw new Error("trying to set auth tag in unsupported state")},CipherBase.prototype.setAAD=function(){throw new Error("trying to set aad in unsupported state")},CipherBase.prototype._transform=function(data,_,next){var err;try{this.hashMode?this._update(data):this.push(this._update(data))}catch(e){err=e}finally{next(err)}},CipherBase.prototype._flush=function(done){var err;try{this.push(this.__final())}catch(e){err=e}done(err)},CipherBase.prototype._finalOrDigest=function(outputEnc){var outData=this.__final()||Buffer.alloc(0);return outputEnc&&(outData=this._toString(outData,outputEnc,!0)),outData},CipherBase.prototype._toString=function(value,enc,fin){if(this._decoder||(this._decoder=new StringDecoder(enc),this._encoding=enc),this._encoding!==enc)throw new Error("can't switch encodings");var out=this._decoder.write(value);return fin&&(out+=this._decoder.end()),out},module.exports=CipherBase},{inherits:22,"safe-buffer":41,stream:50,string_decoder:51}],15:[function(require,module,exports){(function(Buffer){function objectToString(o){return Object.prototype.toString.call(o)}exports.isArray=function(arg){return Array.isArray?Array.isArray(arg):"[object Array]"===objectToString(arg)},exports.isBoolean=function(arg){return"boolean"==typeof arg},exports.isNull=function(arg){return null===arg},exports.isNullOrUndefined=function(arg){return null==arg},exports.isNumber=function(arg){return"number"==typeof arg},exports.isString=function(arg){return"string"==typeof arg},exports.isSymbol=function(arg){return"symbol"==typeof arg},exports.isUndefined=function(arg){return void 0===arg},exports.isRegExp=function(re){return"[object RegExp]"===objectToString(re)},exports.isObject=function(arg){return"object"==typeof arg&&null!==arg},exports.isDate=function(d){return"[object Date]"===objectToString(d)},exports.isError=function(e){return"[object Error]"===objectToString(e)||e instanceof Error},exports.isFunction=function(arg){return"function"==typeof arg},exports.isPrimitive=function(arg){return null===arg||"boolean"==typeof arg||"number"==typeof arg||"string"==typeof arg||"symbol"==typeof arg||void 0===arg},exports.isBuffer=Buffer.isBuffer}).call(this,{isBuffer:require("../../is-buffer/index.js")})},{"../../is-buffer/index.js":23}],16:[function(require,module,exports){(function(Buffer){"use strict";var inherits=require("inherits"),md5=require("./md5"),RIPEMD160=require("ripemd160"),sha=require("sha.js"),Base=require("cipher-base");function HashNoConstructor(hash){Base.call(this,"digest"),this._hash=hash,this.buffers=[]}function Hash(hash){Base.call(this,"digest"),this._hash=hash}inherits(HashNoConstructor,Base),HashNoConstructor.prototype._update=function(data){this.buffers.push(data)},HashNoConstructor.prototype._final=function(){var buf=Buffer.concat(this.buffers),r=this._hash(buf);return this.buffers=null,r},inherits(Hash,Base),Hash.prototype._update=function(data){this._hash.update(data)},Hash.prototype._final=function(){return this._hash.digest()},module.exports=function(alg){return"md5"===(alg=alg.toLowerCase())?new HashNoConstructor(md5):new Hash("rmd160"===alg||"ripemd160"===alg?new RIPEMD160:sha(alg))}}).call(this,require("buffer").Buffer)},{"./md5":18,buffer:9,"cipher-base":14,inherits:22,ripemd160:40,"sha.js":43}],17:[function(require,module,exports){(function(Buffer){"use strict";var zeroBuffer=new Buffer(4);zeroBuffer.fill(0);module.exports=function(buf,fn){var arr=fn(function(buf){if(buf.length%4!=0){var len=buf.length+(4-buf.length%4);buf=Buffer.concat([buf,zeroBuffer],len)}for(var arr=new Array(buf.length>>>2),i=0,j=0;i<buf.length;i+=4,j++)arr[j]=buf.readInt32LE(i);return arr}(buf),8*buf.length);buf=new Buffer(16);for(var i=0;i<arr.length;i++)buf.writeInt32LE(arr[i],i<<2,!0);return buf}}).call(this,require("buffer").Buffer)},{buffer:9}],18:[function(require,module,exports){"use strict";var makeHash=require("./make-hash");function core_md5(x,len){x[len>>5]|=128<<len%32,x[14+(len+64>>>9<<4)]=len;for(var a=1732584193,b=-271733879,c=-1732584194,d=271733878,i=0;i<x.length;i+=16){var olda=a,oldb=b,oldc=c,oldd=d;b=md5_ii(b=md5_ii(b=md5_ii(b=md5_ii(b=md5_hh(b=md5_hh(b=md5_hh(b=md5_hh(b=md5_gg(b=md5_gg(b=md5_gg(b=md5_gg(b=md5_ff(b=md5_ff(b=md5_ff(b=md5_ff(b,c=md5_ff(c,d=md5_ff(d,a=md5_ff(a,b,c,d,x[i+0],7,-680876936),b,c,x[i+1],12,-389564586),a,b,x[i+2],17,606105819),d,a,x[i+3],22,-1044525330),c=md5_ff(c,d=md5_ff(d,a=md5_ff(a,b,c,d,x[i+4],7,-176418897),b,c,x[i+5],12,1200080426),a,b,x[i+6],17,-1473231341),d,a,x[i+7],22,-45705983),c=md5_ff(c,d=md5_ff(d,a=md5_ff(a,b,c,d,x[i+8],7,1770035416),b,c,x[i+9],12,-1958414417),a,b,x[i+10],17,-42063),d,a,x[i+11],22,-1990404162),c=md5_ff(c,d=md5_ff(d,a=md5_ff(a,b,c,d,x[i+12],7,1804603682),b,c,x[i+13],12,-40341101),a,b,x[i+14],17,-1502002290),d,a,x[i+15],22,1236535329),c=md5_gg(c,d=md5_gg(d,a=md5_gg(a,b,c,d,x[i+1],5,-165796510),b,c,x[i+6],9,-1069501632),a,b,x[i+11],14,643717713),d,a,x[i+0],20,-373897302),c=md5_gg(c,d=md5_gg(d,a=md5_gg(a,b,c,d,x[i+5],5,-701558691),b,c,x[i+10],9,38016083),a,b,x[i+15],14,-660478335),d,a,x[i+4],20,-405537848),c=md5_gg(c,d=md5_gg(d,a=md5_gg(a,b,c,d,x[i+9],5,568446438),b,c,x[i+14],9,-1019803690),a,b,x[i+3],14,-187363961),d,a,x[i+8],20,1163531501),c=md5_gg(c,d=md5_gg(d,a=md5_gg(a,b,c,d,x[i+13],5,-1444681467),b,c,x[i+2],9,-51403784),a,b,x[i+7],14,1735328473),d,a,x[i+12],20,-1926607734),c=md5_hh(c,d=md5_hh(d,a=md5_hh(a,b,c,d,x[i+5],4,-378558),b,c,x[i+8],11,-2022574463),a,b,x[i+11],16,1839030562),d,a,x[i+14],23,-35309556),c=md5_hh(c,d=md5_hh(d,a=md5_hh(a,b,c,d,x[i+1],4,-1530992060),b,c,x[i+4],11,1272893353),a,b,x[i+7],16,-155497632),d,a,x[i+10],23,-1094730640),c=md5_hh(c,d=md5_hh(d,a=md5_hh(a,b,c,d,x[i+13],4,681279174),b,c,x[i+0],11,-358537222),a,b,x[i+3],16,-722521979),d,a,x[i+6],23,76029189),c=md5_hh(c,d=md5_hh(d,a=md5_hh(a,b,c,d,x[i+9],4,-640364487),b,c,x[i+12],11,-421815835),a,b,x[i+15],16,530742520),d,a,x[i+2],23,-995338651),c=md5_ii(c,d=md5_ii(d,a=md5_ii(a,b,c,d,x[i+0],6,-198630844),b,c,x[i+7],10,1126891415),a,b,x[i+14],15,-1416354905),d,a,x[i+5],21,-57434055),c=md5_ii(c,d=md5_ii(d,a=md5_ii(a,b,c,d,x[i+12],6,1700485571),b,c,x[i+3],10,-1894986606),a,b,x[i+10],15,-1051523),d,a,x[i+1],21,-2054922799),c=md5_ii(c,d=md5_ii(d,a=md5_ii(a,b,c,d,x[i+8],6,1873313359),b,c,x[i+15],10,-30611744),a,b,x[i+6],15,-1560198380),d,a,x[i+13],21,1309151649),c=md5_ii(c,d=md5_ii(d,a=md5_ii(a,b,c,d,x[i+4],6,-145523070),b,c,x[i+11],10,-1120210379),a,b,x[i+2],15,718787259),d,a,x[i+9],21,-343485551),a=safe_add(a,olda),b=safe_add(b,oldb),c=safe_add(c,oldc),d=safe_add(d,oldd)}return[a,b,c,d]}function md5_cmn(q,a,b,x,s,t){return safe_add((num=safe_add(safe_add(a,q),safe_add(x,t)))<<(cnt=s)|num>>>32-cnt,b);var num,cnt}function md5_ff(a,b,c,d,x,s,t){return md5_cmn(b&c|~b&d,a,b,x,s,t)}function md5_gg(a,b,c,d,x,s,t){return md5_cmn(b&d|c&~d,a,b,x,s,t)}function md5_hh(a,b,c,d,x,s,t){return md5_cmn(b^c^d,a,b,x,s,t)}function md5_ii(a,b,c,d,x,s,t){return md5_cmn(c^(b|~d),a,b,x,s,t)}function safe_add(x,y){var lsw=(65535&x)+(65535&y);return(x>>16)+(y>>16)+(lsw>>16)<<16|65535&lsw}module.exports=function(buf){return makeHash(buf,core_md5)}},{"./make-hash":17}],19:[function(require,module,exports){function EventEmitter(){this._events=this._events||{},this._maxListeners=this._maxListeners||void 0}function isFunction(arg){return"function"==typeof arg}function isObject(arg){return"object"==typeof arg&&null!==arg}function isUndefined(arg){return void 0===arg}((module.exports=EventEmitter).EventEmitter=EventEmitter).prototype._events=void 0,EventEmitter.prototype._maxListeners=void 0,EventEmitter.defaultMaxListeners=10,EventEmitter.prototype.setMaxListeners=function(n){if("number"!=typeof n||n<0||isNaN(n))throw TypeError("n must be a positive number");return this._maxListeners=n,this},EventEmitter.prototype.emit=function(type){var er,handler,len,args,i,listeners;if(this._events||(this._events={}),"error"===type&&(!this._events.error||isObject(this._events.error)&&!this._events.error.length)){if((er=arguments[1])instanceof Error)throw er;var err=new Error('Uncaught, unspecified "error" event. ('+er+")");throw err.context=er,err}if(isUndefined(handler=this._events[type]))return!1;if(isFunction(handler))switch(arguments.length){case 1:handler.call(this);break;case 2:handler.call(this,arguments[1]);break;case 3:handler.call(this,arguments[1],arguments[2]);break;default:args=Array.prototype.slice.call(arguments,1),handler.apply(this,args)}else if(isObject(handler))for(args=Array.prototype.slice.call(arguments,1),len=(listeners=handler.slice()).length,i=0;i<len;i++)listeners[i].apply(this,args);return!0},EventEmitter.prototype.on=EventEmitter.prototype.addListener=function(type,listener){var m;if(!isFunction(listener))throw TypeError("listener must be a function");return this._events||(this._events={}),this._events.newListener&&this.emit("newListener",type,isFunction(listener.listener)?listener.listener:listener),this._events[type]?isObject(this._events[type])?this._events[type].push(listener):this._events[type]=[this._events[type],listener]:this._events[type]=listener,isObject(this._events[type])&&!this._events[type].warned&&(m=isUndefined(this._maxListeners)?EventEmitter.defaultMaxListeners:this._maxListeners)&&0<m&&this._events[type].length>m&&(this._events[type].warned=!0,console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",this._events[type].length),"function"==typeof console.trace&&console.trace()),this},EventEmitter.prototype.once=function(type,listener){if(!isFunction(listener))throw TypeError("listener must be a function");var fired=!1;function g(){this.removeListener(type,g),fired||(fired=!0,listener.apply(this,arguments))}return g.listener=listener,this.on(type,g),this},EventEmitter.prototype.removeListener=function(type,listener){var list,position,length,i;if(!isFunction(listener))throw TypeError("listener must be a function");if(!this._events||!this._events[type])return this;if(length=(list=this._events[type]).length,position=-1,list===listener||isFunction(list.listener)&&list.listener===listener)delete this._events[type],this._events.removeListener&&this.emit("removeListener",type,listener);else if(isObject(list)){for(i=length;0<i--;)if(list[i]===listener||list[i].listener&&list[i].listener===listener){position=i;break}if(position<0)return this;1===list.length?(list.length=0,delete this._events[type]):list.splice(position,1),this._events.removeListener&&this.emit("removeListener",type,listener)}return this},EventEmitter.prototype.removeAllListeners=function(type){var key,listeners;if(!this._events)return this;if(!this._events.removeListener)return 0===arguments.length?this._events={}:this._events[type]&&delete this._events[type],this;if(0===arguments.length){for(key in this._events)"removeListener"!==key&&this.removeAllListeners(key);return this.removeAllListeners("removeListener"),this._events={},this}if(isFunction(listeners=this._events[type]))this.removeListener(type,listeners);else if(listeners)for(;listeners.length;)this.removeListener(type,listeners[listeners.length-1]);return delete this._events[type],this},EventEmitter.prototype.listeners=function(type){return this._events&&this._events[type]?isFunction(this._events[type])?[this._events[type]]:this._events[type].slice():[]},EventEmitter.prototype.listenerCount=function(type){if(this._events){var evlistener=this._events[type];if(isFunction(evlistener))return 1;if(evlistener)return evlistener.length}return 0},EventEmitter.listenerCount=function(emitter,type){return emitter.listenerCount(type)}},{}],20:[function(require,module,exports){(function(Buffer){"use strict";var Transform=require("stream").Transform;function HashBase(blockSize){Transform.call(this),this._block=new Buffer(blockSize),this._blockSize=blockSize,this._blockOffset=0,this._length=[0,0,0,0],this._finalized=!1}require("inherits")(HashBase,Transform),HashBase.prototype._transform=function(chunk,encoding,callback){var error=null;try{"buffer"!==encoding&&(chunk=new Buffer(chunk,encoding)),this.update(chunk)}catch(err){error=err}callback(error)},HashBase.prototype._flush=function(callback){var error=null;try{this.push(this._digest())}catch(err){error=err}callback(error)},HashBase.prototype.update=function(data,encoding){if(!Buffer.isBuffer(data)&&"string"!=typeof data)throw new TypeError("Data must be a string or a buffer");if(this._finalized)throw new Error("Digest already called");Buffer.isBuffer(data)||(data=new Buffer(data,encoding||"binary"));for(var block=this._block,offset=0;this._blockOffset+data.length-offset>=this._blockSize;){for(var i=this._blockOffset;i<this._blockSize;)block[i++]=data[offset++];this._update(),this._blockOffset=0}for(;offset<data.length;)block[this._blockOffset++]=data[offset++];for(var j=0,carry=8*data.length;0<carry;++j)this._length[j]+=carry,0<(carry=this._length[j]/4294967296|0)&&(this._length[j]-=4294967296*carry);return this},HashBase.prototype._update=function(data){throw new Error("_update is not implemented")},HashBase.prototype.digest=function(encoding){if(this._finalized)throw new Error("Digest already called");this._finalized=!0;var digest=this._digest();return void 0!==encoding&&(digest=digest.toString(encoding)),digest},HashBase.prototype._digest=function(){throw new Error("_digest is not implemented")},module.exports=HashBase}).call(this,require("buffer").Buffer)},{buffer:9,inherits:22,stream:50}],21:[function(require,module,exports){exports.read=function(buffer,offset,isLE,mLen,nBytes){var e,m,eLen=8*nBytes-mLen-1,eMax=(1<<eLen)-1,eBias=eMax>>1,nBits=-7,i=isLE?nBytes-1:0,d=isLE?-1:1,s=buffer[offset+i];for(i+=d,e=s&(1<<-nBits)-1,s>>=-nBits,nBits+=eLen;0<nBits;e=256*e+buffer[offset+i],i+=d,nBits-=8);for(m=e&(1<<-nBits)-1,e>>=-nBits,nBits+=mLen;0<nBits;m=256*m+buffer[offset+i],i+=d,nBits-=8);if(0===e)e=1-eBias;else{if(e===eMax)return m?NaN:1/0*(s?-1:1);m+=Math.pow(2,mLen),e-=eBias}return(s?-1:1)*m*Math.pow(2,e-mLen)},exports.write=function(buffer,value,offset,isLE,mLen,nBytes){var e,m,c,eLen=8*nBytes-mLen-1,eMax=(1<<eLen)-1,eBias=eMax>>1,rt=23===mLen?Math.pow(2,-24)-Math.pow(2,-77):0,i=isLE?0:nBytes-1,d=isLE?1:-1,s=value<0||0===value&&1/value<0?1:0;for(value=Math.abs(value),isNaN(value)||value===1/0?(m=isNaN(value)?1:0,e=eMax):(e=Math.floor(Math.log(value)/Math.LN2),value*(c=Math.pow(2,-e))<1&&(e--,c*=2),2<=(value+=1<=e+eBias?rt/c:rt*Math.pow(2,1-eBias))*c&&(e++,c/=2),eMax<=e+eBias?(m=0,e=eMax):1<=e+eBias?(m=(value*c-1)*Math.pow(2,mLen),e+=eBias):(m=value*Math.pow(2,eBias-1)*Math.pow(2,mLen),e=0));8<=mLen;buffer[offset+i]=255&m,i+=d,m/=256,mLen-=8);for(e=e<<mLen|m,eLen+=mLen;0<eLen;buffer[offset+i]=255&e,i+=d,e/=256,eLen-=8);buffer[offset+i-d]|=128*s}},{}],22:[function(require,module,exports){"function"==typeof Object.create?module.exports=function(ctor,superCtor){ctor.super_=superCtor,ctor.prototype=Object.create(superCtor.prototype,{constructor:{value:ctor,enumerable:!1,writable:!0,configurable:!0}})}:module.exports=function(ctor,superCtor){ctor.super_=superCtor;var TempCtor=function(){};TempCtor.prototype=superCtor.prototype,ctor.prototype=new TempCtor,ctor.prototype.constructor=ctor}},{}],23:[function(require,module,exports){function isBuffer(obj){return!!obj.constructor&&"function"==typeof obj.constructor.isBuffer&&obj.constructor.isBuffer(obj)}module.exports=function(obj){return null!=obj&&(isBuffer(obj)||function(obj){return"function"==typeof obj.readFloatLE&&"function"==typeof obj.slice&&isBuffer(obj.slice(0,0))}(obj)||!!obj._isBuffer)}},{}],24:[function(require,module,exports){var toString={}.toString;module.exports=Array.isArray||function(arr){return"[object Array]"==toString.call(arr)}},{}],25:[function(require,module,exports){(function(process){"use strict";!process.version||0===process.version.indexOf("v0.")||0===process.version.indexOf("v1.")&&0!==process.version.indexOf("v1.8.")?module.exports=function(fn,arg1,arg2,arg3){if("function"!=typeof fn)throw new TypeError('"callback" argument must be a function');var args,i,len=arguments.length;switch(len){case 0:case 1:return process.nextTick(fn);case 2:return process.nextTick(function(){fn.call(null,arg1)});case 3:return process.nextTick(function(){fn.call(null,arg1,arg2)});case 4:return process.nextTick(function(){fn.call(null,arg1,arg2,arg3)});default:for(args=new Array(len-1),i=0;i<args.length;)args[i++]=arguments[i];return process.nextTick(function(){fn.apply(null,args)})}}:module.exports=process.nextTick}).call(this,require("_process"))},{_process:26}],26:[function(require,module,exports){var cachedSetTimeout,cachedClearTimeout,process=module.exports={};function defaultSetTimout(){throw new Error("setTimeout has not been defined")}function defaultClearTimeout(){throw new Error("clearTimeout has not been defined")}function runTimeout(fun){if(cachedSetTimeout===setTimeout)return setTimeout(fun,0);if((cachedSetTimeout===defaultSetTimout||!cachedSetTimeout)&&setTimeout)return cachedSetTimeout=setTimeout,setTimeout(fun,0);try{return cachedSetTimeout(fun,0)}catch(e){try{return cachedSetTimeout.call(null,fun,0)}catch(e){return cachedSetTimeout.call(this,fun,0)}}}!function(){try{cachedSetTimeout="function"==typeof setTimeout?setTimeout:defaultSetTimout}catch(e){cachedSetTimeout=defaultSetTimout}try{cachedClearTimeout="function"==typeof clearTimeout?clearTimeout:defaultClearTimeout}catch(e){cachedClearTimeout=defaultClearTimeout}}();var currentQueue,queue=[],draining=!1,queueIndex=-1;function cleanUpNextTick(){draining&&currentQueue&&(draining=!1,currentQueue.length?queue=currentQueue.concat(queue):queueIndex=-1,queue.length&&drainQueue())}function drainQueue(){if(!draining){var timeout=runTimeout(cleanUpNextTick);draining=!0;for(var len=queue.length;len;){for(currentQueue=queue,queue=[];++queueIndex<len;)currentQueue&&currentQueue[queueIndex].run();queueIndex=-1,len=queue.length}currentQueue=null,draining=!1,function(marker){if(cachedClearTimeout===clearTimeout)return clearTimeout(marker);if((cachedClearTimeout===defaultClearTimeout||!cachedClearTimeout)&&clearTimeout)return cachedClearTimeout=clearTimeout,clearTimeout(marker);try{cachedClearTimeout(marker)}catch(e){try{return cachedClearTimeout.call(null,marker)}catch(e){return cachedClearTimeout.call(this,marker)}}}(timeout)}}function Item(fun,array){this.fun=fun,this.array=array}function noop(){}process.nextTick=function(fun){var args=new Array(arguments.length-1);if(1<arguments.length)for(var i=1;i<arguments.length;i++)args[i-1]=arguments[i];queue.push(new Item(fun,args)),1!==queue.length||draining||runTimeout(drainQueue)},Item.prototype.run=function(){this.fun.apply(null,this.array)},process.title="browser",process.browser=!0,process.env={},process.argv=[],process.version="",process.versions={},process.on=noop,process.addListener=noop,process.once=noop,process.off=noop,process.removeListener=noop,process.removeAllListeners=noop,process.emit=noop,process.prependListener=noop,process.prependOnceListener=noop,process.listeners=function(name){return[]},process.binding=function(name){throw new Error("process.binding is not supported")},process.cwd=function(){return"/"},process.chdir=function(dir){throw new Error("process.chdir is not supported")},process.umask=function(){return 0}},{}],27:[function(require,module,exports){module.exports=require("./lib/_stream_duplex.js")},{"./lib/_stream_duplex.js":28}],28:[function(require,module,exports){"use strict";var processNextTick=require("process-nextick-args"),objectKeys=Object.keys||function(obj){var keys=[];for(var key in obj)keys.push(key);return keys};module.exports=Duplex;var util=require("core-util-is");util.inherits=require("inherits");var Readable=require("./_stream_readable"),Writable=require("./_stream_writable");util.inherits(Duplex,Readable);for(var keys=objectKeys(Writable.prototype),v=0;v<keys.length;v++){var method=keys[v];Duplex.prototype[method]||(Duplex.prototype[method]=Writable.prototype[method])}function Duplex(options){if(!(this instanceof Duplex))return new Duplex(options);Readable.call(this,options),Writable.call(this,options),options&&!1===options.readable&&(this.readable=!1),options&&!1===options.writable&&(this.writable=!1),this.allowHalfOpen=!0,options&&!1===options.allowHalfOpen&&(this.allowHalfOpen=!1),this.once("end",onend)}function onend(){this.allowHalfOpen||this._writableState.ended||processNextTick(onEndNT,this)}function onEndNT(self){self.end()}Object.defineProperty(Duplex.prototype,"destroyed",{get:function(){return void 0!==this._readableState&&void 0!==this._writableState&&(this._readableState.destroyed&&this._writableState.destroyed)},set:function(value){void 0!==this._readableState&&void 0!==this._writableState&&(this._readableState.destroyed=value,this._writableState.destroyed=value)}}),Duplex.prototype._destroy=function(err,cb){this.push(null),this.end(),processNextTick(cb,err)}},{"./_stream_readable":30,"./_stream_writable":32,"core-util-is":15,inherits:22,"process-nextick-args":25}],29:[function(require,module,exports){"use strict";module.exports=PassThrough;var Transform=require("./_stream_transform"),util=require("core-util-is");function PassThrough(options){if(!(this instanceof PassThrough))return new PassThrough(options);Transform.call(this,options)}util.inherits=require("inherits"),util.inherits(PassThrough,Transform),PassThrough.prototype._transform=function(chunk,encoding,cb){cb(null,chunk)}},{"./_stream_transform":31,"core-util-is":15,inherits:22}],30:[function(require,module,exports){(function(process,global){"use strict";var processNextTick=require("process-nextick-args");module.exports=Readable;var Duplex,isArray=require("isarray");Readable.ReadableState=ReadableState;require("events").EventEmitter;var EElistenerCount=function(emitter,type){return emitter.listeners(type).length},Stream=require("./internal/streams/stream"),Buffer=require("safe-buffer").Buffer,OurUint8Array=global.Uint8Array||function(){};var util=require("core-util-is");util.inherits=require("inherits");var debugUtil=require("util"),debug=void 0;debug=debugUtil&&debugUtil.debuglog?debugUtil.debuglog("stream"):function(){};var StringDecoder,BufferList=require("./internal/streams/BufferList"),destroyImpl=require("./internal/streams/destroy");util.inherits(Readable,Stream);var kProxyEvents=["error","close","destroy","pause","resume"];function ReadableState(options,stream){Duplex=Duplex||require("./_stream_duplex"),options=options||{},this.objectMode=!!options.objectMode,stream instanceof Duplex&&(this.objectMode=this.objectMode||!!options.readableObjectMode);var hwm=options.highWaterMark,defaultHwm=this.objectMode?16:16384;this.highWaterMark=hwm||0===hwm?hwm:defaultHwm,this.highWaterMark=Math.floor(this.highWaterMark),this.buffer=new BufferList,this.length=0,this.pipes=null,this.pipesCount=0,this.flowing=null,this.ended=!1,this.endEmitted=!1,this.reading=!1,this.sync=!0,this.needReadable=!1,this.emittedReadable=!1,this.readableListening=!1,this.resumeScheduled=!1,this.destroyed=!1,this.defaultEncoding=options.defaultEncoding||"utf8",this.awaitDrain=0,this.readingMore=!1,this.decoder=null,this.encoding=null,options.encoding&&(StringDecoder||(StringDecoder=require("string_decoder/").StringDecoder),this.decoder=new StringDecoder(options.encoding),this.encoding=options.encoding)}function Readable(options){if(Duplex=Duplex||require("./_stream_duplex"),!(this instanceof Readable))return new Readable(options);this._readableState=new ReadableState(options,this),this.readable=!0,options&&("function"==typeof options.read&&(this._read=options.read),"function"==typeof options.destroy&&(this._destroy=options.destroy)),Stream.call(this)}function readableAddChunk(stream,chunk,encoding,addToFront,skipChunkCheck){var er,state=stream._readableState;null===chunk?(state.reading=!1,function(stream,state){if(state.ended)return;if(state.decoder){var chunk=state.decoder.end();chunk&&chunk.length&&(state.buffer.push(chunk),state.length+=state.objectMode?1:chunk.length)}state.ended=!0,emitReadable(stream)}(stream,state)):(skipChunkCheck||(er=function(state,chunk){var er;obj=chunk,Buffer.isBuffer(obj)||obj instanceof OurUint8Array||"string"==typeof chunk||void 0===chunk||state.objectMode||(er=new TypeError("Invalid non-string/buffer chunk"));var obj;return er}(state,chunk)),er?stream.emit("error",er):state.objectMode||chunk&&0<chunk.length?("string"==typeof chunk||state.objectMode||Object.getPrototypeOf(chunk)===Buffer.prototype||(chunk=function(chunk){return Buffer.from(chunk)}(chunk)),addToFront?state.endEmitted?stream.emit("error",new Error("stream.unshift() after end event")):addChunk(stream,state,chunk,!0):state.ended?stream.emit("error",new Error("stream.push() after EOF")):(state.reading=!1,state.decoder&&!encoding?(chunk=state.decoder.write(chunk),state.objectMode||0!==chunk.length?addChunk(stream,state,chunk,!1):maybeReadMore(stream,state)):addChunk(stream,state,chunk,!1))):addToFront||(state.reading=!1));return function(state){return!state.ended&&(state.needReadable||state.length<state.highWaterMark||0===state.length)}(state)}function addChunk(stream,state,chunk,addToFront){state.flowing&&0===state.length&&!state.sync?(stream.emit("data",chunk),stream.read(0)):(state.length+=state.objectMode?1:chunk.length,addToFront?state.buffer.unshift(chunk):state.buffer.push(chunk),state.needReadable&&emitReadable(stream)),maybeReadMore(stream,state)}Object.defineProperty(Readable.prototype,"destroyed",{get:function(){return void 0!==this._readableState&&this._readableState.destroyed},set:function(value){this._readableState&&(this._readableState.destroyed=value)}}),Readable.prototype.destroy=destroyImpl.destroy,Readable.prototype._undestroy=destroyImpl.undestroy,Readable.prototype._destroy=function(err,cb){this.push(null),cb(err)},Readable.prototype.push=function(chunk,encoding){var skipChunkCheck,state=this._readableState;return state.objectMode?skipChunkCheck=!0:"string"==typeof chunk&&((encoding=encoding||state.defaultEncoding)!==state.encoding&&(chunk=Buffer.from(chunk,encoding),encoding=""),skipChunkCheck=!0),readableAddChunk(this,chunk,encoding,!1,skipChunkCheck)},Readable.prototype.unshift=function(chunk){return readableAddChunk(this,chunk,null,!0,!1)},Readable.prototype.isPaused=function(){return!1===this._readableState.flowing},Readable.prototype.setEncoding=function(enc){return StringDecoder||(StringDecoder=require("string_decoder/").StringDecoder),this._readableState.decoder=new StringDecoder(enc),this._readableState.encoding=enc,this};var MAX_HWM=8388608;function howMuchToRead(n,state){return n<=0||0===state.length&&state.ended?0:state.objectMode?1:n!=n?state.flowing&&state.length?state.buffer.head.data.length:state.length:(n>state.highWaterMark&&(state.highWaterMark=function(n){return MAX_HWM<=n?n=MAX_HWM:(n--,n|=n>>>1,n|=n>>>2,n|=n>>>4,n|=n>>>8,n|=n>>>16,n++),n}(n)),n<=state.length?n:state.ended?state.length:(state.needReadable=!0,0))}function emitReadable(stream){var state=stream._readableState;state.needReadable=!1,state.emittedReadable||(debug("emitReadable",state.flowing),state.emittedReadable=!0,state.sync?processNextTick(emitReadable_,stream):emitReadable_(stream))}function emitReadable_(stream){debug("emit readable"),stream.emit("readable"),flow(stream)}function maybeReadMore(stream,state){state.readingMore||(state.readingMore=!0,processNextTick(maybeReadMore_,stream,state))}function maybeReadMore_(stream,state){for(var len=state.length;!state.reading&&!state.flowing&&!state.ended&&state.length<state.highWaterMark&&(debug("maybeReadMore read 0"),stream.read(0),len!==state.length);)len=state.length;state.readingMore=!1}function nReadingNextTick(self){debug("readable nexttick read 0"),self.read(0)}function resume_(stream,state){state.reading||(debug("resume read 0"),stream.read(0)),state.resumeScheduled=!1,state.awaitDrain=0,stream.emit("resume"),flow(stream),state.flowing&&!state.reading&&stream.read(0)}function flow(stream){var state=stream._readableState;for(debug("flow",state.flowing);state.flowing&&null!==stream.read(););}function fromList(n,state){return 0===state.length?null:(state.objectMode?ret=state.buffer.shift():!n||n>=state.length?(ret=state.decoder?state.buffer.join(""):1===state.buffer.length?state.buffer.head.data:state.buffer.concat(state.length),state.buffer.clear()):ret=function(n,list,hasStrings){var ret;n<list.head.data.length?(ret=list.head.data.slice(0,n),list.head.data=list.head.data.slice(n)):ret=n===list.head.data.length?list.shift():hasStrings?function(n,list){var p=list.head,c=1,ret=p.data;n-=ret.length;for(;p=p.next;){var str=p.data,nb=n>str.length?str.length:n;if(nb===str.length?ret+=str:ret+=str.slice(0,n),0===(n-=nb)){nb===str.length?(++c,p.next?list.head=p.next:list.head=list.tail=null):(list.head=p).data=str.slice(nb);break}++c}return list.length-=c,ret}(n,list):function(n,list){var ret=Buffer.allocUnsafe(n),p=list.head,c=1;p.data.copy(ret),n-=p.data.length;for(;p=p.next;){var buf=p.data,nb=n>buf.length?buf.length:n;if(buf.copy(ret,ret.length-n,0,nb),0===(n-=nb)){nb===buf.length?(++c,p.next?list.head=p.next:list.head=list.tail=null):(list.head=p).data=buf.slice(nb);break}++c}return list.length-=c,ret}(n,list);return ret}(n,state.buffer,state.decoder),ret);var ret}function endReadable(stream){var state=stream._readableState;if(0<state.length)throw new Error('"endReadable()" called on non-empty stream');state.endEmitted||(state.ended=!0,processNextTick(endReadableNT,state,stream))}function endReadableNT(state,stream){state.endEmitted||0!==state.length||(state.endEmitted=!0,stream.readable=!1,stream.emit("end"))}function indexOf(xs,x){for(var i=0,l=xs.length;i<l;i++)if(xs[i]===x)return i;return-1}Readable.prototype.read=function(n){debug("read",n),n=parseInt(n,10);var state=this._readableState,nOrig=n;if(0!==n&&(state.emittedReadable=!1),0===n&&state.needReadable&&(state.length>=state.highWaterMark||state.ended))return debug("read: emitReadable",state.length,state.ended),0===state.length&&state.ended?endReadable(this):emitReadable(this),null;if(0===(n=howMuchToRead(n,state))&&state.ended)return 0===state.length&&endReadable(this),null;var ret,doRead=state.needReadable;return debug("need readable",doRead),(0===state.length||state.length-n<state.highWaterMark)&&debug("length less than watermark",doRead=!0),state.ended||state.reading?debug("reading or ended",doRead=!1):doRead&&(debug("do read"),state.reading=!0,state.sync=!0,0===state.length&&(state.needReadable=!0),this._read(state.highWaterMark),state.sync=!1,state.reading||(n=howMuchToRead(nOrig,state))),null===(ret=0<n?fromList(n,state):null)?(state.needReadable=!0,n=0):state.length-=n,0===state.length&&(state.ended||(state.needReadable=!0),nOrig!==n&&state.ended&&endReadable(this)),null!==ret&&this.emit("data",ret),ret},Readable.prototype._read=function(n){this.emit("error",new Error("_read() is not implemented"))},Readable.prototype.pipe=function(dest,pipeOpts){var src=this,state=this._readableState;switch(state.pipesCount){case 0:state.pipes=dest;break;case 1:state.pipes=[state.pipes,dest];break;default:state.pipes.push(dest)}state.pipesCount+=1,debug("pipe count=%d opts=%j",state.pipesCount,pipeOpts);var endFn=(!pipeOpts||!1!==pipeOpts.end)&&dest!==process.stdout&&dest!==process.stderr?onend:unpipe;function onunpipe(readable,unpipeInfo){debug("onunpipe"),readable===src&&unpipeInfo&&!1===unpipeInfo.hasUnpiped&&(unpipeInfo.hasUnpiped=!0,debug("cleanup"),dest.removeListener("close",onclose),dest.removeListener("finish",onfinish),dest.removeListener("drain",ondrain),dest.removeListener("error",onerror),dest.removeListener("unpipe",onunpipe),src.removeListener("end",onend),src.removeListener("end",unpipe),src.removeListener("data",ondata),cleanedUp=!0,!state.awaitDrain||dest._writableState&&!dest._writableState.needDrain||ondrain())}function onend(){debug("onend"),dest.end()}state.endEmitted?processNextTick(endFn):src.once("end",endFn),dest.on("unpipe",onunpipe);var ondrain=function(src){return function(){var state=src._readableState;debug("pipeOnDrain",state.awaitDrain),state.awaitDrain&&state.awaitDrain--,0===state.awaitDrain&&EElistenerCount(src,"data")&&(state.flowing=!0,flow(src))}}(src);dest.on("drain",ondrain);var cleanedUp=!1;var increasedAwaitDrain=!1;function ondata(chunk){debug("ondata"),(increasedAwaitDrain=!1)!==dest.write(chunk)||increasedAwaitDrain||((1===state.pipesCount&&state.pipes===dest||1<state.pipesCount&&-1!==indexOf(state.pipes,dest))&&!cleanedUp&&(debug("false write response, pause",src._readableState.awaitDrain),src._readableState.awaitDrain++,increasedAwaitDrain=!0),src.pause())}function onerror(er){debug("onerror",er),unpipe(),dest.removeListener("error",onerror),0===EElistenerCount(dest,"error")&&dest.emit("error",er)}function onclose(){dest.removeListener("finish",onfinish),unpipe()}function onfinish(){debug("onfinish"),dest.removeListener("close",onclose),unpipe()}function unpipe(){debug("unpipe"),src.unpipe(dest)}return src.on("data",ondata),function(emitter,event,fn){if("function"==typeof emitter.prependListener)return emitter.prependListener(event,fn);emitter._events&&emitter._events[event]?isArray(emitter._events[event])?emitter._events[event].unshift(fn):emitter._events[event]=[fn,emitter._events[event]]:emitter.on(event,fn)}(dest,"error",onerror),dest.once("close",onclose),dest.once("finish",onfinish),dest.emit("pipe",src),state.flowing||(debug("pipe resume"),src.resume()),dest},Readable.prototype.unpipe=function(dest){var state=this._readableState,unpipeInfo={hasUnpiped:!1};if(0===state.pipesCount)return this;if(1===state.pipesCount)return dest&&dest!==state.pipes||(dest||(dest=state.pipes),state.pipes=null,state.pipesCount=0,state.flowing=!1,dest&&dest.emit("unpipe",this,unpipeInfo)),this;if(!dest){var dests=state.pipes,len=state.pipesCount;state.pipes=null,state.pipesCount=0,state.flowing=!1;for(var i=0;i<len;i++)dests[i].emit("unpipe",this,unpipeInfo);return this}var index=indexOf(state.pipes,dest);return-1===index||(state.pipes.splice(index,1),state.pipesCount-=1,1===state.pipesCount&&(state.pipes=state.pipes[0]),dest.emit("unpipe",this,unpipeInfo)),this},Readable.prototype.addListener=Readable.prototype.on=function(ev,fn){var res=Stream.prototype.on.call(this,ev,fn);if("data"===ev)!1!==this._readableState.flowing&&this.resume();else if("readable"===ev){var state=this._readableState;state.endEmitted||state.readableListening||(state.readableListening=state.needReadable=!0,state.emittedReadable=!1,state.reading?state.length&&emitReadable(this):processNextTick(nReadingNextTick,this))}return res},Readable.prototype.resume=function(){var state=this._readableState;return state.flowing||(debug("resume"),state.flowing=!0,function(stream,state){state.resumeScheduled||(state.resumeScheduled=!0,processNextTick(resume_,stream,state))}(this,state)),this},Readable.prototype.pause=function(){return debug("call pause flowing=%j",this._readableState.flowing),!1!==this._readableState.flowing&&(debug("pause"),this._readableState.flowing=!1,this.emit("pause")),this},Readable.prototype.wrap=function(stream){var state=this._readableState,paused=!1,self=this;for(var i in stream.on("end",function(){if(debug("wrapped end"),state.decoder&&!state.ended){var chunk=state.decoder.end();chunk&&chunk.length&&self.push(chunk)}self.push(null)}),stream.on("data",function(chunk){(debug("wrapped data"),state.decoder&&(chunk=state.decoder.write(chunk)),state.objectMode&&null==chunk)||(state.objectMode||chunk&&chunk.length)&&(self.push(chunk)||(paused=!0,stream.pause()))}),stream)void 0===this[i]&&"function"==typeof stream[i]&&(this[i]=function(method){return function(){return stream[method].apply(stream,arguments)}}(i));for(var n=0;n<kProxyEvents.length;n++)stream.on(kProxyEvents[n],self.emit.bind(self,kProxyEvents[n]));return self._read=function(n){debug("wrapped _read",n),paused&&(paused=!1,stream.resume())},self},Readable._fromList=fromList}).call(this,require("_process"),"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"./_stream_duplex":28,"./internal/streams/BufferList":33,"./internal/streams/destroy":34,"./internal/streams/stream":35,_process:26,"core-util-is":15,events:19,inherits:22,isarray:24,"process-nextick-args":25,"safe-buffer":41,"string_decoder/":51,util:4}],31:[function(require,module,exports){"use strict";module.exports=Transform;var Duplex=require("./_stream_duplex"),util=require("core-util-is");function TransformState(stream){this.afterTransform=function(er,data){return function(stream,er,data){var ts=stream._transformState;ts.transforming=!1;var cb=ts.writecb;if(!cb)return stream.emit("error",new Error("write callback called multiple times"));ts.writechunk=null,(ts.writecb=null)!=data&&stream.push(data);cb(er);var rs=stream._readableState;rs.reading=!1,(rs.needReadable||rs.length<rs.highWaterMark)&&stream._read(rs.highWaterMark)}(stream,er,data)},this.needTransform=!1,this.transforming=!1,this.writecb=null,this.writechunk=null,this.writeencoding=null}function Transform(options){if(!(this instanceof Transform))return new Transform(options);Duplex.call(this,options),this._transformState=new TransformState(this);var stream=this;this._readableState.needReadable=!0,this._readableState.sync=!1,options&&("function"==typeof options.transform&&(this._transform=options.transform),"function"==typeof options.flush&&(this._flush=options.flush)),this.once("prefinish",function(){"function"==typeof this._flush?this._flush(function(er,data){done(stream,er,data)}):done(stream)})}function done(stream,er,data){if(er)return stream.emit("error",er);null!=data&&stream.push(data);var ws=stream._writableState,ts=stream._transformState;if(ws.length)throw new Error("Calling transform done when ws.length != 0");if(ts.transforming)throw new Error("Calling transform done when still transforming");return stream.push(null)}util.inherits=require("inherits"),util.inherits(Transform,Duplex),Transform.prototype.push=function(chunk,encoding){return this._transformState.needTransform=!1,Duplex.prototype.push.call(this,chunk,encoding)},Transform.prototype._transform=function(chunk,encoding,cb){throw new Error("_transform() is not implemented")},Transform.prototype._write=function(chunk,encoding,cb){var ts=this._transformState;if(ts.writecb=cb,ts.writechunk=chunk,ts.writeencoding=encoding,!ts.transforming){var rs=this._readableState;(ts.needTransform||rs.needReadable||rs.length<rs.highWaterMark)&&this._read(rs.highWaterMark)}},Transform.prototype._read=function(n){var ts=this._transformState;null!==ts.writechunk&&ts.writecb&&!ts.transforming?(ts.transforming=!0,this._transform(ts.writechunk,ts.writeencoding,ts.afterTransform)):ts.needTransform=!0},Transform.prototype._destroy=function(err,cb){var _this=this;Duplex.prototype._destroy.call(this,err,function(err2){cb(err2),_this.emit("close")})}},{"./_stream_duplex":28,"core-util-is":15,inherits:22}],32:[function(require,module,exports){(function(process,global){"use strict";var processNextTick=require("process-nextick-args");function CorkedRequest(state){var _this=this;this.next=null,this.entry=null,this.finish=function(){!function(corkReq,state,err){var entry=corkReq.entry;corkReq.entry=null;for(;entry;){var cb=entry.callback;state.pendingcb--,cb(err),entry=entry.next}state.corkedRequestsFree?state.corkedRequestsFree.next=corkReq:state.corkedRequestsFree=corkReq}(_this,state)}}module.exports=Writable;var Duplex,asyncWrite=!process.browser&&-1<["v0.10","v0.9."].indexOf(process.version.slice(0,5))?setImmediate:processNextTick;Writable.WritableState=WritableState;var util=require("core-util-is");util.inherits=require("inherits");var internalUtil={deprecate:require("util-deprecate")},Stream=require("./internal/streams/stream"),Buffer=require("safe-buffer").Buffer,OurUint8Array=global.Uint8Array||function(){};var realHasInstance,destroyImpl=require("./internal/streams/destroy");function nop(){}function WritableState(options,stream){Duplex=Duplex||require("./_stream_duplex"),options=options||{},this.objectMode=!!options.objectMode,stream instanceof Duplex&&(this.objectMode=this.objectMode||!!options.writableObjectMode);var hwm=options.highWaterMark,defaultHwm=this.objectMode?16:16384;this.highWaterMark=hwm||0===hwm?hwm:defaultHwm,this.highWaterMark=Math.floor(this.highWaterMark),this.finalCalled=!1,this.needDrain=!1,this.ending=!1,this.ended=!1,this.finished=!1;var noDecode=(this.destroyed=!1)===options.decodeStrings;this.decodeStrings=!noDecode,this.defaultEncoding=options.defaultEncoding||"utf8",this.length=0,this.writing=!1,this.corked=0,this.sync=!0,this.bufferProcessing=!1,this.onwrite=function(er){!function(stream,er){var state=stream._writableState,sync=state.sync,cb=state.writecb;if(function(state){state.writing=!1,state.writecb=null,state.length-=state.writelen,state.writelen=0}(state),er)!function(stream,state,sync,er,cb){--state.pendingcb,sync?(processNextTick(cb,er),processNextTick(finishMaybe,stream,state),stream._writableState.errorEmitted=!0,stream.emit("error",er)):(cb(er),stream._writableState.errorEmitted=!0,stream.emit("error",er),finishMaybe(stream,state))}(stream,state,sync,er,cb);else{var finished=needFinish(state);finished||state.corked||state.bufferProcessing||!state.bufferedRequest||clearBuffer(stream,state),sync?asyncWrite(afterWrite,stream,state,finished,cb):afterWrite(stream,state,finished,cb)}}(stream,er)},this.writecb=null,this.writelen=0,this.bufferedRequest=null,this.lastBufferedRequest=null,this.pendingcb=0,this.prefinished=!1,this.errorEmitted=!1,this.bufferedRequestCount=0,this.corkedRequestsFree=new CorkedRequest(this)}function Writable(options){if(Duplex=Duplex||require("./_stream_duplex"),!(realHasInstance.call(Writable,this)||this instanceof Duplex))return new Writable(options);this._writableState=new WritableState(options,this),this.writable=!0,options&&("function"==typeof options.write&&(this._write=options.write),"function"==typeof options.writev&&(this._writev=options.writev),"function"==typeof options.destroy&&(this._destroy=options.destroy),"function"==typeof options.final&&(this._final=options.final)),Stream.call(this)}function doWrite(stream,state,writev,len,chunk,encoding,cb){state.writelen=len,state.writecb=cb,state.writing=!0,state.sync=!0,writev?stream._writev(chunk,state.onwrite):stream._write(chunk,encoding,state.onwrite),state.sync=!1}function afterWrite(stream,state,finished,cb){finished||function(stream,state){0===state.length&&state.needDrain&&(state.needDrain=!1,stream.emit("drain"))}(stream,state),state.pendingcb--,cb(),finishMaybe(stream,state)}function clearBuffer(stream,state){state.bufferProcessing=!0;var entry=state.bufferedRequest;if(stream._writev&&entry&&entry.next){var l=state.bufferedRequestCount,buffer=new Array(l),holder=state.corkedRequestsFree;holder.entry=entry;for(var count=0,allBuffers=!0;entry;)(buffer[count]=entry).isBuf||(allBuffers=!1),entry=entry.next,count+=1;buffer.allBuffers=allBuffers,doWrite(stream,state,!0,state.length,buffer,"",holder.finish),state.pendingcb++,state.lastBufferedRequest=null,holder.next?(state.corkedRequestsFree=holder.next,holder.next=null):state.corkedRequestsFree=new CorkedRequest(state)}else{for(;entry;){var chunk=entry.chunk,encoding=entry.encoding,cb=entry.callback;if(doWrite(stream,state,!1,state.objectMode?1:chunk.length,chunk,encoding,cb),entry=entry.next,state.writing)break}null===entry&&(state.lastBufferedRequest=null)}state.bufferedRequestCount=0,state.bufferedRequest=entry,state.bufferProcessing=!1}function needFinish(state){return state.ending&&0===state.length&&null===state.bufferedRequest&&!state.finished&&!state.writing}function callFinal(stream,state){stream._final(function(err){state.pendingcb--,err&&stream.emit("error",err),state.prefinished=!0,stream.emit("prefinish"),finishMaybe(stream,state)})}function finishMaybe(stream,state){var need=needFinish(state);return need&&(!function(stream,state){state.prefinished||state.finalCalled||("function"==typeof stream._final?(state.pendingcb++,state.finalCalled=!0,processNextTick(callFinal,stream,state)):(state.prefinished=!0,stream.emit("prefinish")))}(stream,state),0===state.pendingcb&&(state.finished=!0,stream.emit("finish"))),need}util.inherits(Writable,Stream),WritableState.prototype.getBuffer=function(){for(var current=this.bufferedRequest,out=[];current;)out.push(current),current=current.next;return out},function(){try{Object.defineProperty(WritableState.prototype,"buffer",{get:internalUtil.deprecate(function(){return this.getBuffer()},"_writableState.buffer is deprecated. Use _writableState.getBuffer instead.","DEP0003")})}catch(_){}}(),"function"==typeof Symbol&&Symbol.hasInstance&&"function"==typeof Function.prototype[Symbol.hasInstance]?(realHasInstance=Function.prototype[Symbol.hasInstance],Object.defineProperty(Writable,Symbol.hasInstance,{value:function(object){return!!realHasInstance.call(this,object)||object&&object._writableState instanceof WritableState}})):realHasInstance=function(object){return object instanceof this},Writable.prototype.pipe=function(){this.emit("error",new Error("Cannot pipe, not readable"))},Writable.prototype.write=function(chunk,encoding,cb){var obj,state=this._writableState,ret=!1,isBuf=(obj=chunk,(Buffer.isBuffer(obj)||obj instanceof OurUint8Array)&&!state.objectMode);return isBuf&&!Buffer.isBuffer(chunk)&&(chunk=function(chunk){return Buffer.from(chunk)}(chunk)),"function"==typeof encoding&&(cb=encoding,encoding=null),isBuf?encoding="buffer":encoding||(encoding=state.defaultEncoding),"function"!=typeof cb&&(cb=nop),state.ended?function(stream,cb){var er=new Error("write after end");stream.emit("error",er),processNextTick(cb,er)}(this,cb):(isBuf||function(stream,state,chunk,cb){var valid=!0,er=!1;return null===chunk?er=new TypeError("May not write null values to stream"):"string"==typeof chunk||void 0===chunk||state.objectMode||(er=new TypeError("Invalid non-string/buffer chunk")),er&&(stream.emit("error",er),processNextTick(cb,er),valid=!1),valid}(this,state,chunk,cb))&&(state.pendingcb++,ret=function(stream,state,isBuf,chunk,encoding,cb){if(!isBuf){var newChunk=function(state,chunk,encoding){state.objectMode||!1===state.decodeStrings||"string"!=typeof chunk||(chunk=Buffer.from(chunk,encoding));return chunk}(state,chunk,encoding);chunk!==newChunk&&(isBuf=!0,encoding="buffer",chunk=newChunk)}var len=state.objectMode?1:chunk.length;state.length+=len;var ret=state.length<state.highWaterMark;ret||(state.needDrain=!0);if(state.writing||state.corked){var last=state.lastBufferedRequest;state.lastBufferedRequest={chunk:chunk,encoding:encoding,isBuf:isBuf,callback:cb,next:null},last?last.next=state.lastBufferedRequest:state.bufferedRequest=state.lastBufferedRequest,state.bufferedRequestCount+=1}else doWrite(stream,state,!1,len,chunk,encoding,cb);return ret}(this,state,isBuf,chunk,encoding,cb)),ret},Writable.prototype.cork=function(){this._writableState.corked++},Writable.prototype.uncork=function(){var state=this._writableState;state.corked&&(state.corked--,state.writing||state.corked||state.finished||state.bufferProcessing||!state.bufferedRequest||clearBuffer(this,state))},Writable.prototype.setDefaultEncoding=function(encoding){if("string"==typeof encoding&&(encoding=encoding.toLowerCase()),!(-1<["hex","utf8","utf-8","ascii","binary","base64","ucs2","ucs-2","utf16le","utf-16le","raw"].indexOf((encoding+"").toLowerCase())))throw new TypeError("Unknown encoding: "+encoding);return this._writableState.defaultEncoding=encoding,this},Writable.prototype._write=function(chunk,encoding,cb){cb(new Error("_write() is not implemented"))},Writable.prototype._writev=null,Writable.prototype.end=function(chunk,encoding,cb){var state=this._writableState;"function"==typeof chunk?(cb=chunk,encoding=chunk=null):"function"==typeof encoding&&(cb=encoding,encoding=null),null!=chunk&&this.write(chunk,encoding),state.corked&&(state.corked=1,this.uncork()),state.ending||state.finished||function(stream,state,cb){state.ending=!0,finishMaybe(stream,state),cb&&(state.finished?processNextTick(cb):stream.once("finish",cb));state.ended=!0,stream.writable=!1}(this,state,cb)},Object.defineProperty(Writable.prototype,"destroyed",{get:function(){return void 0!==this._writableState&&this._writableState.destroyed},set:function(value){this._writableState&&(this._writableState.destroyed=value)}}),Writable.prototype.destroy=destroyImpl.destroy,Writable.prototype._undestroy=destroyImpl.undestroy,Writable.prototype._destroy=function(err,cb){this.end(),cb(err)}}).call(this,require("_process"),"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"./_stream_duplex":28,"./internal/streams/destroy":34,"./internal/streams/stream":35,_process:26,"core-util-is":15,inherits:22,"process-nextick-args":25,"safe-buffer":41,"util-deprecate":52}],33:[function(require,module,exports){"use strict";var Buffer=require("safe-buffer").Buffer;module.exports=function(){function BufferList(){!function(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}(this,BufferList),this.head=null,this.tail=null,this.length=0}return BufferList.prototype.push=function(v){var entry={data:v,next:null};0<this.length?this.tail.next=entry:this.head=entry,this.tail=entry,++this.length},BufferList.prototype.unshift=function(v){var entry={data:v,next:this.head};0===this.length&&(this.tail=entry),this.head=entry,++this.length},BufferList.prototype.shift=function(){if(0!==this.length){var ret=this.head.data;return 1===this.length?this.head=this.tail=null:this.head=this.head.next,--this.length,ret}},BufferList.prototype.clear=function(){this.head=this.tail=null,this.length=0},BufferList.prototype.join=function(s){if(0===this.length)return"";for(var p=this.head,ret=""+p.data;p=p.next;)ret+=s+p.data;return ret},BufferList.prototype.concat=function(n){if(0===this.length)return Buffer.alloc(0);if(1===this.length)return this.head.data;for(var src,target,offset,ret=Buffer.allocUnsafe(n>>>0),p=this.head,i=0;p;)src=p.data,target=ret,offset=i,src.copy(target,offset),i+=p.data.length,p=p.next;return ret},BufferList}()},{"safe-buffer":41}],34:[function(require,module,exports){"use strict";var processNextTick=require("process-nextick-args");function emitErrorNT(self,err){self.emit("error",err)}module.exports={destroy:function(err,cb){var _this=this,readableDestroyed=this._readableState&&this._readableState.destroyed,writableDestroyed=this._writableState&&this._writableState.destroyed;readableDestroyed||writableDestroyed?cb?cb(err):!err||this._writableState&&this._writableState.errorEmitted||processNextTick(emitErrorNT,this,err):(this._readableState&&(this._readableState.destroyed=!0),this._writableState&&(this._writableState.destroyed=!0),this._destroy(err||null,function(err){!cb&&err?(processNextTick(emitErrorNT,_this,err),_this._writableState&&(_this._writableState.errorEmitted=!0)):cb&&cb(err)}))},undestroy:function(){this._readableState&&(this._readableState.destroyed=!1,this._readableState.reading=!1,this._readableState.ended=!1,this._readableState.endEmitted=!1),this._writableState&&(this._writableState.destroyed=!1,this._writableState.ended=!1,this._writableState.ending=!1,this._writableState.finished=!1,this._writableState.errorEmitted=!1)}}},{"process-nextick-args":25}],35:[function(require,module,exports){module.exports=require("events").EventEmitter},{events:19}],36:[function(require,module,exports){module.exports=require("./readable").PassThrough},{"./readable":37}],37:[function(require,module,exports){(((exports=module.exports=require("./lib/_stream_readable.js")).Stream=exports).Readable=exports).Writable=require("./lib/_stream_writable.js"),exports.Duplex=require("./lib/_stream_duplex.js"),exports.Transform=require("./lib/_stream_transform.js"),exports.PassThrough=require("./lib/_stream_passthrough.js")},{"./lib/_stream_duplex.js":28,"./lib/_stream_passthrough.js":29,"./lib/_stream_readable.js":30,"./lib/_stream_transform.js":31,"./lib/_stream_writable.js":32}],38:[function(require,module,exports){module.exports=require("./readable").Transform},{"./readable":37}],39:[function(require,module,exports){module.exports=require("./lib/_stream_writable.js")},{"./lib/_stream_writable.js":32}],40:[function(require,module,exports){(function(Buffer){"use strict";var inherits=require("inherits"),HashBase=require("hash-base");function RIPEMD160(){HashBase.call(this,64),this._a=1732584193,this._b=4023233417,this._c=2562383102,this._d=271733878,this._e=3285377520}function rotl(x,n){return x<<n|x>>>32-n}function fn1(a,b,c,d,e,m,k,s){return rotl(a+(b^c^d)+m+k|0,s)+e|0}function fn2(a,b,c,d,e,m,k,s){return rotl(a+(b&c|~b&d)+m+k|0,s)+e|0}function fn3(a,b,c,d,e,m,k,s){return rotl(a+((b|~c)^d)+m+k|0,s)+e|0}function fn4(a,b,c,d,e,m,k,s){return rotl(a+(b&d|c&~d)+m+k|0,s)+e|0}function fn5(a,b,c,d,e,m,k,s){return rotl(a+(b^(c|~d))+m+k|0,s)+e|0}inherits(RIPEMD160,HashBase),RIPEMD160.prototype._update=function(){for(var m=new Array(16),i=0;i<16;++i)m[i]=this._block.readInt32LE(4*i);var al=this._a,bl=this._b,cl=this._c,dl=this._d,el=this._e;el=fn1(el,al=fn1(al,bl,cl,dl,el,m[0],0,11),bl,cl=rotl(cl,10),dl,m[1],0,14),bl=fn1(bl=rotl(bl,10),cl=fn1(cl,dl=fn1(dl,el,al,bl,cl,m[2],0,15),el,al=rotl(al,10),bl,m[3],0,12),dl,el=rotl(el,10),al,m[4],0,5),dl=fn1(dl=rotl(dl,10),el=fn1(el,al=fn1(al,bl,cl,dl,el,m[5],0,8),bl,cl=rotl(cl,10),dl,m[6],0,7),al,bl=rotl(bl,10),cl,m[7],0,9),al=fn1(al=rotl(al,10),bl=fn1(bl,cl=fn1(cl,dl,el,al,bl,m[8],0,11),dl,el=rotl(el,10),al,m[9],0,13),cl,dl=rotl(dl,10),el,m[10],0,14),cl=fn1(cl=rotl(cl,10),dl=fn1(dl,el=fn1(el,al,bl,cl,dl,m[11],0,15),al,bl=rotl(bl,10),cl,m[12],0,6),el,al=rotl(al,10),bl,m[13],0,7),el=fn2(el=rotl(el,10),al=fn1(al,bl=fn1(bl,cl,dl,el,al,m[14],0,9),cl,dl=rotl(dl,10),el,m[15],0,8),bl,cl=rotl(cl,10),dl,m[7],1518500249,7),bl=fn2(bl=rotl(bl,10),cl=fn2(cl,dl=fn2(dl,el,al,bl,cl,m[4],1518500249,6),el,al=rotl(al,10),bl,m[13],1518500249,8),dl,el=rotl(el,10),al,m[1],1518500249,13),dl=fn2(dl=rotl(dl,10),el=fn2(el,al=fn2(al,bl,cl,dl,el,m[10],1518500249,11),bl,cl=rotl(cl,10),dl,m[6],1518500249,9),al,bl=rotl(bl,10),cl,m[15],1518500249,7),al=fn2(al=rotl(al,10),bl=fn2(bl,cl=fn2(cl,dl,el,al,bl,m[3],1518500249,15),dl,el=rotl(el,10),al,m[12],1518500249,7),cl,dl=rotl(dl,10),el,m[0],1518500249,12),cl=fn2(cl=rotl(cl,10),dl=fn2(dl,el=fn2(el,al,bl,cl,dl,m[9],1518500249,15),al,bl=rotl(bl,10),cl,m[5],1518500249,9),el,al=rotl(al,10),bl,m[2],1518500249,11),el=fn2(el=rotl(el,10),al=fn2(al,bl=fn2(bl,cl,dl,el,al,m[14],1518500249,7),cl,dl=rotl(dl,10),el,m[11],1518500249,13),bl,cl=rotl(cl,10),dl,m[8],1518500249,12),bl=fn3(bl=rotl(bl,10),cl=fn3(cl,dl=fn3(dl,el,al,bl,cl,m[3],1859775393,11),el,al=rotl(al,10),bl,m[10],1859775393,13),dl,el=rotl(el,10),al,m[14],1859775393,6),dl=fn3(dl=rotl(dl,10),el=fn3(el,al=fn3(al,bl,cl,dl,el,m[4],1859775393,7),bl,cl=rotl(cl,10),dl,m[9],1859775393,14),al,bl=rotl(bl,10),cl,m[15],1859775393,9),al=fn3(al=rotl(al,10),bl=fn3(bl,cl=fn3(cl,dl,el,al,bl,m[8],1859775393,13),dl,el=rotl(el,10),al,m[1],1859775393,15),cl,dl=rotl(dl,10),el,m[2],1859775393,14),cl=fn3(cl=rotl(cl,10),dl=fn3(dl,el=fn3(el,al,bl,cl,dl,m[7],1859775393,8),al,bl=rotl(bl,10),cl,m[0],1859775393,13),el,al=rotl(al,10),bl,m[6],1859775393,6),el=fn3(el=rotl(el,10),al=fn3(al,bl=fn3(bl,cl,dl,el,al,m[13],1859775393,5),cl,dl=rotl(dl,10),el,m[11],1859775393,12),bl,cl=rotl(cl,10),dl,m[5],1859775393,7),bl=fn4(bl=rotl(bl,10),cl=fn4(cl,dl=fn3(dl,el,al,bl,cl,m[12],1859775393,5),el,al=rotl(al,10),bl,m[1],2400959708,11),dl,el=rotl(el,10),al,m[9],2400959708,12),dl=fn4(dl=rotl(dl,10),el=fn4(el,al=fn4(al,bl,cl,dl,el,m[11],2400959708,14),bl,cl=rotl(cl,10),dl,m[10],2400959708,15),al,bl=rotl(bl,10),cl,m[0],2400959708,14),al=fn4(al=rotl(al,10),bl=fn4(bl,cl=fn4(cl,dl,el,al,bl,m[8],2400959708,15),dl,el=rotl(el,10),al,m[12],2400959708,9),cl,dl=rotl(dl,10),el,m[4],2400959708,8),cl=fn4(cl=rotl(cl,10),dl=fn4(dl,el=fn4(el,al,bl,cl,dl,m[13],2400959708,9),al,bl=rotl(bl,10),cl,m[3],2400959708,14),el,al=rotl(al,10),bl,m[7],2400959708,5),el=fn4(el=rotl(el,10),al=fn4(al,bl=fn4(bl,cl,dl,el,al,m[15],2400959708,6),cl,dl=rotl(dl,10),el,m[14],2400959708,8),bl,cl=rotl(cl,10),dl,m[5],2400959708,6),bl=fn5(bl=rotl(bl,10),cl=fn4(cl,dl=fn4(dl,el,al,bl,cl,m[6],2400959708,5),el,al=rotl(al,10),bl,m[2],2400959708,12),dl,el=rotl(el,10),al,m[4],2840853838,9),dl=fn5(dl=rotl(dl,10),el=fn5(el,al=fn5(al,bl,cl,dl,el,m[0],2840853838,15),bl,cl=rotl(cl,10),dl,m[5],2840853838,5),al,bl=rotl(bl,10),cl,m[9],2840853838,11),al=fn5(al=rotl(al,10),bl=fn5(bl,cl=fn5(cl,dl,el,al,bl,m[7],2840853838,6),dl,el=rotl(el,10),al,m[12],2840853838,8),cl,dl=rotl(dl,10),el,m[2],2840853838,13),cl=fn5(cl=rotl(cl,10),dl=fn5(dl,el=fn5(el,al,bl,cl,dl,m[10],2840853838,12),al,bl=rotl(bl,10),cl,m[14],2840853838,5),el,al=rotl(al,10),bl,m[1],2840853838,12),el=fn5(el=rotl(el,10),al=fn5(al,bl=fn5(bl,cl,dl,el,al,m[3],2840853838,13),cl,dl=rotl(dl,10),el,m[8],2840853838,14),bl,cl=rotl(cl,10),dl,m[11],2840853838,11),bl=fn5(bl=rotl(bl,10),cl=fn5(cl,dl=fn5(dl,el,al,bl,cl,m[6],2840853838,8),el,al=rotl(al,10),bl,m[15],2840853838,5),dl,el=rotl(el,10),al,m[13],2840853838,6),dl=rotl(dl,10);var ar=this._a,br=this._b,cr=this._c,dr=this._d,er=this._e;er=fn5(er,ar=fn5(ar,br,cr,dr,er,m[5],1352829926,8),br,cr=rotl(cr,10),dr,m[14],1352829926,9),br=fn5(br=rotl(br,10),cr=fn5(cr,dr=fn5(dr,er,ar,br,cr,m[7],1352829926,9),er,ar=rotl(ar,10),br,m[0],1352829926,11),dr,er=rotl(er,10),ar,m[9],1352829926,13),dr=fn5(dr=rotl(dr,10),er=fn5(er,ar=fn5(ar,br,cr,dr,er,m[2],1352829926,15),br,cr=rotl(cr,10),dr,m[11],1352829926,15),ar,br=rotl(br,10),cr,m[4],1352829926,5),ar=fn5(ar=rotl(ar,10),br=fn5(br,cr=fn5(cr,dr,er,ar,br,m[13],1352829926,7),dr,er=rotl(er,10),ar,m[6],1352829926,7),cr,dr=rotl(dr,10),er,m[15],1352829926,8),cr=fn5(cr=rotl(cr,10),dr=fn5(dr,er=fn5(er,ar,br,cr,dr,m[8],1352829926,11),ar,br=rotl(br,10),cr,m[1],1352829926,14),er,ar=rotl(ar,10),br,m[10],1352829926,14),er=fn4(er=rotl(er,10),ar=fn5(ar,br=fn5(br,cr,dr,er,ar,m[3],1352829926,12),cr,dr=rotl(dr,10),er,m[12],1352829926,6),br,cr=rotl(cr,10),dr,m[6],1548603684,9),br=fn4(br=rotl(br,10),cr=fn4(cr,dr=fn4(dr,er,ar,br,cr,m[11],1548603684,13),er,ar=rotl(ar,10),br,m[3],1548603684,15),dr,er=rotl(er,10),ar,m[7],1548603684,7),dr=fn4(dr=rotl(dr,10),er=fn4(er,ar=fn4(ar,br,cr,dr,er,m[0],1548603684,12),br,cr=rotl(cr,10),dr,m[13],1548603684,8),ar,br=rotl(br,10),cr,m[5],1548603684,9),ar=fn4(ar=rotl(ar,10),br=fn4(br,cr=fn4(cr,dr,er,ar,br,m[10],1548603684,11),dr,er=rotl(er,10),ar,m[14],1548603684,7),cr,dr=rotl(dr,10),er,m[15],1548603684,7),cr=fn4(cr=rotl(cr,10),dr=fn4(dr,er=fn4(er,ar,br,cr,dr,m[8],1548603684,12),ar,br=rotl(br,10),cr,m[12],1548603684,7),er,ar=rotl(ar,10),br,m[4],1548603684,6),er=fn4(er=rotl(er,10),ar=fn4(ar,br=fn4(br,cr,dr,er,ar,m[9],1548603684,15),cr,dr=rotl(dr,10),er,m[1],1548603684,13),br,cr=rotl(cr,10),dr,m[2],1548603684,11),br=fn3(br=rotl(br,10),cr=fn3(cr,dr=fn3(dr,er,ar,br,cr,m[15],1836072691,9),er,ar=rotl(ar,10),br,m[5],1836072691,7),dr,er=rotl(er,10),ar,m[1],1836072691,15),dr=fn3(dr=rotl(dr,10),er=fn3(er,ar=fn3(ar,br,cr,dr,er,m[3],1836072691,11),br,cr=rotl(cr,10),dr,m[7],1836072691,8),ar,br=rotl(br,10),cr,m[14],1836072691,6),ar=fn3(ar=rotl(ar,10),br=fn3(br,cr=fn3(cr,dr,er,ar,br,m[6],1836072691,6),dr,er=rotl(er,10),ar,m[9],1836072691,14),cr,dr=rotl(dr,10),er,m[11],1836072691,12),cr=fn3(cr=rotl(cr,10),dr=fn3(dr,er=fn3(er,ar,br,cr,dr,m[8],1836072691,13),ar,br=rotl(br,10),cr,m[12],1836072691,5),er,ar=rotl(ar,10),br,m[2],1836072691,14),er=fn3(er=rotl(er,10),ar=fn3(ar,br=fn3(br,cr,dr,er,ar,m[10],1836072691,13),cr,dr=rotl(dr,10),er,m[0],1836072691,13),br,cr=rotl(cr,10),dr,m[4],1836072691,7),br=fn2(br=rotl(br,10),cr=fn2(cr,dr=fn3(dr,er,ar,br,cr,m[13],1836072691,5),er,ar=rotl(ar,10),br,m[8],2053994217,15),dr,er=rotl(er,10),ar,m[6],2053994217,5),dr=fn2(dr=rotl(dr,10),er=fn2(er,ar=fn2(ar,br,cr,dr,er,m[4],2053994217,8),br,cr=rotl(cr,10),dr,m[1],2053994217,11),ar,br=rotl(br,10),cr,m[3],2053994217,14),ar=fn2(ar=rotl(ar,10),br=fn2(br,cr=fn2(cr,dr,er,ar,br,m[11],2053994217,14),dr,er=rotl(er,10),ar,m[15],2053994217,6),cr,dr=rotl(dr,10),er,m[0],2053994217,14),cr=fn2(cr=rotl(cr,10),dr=fn2(dr,er=fn2(er,ar,br,cr,dr,m[5],2053994217,6),ar,br=rotl(br,10),cr,m[12],2053994217,9),er,ar=rotl(ar,10),br,m[2],2053994217,12),er=fn2(er=rotl(er,10),ar=fn2(ar,br=fn2(br,cr,dr,er,ar,m[13],2053994217,9),cr,dr=rotl(dr,10),er,m[9],2053994217,12),br,cr=rotl(cr,10),dr,m[7],2053994217,5),br=fn1(br=rotl(br,10),cr=fn2(cr,dr=fn2(dr,er,ar,br,cr,m[10],2053994217,15),er,ar=rotl(ar,10),br,m[14],2053994217,8),dr,er=rotl(er,10),ar,m[12],0,8),dr=fn1(dr=rotl(dr,10),er=fn1(er,ar=fn1(ar,br,cr,dr,er,m[15],0,5),br,cr=rotl(cr,10),dr,m[10],0,12),ar,br=rotl(br,10),cr,m[4],0,9),ar=fn1(ar=rotl(ar,10),br=fn1(br,cr=fn1(cr,dr,er,ar,br,m[1],0,12),dr,er=rotl(er,10),ar,m[5],0,5),cr,dr=rotl(dr,10),er,m[8],0,14),cr=fn1(cr=rotl(cr,10),dr=fn1(dr,er=fn1(er,ar,br,cr,dr,m[7],0,6),ar,br=rotl(br,10),cr,m[6],0,8),er,ar=rotl(ar,10),br,m[2],0,13),er=fn1(er=rotl(er,10),ar=fn1(ar,br=fn1(br,cr,dr,er,ar,m[13],0,6),cr,dr=rotl(dr,10),er,m[14],0,5),br,cr=rotl(cr,10),dr,m[0],0,15),br=fn1(br=rotl(br,10),cr=fn1(cr,dr=fn1(dr,er,ar,br,cr,m[3],0,13),er,ar=rotl(ar,10),br,m[9],0,11),dr,er=rotl(er,10),ar,m[11],0,11),dr=rotl(dr,10);var t=this._b+cl+dr|0;this._b=this._c+dl+er|0,this._c=this._d+el+ar|0,this._d=this._e+al+br|0,this._e=this._a+bl+cr|0,this._a=t},RIPEMD160.prototype._digest=function(){this._block[this._blockOffset++]=128,56<this._blockOffset&&(this._block.fill(0,this._blockOffset,64),this._update(),this._blockOffset=0),this._block.fill(0,this._blockOffset,56),this._block.writeUInt32LE(this._length[0],56),this._block.writeUInt32LE(this._length[1],60),this._update();var buffer=new Buffer(20);return buffer.writeInt32LE(this._a,0),buffer.writeInt32LE(this._b,4),buffer.writeInt32LE(this._c,8),buffer.writeInt32LE(this._d,12),buffer.writeInt32LE(this._e,16),buffer},module.exports=RIPEMD160}).call(this,require("buffer").Buffer)},{buffer:9,"hash-base":20,inherits:22}],41:[function(require,module,exports){arguments[4][8][0].apply(exports,arguments)},{buffer:9,dup:8}],42:[function(require,module,exports){var Buffer=require("safe-buffer").Buffer;function Hash(blockSize,finalSize){this._block=Buffer.alloc(blockSize),this._finalSize=finalSize,this._blockSize=blockSize,this._len=0}Hash.prototype.update=function(data,enc){"string"==typeof data&&(enc=enc||"utf8",data=Buffer.from(data,enc));for(var block=this._block,blockSize=this._blockSize,length=data.length,accum=this._len,offset=0;offset<length;){for(var assigned=accum%blockSize,remainder=Math.min(length-offset,blockSize-assigned),i=0;i<remainder;i++)block[assigned+i]=data[offset+i];offset+=remainder,(accum+=remainder)%blockSize==0&&this._update(block)}return this._len+=length,this},Hash.prototype.digest=function(enc){var rem=this._len%this._blockSize;this._block[rem]=128,this._block.fill(0,rem+1),rem>=this._finalSize&&(this._update(this._block),this._block.fill(0));var bits=8*this._len;if(bits<=4294967295)this._block.writeUInt32BE(bits,this._blockSize-4);else{var lowBits=4294967295&bits,highBits=(bits-lowBits)/4294967296;this._block.writeUInt32BE(highBits,this._blockSize-8),this._block.writeUInt32BE(lowBits,this._blockSize-4)}this._update(this._block);var hash=this._hash();return enc?hash.toString(enc):hash},Hash.prototype._update=function(){throw new Error("_update must be implemented by subclass")},module.exports=Hash},{"safe-buffer":41}],43:[function(require,module,exports){(exports=module.exports=function(algorithm){algorithm=algorithm.toLowerCase();var Algorithm=exports[algorithm];if(!Algorithm)throw new Error(algorithm+" is not supported (we accept pull requests)");return new Algorithm}).sha=require("./sha"),exports.sha1=require("./sha1"),exports.sha224=require("./sha224"),exports.sha256=require("./sha256"),exports.sha384=require("./sha384"),exports.sha512=require("./sha512")},{"./sha":44,"./sha1":45,"./sha224":46,"./sha256":47,"./sha384":48,"./sha512":49}],44:[function(require,module,exports){var inherits=require("inherits"),Hash=require("./hash"),Buffer=require("safe-buffer").Buffer,K=[1518500249,1859775393,-1894007588,-899497514],W=new Array(80);function Sha(){this.init(),this._w=W,Hash.call(this,64,56)}function rotl30(num){return num<<30|num>>>2}function ft(s,b,c,d){return 0===s?b&c|~b&d:2===s?b&c|b&d|c&d:b^c^d}inherits(Sha,Hash),Sha.prototype.init=function(){return this._a=1732584193,this._b=4023233417,this._c=2562383102,this._d=271733878,this._e=3285377520,this},Sha.prototype._update=function(M){for(var num,W=this._w,a=0|this._a,b=0|this._b,c=0|this._c,d=0|this._d,e=0|this._e,i=0;i<16;++i)W[i]=M.readInt32BE(4*i);for(;i<80;++i)W[i]=W[i-3]^W[i-8]^W[i-14]^W[i-16];for(var j=0;j<80;++j){var s=~~(j/20),t=0|((num=a)<<5|num>>>27)+ft(s,b,c,d)+e+W[j]+K[s];e=d,d=c,c=rotl30(b),b=a,a=t}this._a=a+this._a|0,this._b=b+this._b|0,this._c=c+this._c|0,this._d=d+this._d|0,this._e=e+this._e|0},Sha.prototype._hash=function(){var H=Buffer.allocUnsafe(20);return H.writeInt32BE(0|this._a,0),H.writeInt32BE(0|this._b,4),H.writeInt32BE(0|this._c,8),H.writeInt32BE(0|this._d,12),H.writeInt32BE(0|this._e,16),H},module.exports=Sha},{"./hash":42,inherits:22,"safe-buffer":41}],45:[function(require,module,exports){var inherits=require("inherits"),Hash=require("./hash"),Buffer=require("safe-buffer").Buffer,K=[1518500249,1859775393,-1894007588,-899497514],W=new Array(80);function Sha1(){this.init(),this._w=W,Hash.call(this,64,56)}function rotl5(num){return num<<5|num>>>27}function rotl30(num){return num<<30|num>>>2}function ft(s,b,c,d){return 0===s?b&c|~b&d:2===s?b&c|b&d|c&d:b^c^d}inherits(Sha1,Hash),Sha1.prototype.init=function(){return this._a=1732584193,this._b=4023233417,this._c=2562383102,this._d=271733878,this._e=3285377520,this},Sha1.prototype._update=function(M){for(var num,W=this._w,a=0|this._a,b=0|this._b,c=0|this._c,d=0|this._d,e=0|this._e,i=0;i<16;++i)W[i]=M.readInt32BE(4*i);for(;i<80;++i)W[i]=(num=W[i-3]^W[i-8]^W[i-14]^W[i-16])<<1|num>>>31;for(var j=0;j<80;++j){var s=~~(j/20),t=rotl5(a)+ft(s,b,c,d)+e+W[j]+K[s]|0;e=d,d=c,c=rotl30(b),b=a,a=t}this._a=a+this._a|0,this._b=b+this._b|0,this._c=c+this._c|0,this._d=d+this._d|0,this._e=e+this._e|0},Sha1.prototype._hash=function(){var H=Buffer.allocUnsafe(20);return H.writeInt32BE(0|this._a,0),H.writeInt32BE(0|this._b,4),H.writeInt32BE(0|this._c,8),H.writeInt32BE(0|this._d,12),H.writeInt32BE(0|this._e,16),H},module.exports=Sha1},{"./hash":42,inherits:22,"safe-buffer":41}],46:[function(require,module,exports){var inherits=require("inherits"),Sha256=require("./sha256"),Hash=require("./hash"),Buffer=require("safe-buffer").Buffer,W=new Array(64);function Sha224(){this.init(),this._w=W,Hash.call(this,64,56)}inherits(Sha224,Sha256),Sha224.prototype.init=function(){return this._a=3238371032,this._b=914150663,this._c=812702999,this._d=4144912697,this._e=4290775857,this._f=1750603025,this._g=1694076839,this._h=3204075428,this},Sha224.prototype._hash=function(){var H=Buffer.allocUnsafe(28);return H.writeInt32BE(this._a,0),H.writeInt32BE(this._b,4),H.writeInt32BE(this._c,8),H.writeInt32BE(this._d,12),H.writeInt32BE(this._e,16),H.writeInt32BE(this._f,20),H.writeInt32BE(this._g,24),H},module.exports=Sha224},{"./hash":42,"./sha256":47,inherits:22,"safe-buffer":41}],47:[function(require,module,exports){var inherits=require("inherits"),Hash=require("./hash"),Buffer=require("safe-buffer").Buffer,K=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298],W=new Array(64);function Sha256(){this.init(),this._w=W,Hash.call(this,64,56)}function ch(x,y,z){return z^x&(y^z)}function maj(x,y,z){return x&y|z&(x|y)}function sigma0(x){return(x>>>2|x<<30)^(x>>>13|x<<19)^(x>>>22|x<<10)}function sigma1(x){return(x>>>6|x<<26)^(x>>>11|x<<21)^(x>>>25|x<<7)}function gamma0(x){return(x>>>7|x<<25)^(x>>>18|x<<14)^x>>>3}inherits(Sha256,Hash),Sha256.prototype.init=function(){return this._a=1779033703,this._b=3144134277,this._c=1013904242,this._d=2773480762,this._e=1359893119,this._f=2600822924,this._g=528734635,this._h=1541459225,this},Sha256.prototype._update=function(M){for(var x,W=this._w,a=0|this._a,b=0|this._b,c=0|this._c,d=0|this._d,e=0|this._e,f=0|this._f,g=0|this._g,h=0|this._h,i=0;i<16;++i)W[i]=M.readInt32BE(4*i);for(;i<64;++i)W[i]=0|(((x=W[i-2])>>>17|x<<15)^(x>>>19|x<<13)^x>>>10)+W[i-7]+gamma0(W[i-15])+W[i-16];for(var j=0;j<64;++j){var T1=h+sigma1(e)+ch(e,f,g)+K[j]+W[j]|0,T2=sigma0(a)+maj(a,b,c)|0;h=g,g=f,f=e,e=d+T1|0,d=c,c=b,b=a,a=T1+T2|0}this._a=a+this._a|0,this._b=b+this._b|0,this._c=c+this._c|0,this._d=d+this._d|0,this._e=e+this._e|0,this._f=f+this._f|0,this._g=g+this._g|0,this._h=h+this._h|0},Sha256.prototype._hash=function(){var H=Buffer.allocUnsafe(32);return H.writeInt32BE(this._a,0),H.writeInt32BE(this._b,4),H.writeInt32BE(this._c,8),H.writeInt32BE(this._d,12),H.writeInt32BE(this._e,16),H.writeInt32BE(this._f,20),H.writeInt32BE(this._g,24),H.writeInt32BE(this._h,28),H},module.exports=Sha256},{"./hash":42,inherits:22,"safe-buffer":41}],48:[function(require,module,exports){var inherits=require("inherits"),SHA512=require("./sha512"),Hash=require("./hash"),Buffer=require("safe-buffer").Buffer,W=new Array(160);function Sha384(){this.init(),this._w=W,Hash.call(this,128,112)}inherits(Sha384,SHA512),Sha384.prototype.init=function(){return this._ah=3418070365,this._bh=1654270250,this._ch=2438529370,this._dh=355462360,this._eh=1731405415,this._fh=2394180231,this._gh=3675008525,this._hh=1203062813,this._al=3238371032,this._bl=914150663,this._cl=812702999,this._dl=4144912697,this._el=4290775857,this._fl=1750603025,this._gl=1694076839,this._hl=3204075428,this},Sha384.prototype._hash=function(){var H=Buffer.allocUnsafe(48);function writeInt64BE(h,l,offset){H.writeInt32BE(h,offset),H.writeInt32BE(l,offset+4)}return writeInt64BE(this._ah,this._al,0),writeInt64BE(this._bh,this._bl,8),writeInt64BE(this._ch,this._cl,16),writeInt64BE(this._dh,this._dl,24),writeInt64BE(this._eh,this._el,32),writeInt64BE(this._fh,this._fl,40),H},module.exports=Sha384},{"./hash":42,"./sha512":49,inherits:22,"safe-buffer":41}],49:[function(require,module,exports){var inherits=require("inherits"),Hash=require("./hash"),Buffer=require("safe-buffer").Buffer,K=[1116352408,3609767458,1899447441,602891725,3049323471,3964484399,3921009573,2173295548,961987163,4081628472,1508970993,3053834265,2453635748,2937671579,2870763221,3664609560,3624381080,2734883394,310598401,1164996542,607225278,1323610764,1426881987,3590304994,1925078388,4068182383,2162078206,991336113,2614888103,633803317,3248222580,3479774868,3835390401,2666613458,4022224774,944711139,264347078,2341262773,604807628,2007800933,770255983,1495990901,1249150122,1856431235,1555081692,3175218132,1996064986,2198950837,2554220882,3999719339,2821834349,766784016,2952996808,2566594879,3210313671,3203337956,3336571891,1034457026,3584528711,2466948901,113926993,3758326383,338241895,168717936,666307205,1188179964,773529912,1546045734,1294757372,1522805485,1396182291,2643833823,1695183700,2343527390,1986661051,1014477480,2177026350,1206759142,2456956037,344077627,2730485921,1290863460,2820302411,3158454273,3259730800,3505952657,3345764771,106217008,3516065817,3606008344,3600352804,1432725776,4094571909,1467031594,275423344,851169720,430227734,3100823752,506948616,1363258195,659060556,3750685593,883997877,3785050280,958139571,3318307427,1322822218,3812723403,1537002063,2003034995,1747873779,3602036899,1955562222,1575990012,2024104815,1125592928,2227730452,2716904306,2361852424,442776044,2428436474,593698344,2756734187,3733110249,3204031479,2999351573,3329325298,3815920427,3391569614,3928383900,3515267271,566280711,3940187606,3454069534,4118630271,4000239992,116418474,1914138554,174292421,2731055270,289380356,3203993006,460393269,320620315,685471733,587496836,852142971,1086792851,1017036298,365543100,1126000580,2618297676,1288033470,3409855158,1501505948,4234509866,1607167915,987167468,1816402316,1246189591],W=new Array(160);function Sha512(){this.init(),this._w=W,Hash.call(this,128,112)}function Ch(x,y,z){return z^x&(y^z)}function maj(x,y,z){return x&y|z&(x|y)}function sigma0(x,xl){return(x>>>28|xl<<4)^(xl>>>2|x<<30)^(xl>>>7|x<<25)}function sigma1(x,xl){return(x>>>14|xl<<18)^(x>>>18|xl<<14)^(xl>>>9|x<<23)}function Gamma0(x,xl){return(x>>>1|xl<<31)^(x>>>8|xl<<24)^x>>>7}function Gamma0l(x,xl){return(x>>>1|xl<<31)^(x>>>8|xl<<24)^(x>>>7|xl<<25)}function Gamma1(x,xl){return(x>>>19|xl<<13)^(xl>>>29|x<<3)^x>>>6}function Gamma1l(x,xl){return(x>>>19|xl<<13)^(xl>>>29|x<<3)^(x>>>6|xl<<26)}function getCarry(a,b){return a>>>0<b>>>0?1:0}inherits(Sha512,Hash),Sha512.prototype.init=function(){return this._ah=1779033703,this._bh=3144134277,this._ch=1013904242,this._dh=2773480762,this._eh=1359893119,this._fh=2600822924,this._gh=528734635,this._hh=1541459225,this._al=4089235720,this._bl=2227873595,this._cl=4271175723,this._dl=1595750129,this._el=2917565137,this._fl=725511199,this._gl=4215389547,this._hl=327033209,this},Sha512.prototype._update=function(M){for(var W=this._w,ah=0|this._ah,bh=0|this._bh,ch=0|this._ch,dh=0|this._dh,eh=0|this._eh,fh=0|this._fh,gh=0|this._gh,hh=0|this._hh,al=0|this._al,bl=0|this._bl,cl=0|this._cl,dl=0|this._dl,el=0|this._el,fl=0|this._fl,gl=0|this._gl,hl=0|this._hl,i=0;i<32;i+=2)W[i]=M.readInt32BE(4*i),W[i+1]=M.readInt32BE(4*i+4);for(;i<160;i+=2){var xh=W[i-30],xl=W[i-30+1],gamma0=Gamma0(xh,xl),gamma0l=Gamma0l(xl,xh),gamma1=Gamma1(xh=W[i-4],xl=W[i-4+1]),gamma1l=Gamma1l(xl,xh),Wi7h=W[i-14],Wi7l=W[i-14+1],Wi16h=W[i-32],Wi16l=W[i-32+1],Wil=gamma0l+Wi7l|0,Wih=gamma0+Wi7h+getCarry(Wil,gamma0l)|0;Wih=(Wih=Wih+gamma1+getCarry(Wil=Wil+gamma1l|0,gamma1l)|0)+Wi16h+getCarry(Wil=Wil+Wi16l|0,Wi16l)|0,W[i]=Wih,W[i+1]=Wil}for(var j=0;j<160;j+=2){Wih=W[j],Wil=W[j+1];var majh=maj(ah,bh,ch),majl=maj(al,bl,cl),sigma0h=sigma0(ah,al),sigma0l=sigma0(al,ah),sigma1h=sigma1(eh,el),sigma1l=sigma1(el,eh),Kih=K[j],Kil=K[j+1],chh=Ch(eh,fh,gh),chl=Ch(el,fl,gl),t1l=hl+sigma1l|0,t1h=hh+sigma1h+getCarry(t1l,hl)|0;t1h=(t1h=(t1h=t1h+chh+getCarry(t1l=t1l+chl|0,chl)|0)+Kih+getCarry(t1l=t1l+Kil|0,Kil)|0)+Wih+getCarry(t1l=t1l+Wil|0,Wil)|0;var t2l=sigma0l+majl|0,t2h=sigma0h+majh+getCarry(t2l,sigma0l)|0;hh=gh,hl=gl,gh=fh,gl=fl,fh=eh,fl=el,eh=dh+t1h+getCarry(el=dl+t1l|0,dl)|0,dh=ch,dl=cl,ch=bh,cl=bl,bh=ah,bl=al,ah=t1h+t2h+getCarry(al=t1l+t2l|0,t1l)|0}this._al=this._al+al|0,this._bl=this._bl+bl|0,this._cl=this._cl+cl|0,this._dl=this._dl+dl|0,this._el=this._el+el|0,this._fl=this._fl+fl|0,this._gl=this._gl+gl|0,this._hl=this._hl+hl|0,this._ah=this._ah+ah+getCarry(this._al,al)|0,this._bh=this._bh+bh+getCarry(this._bl,bl)|0,this._ch=this._ch+ch+getCarry(this._cl,cl)|0,this._dh=this._dh+dh+getCarry(this._dl,dl)|0,this._eh=this._eh+eh+getCarry(this._el,el)|0,this._fh=this._fh+fh+getCarry(this._fl,fl)|0,this._gh=this._gh+gh+getCarry(this._gl,gl)|0,this._hh=this._hh+hh+getCarry(this._hl,hl)|0},Sha512.prototype._hash=function(){var H=Buffer.allocUnsafe(64);function writeInt64BE(h,l,offset){H.writeInt32BE(h,offset),H.writeInt32BE(l,offset+4)}return writeInt64BE(this._ah,this._al,0),writeInt64BE(this._bh,this._bl,8),writeInt64BE(this._ch,this._cl,16),writeInt64BE(this._dh,this._dl,24),writeInt64BE(this._eh,this._el,32),writeInt64BE(this._fh,this._fl,40),writeInt64BE(this._gh,this._gl,48),writeInt64BE(this._hh,this._hl,56),H},module.exports=Sha512},{"./hash":42,inherits:22,"safe-buffer":41}],50:[function(require,module,exports){module.exports=Stream;var EE=require("events").EventEmitter;function Stream(){EE.call(this)}require("inherits")(Stream,EE),Stream.Readable=require("readable-stream/readable.js"),Stream.Writable=require("readable-stream/writable.js"),Stream.Duplex=require("readable-stream/duplex.js"),Stream.Transform=require("readable-stream/transform.js"),Stream.PassThrough=require("readable-stream/passthrough.js"),(Stream.Stream=Stream).prototype.pipe=function(dest,options){var source=this;function ondata(chunk){dest.writable&&!1===dest.write(chunk)&&source.pause&&source.pause()}function ondrain(){source.readable&&source.resume&&source.resume()}source.on("data",ondata),dest.on("drain",ondrain),dest._isStdio||options&&!1===options.end||(source.on("end",onend),source.on("close",onclose));var didOnEnd=!1;function onend(){didOnEnd||(didOnEnd=!0,dest.end())}function onclose(){didOnEnd||(didOnEnd=!0,"function"==typeof dest.destroy&&dest.destroy())}function onerror(er){if(cleanup(),0===EE.listenerCount(this,"error"))throw er}function cleanup(){source.removeListener("data",ondata),dest.removeListener("drain",ondrain),source.removeListener("end",onend),source.removeListener("close",onclose),source.removeListener("error",onerror),dest.removeListener("error",onerror),source.removeListener("end",cleanup),source.removeListener("close",cleanup),dest.removeListener("close",cleanup)}return source.on("error",onerror),dest.on("error",onerror),source.on("end",cleanup),source.on("close",cleanup),dest.on("close",cleanup),dest.emit("pipe",source),dest}},{events:19,inherits:22,"readable-stream/duplex.js":27,"readable-stream/passthrough.js":36,"readable-stream/readable.js":37,"readable-stream/transform.js":38,"readable-stream/writable.js":39}],51:[function(require,module,exports){"use strict";var Buffer=require("safe-buffer").Buffer,isEncoding=Buffer.isEncoding||function(encoding){switch((encoding=""+encoding)&&encoding.toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":case"raw":return!0;default:return!1}};function StringDecoder(encoding){var nb;switch(this.encoding=function(enc){var nenc=function(enc){if(!enc)return"utf8";for(var retried;;)switch(enc){case"utf8":case"utf-8":return"utf8";case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return"utf16le";case"latin1":case"binary":return"latin1";case"base64":case"ascii":case"hex":return enc;default:if(retried)return;enc=(""+enc).toLowerCase(),retried=!0}}(enc);if("string"!=typeof nenc&&(Buffer.isEncoding===isEncoding||!isEncoding(enc)))throw new Error("Unknown encoding: "+enc);return nenc||enc}(encoding),this.encoding){case"utf16le":this.text=utf16Text,this.end=utf16End,nb=4;break;case"utf8":this.fillLast=utf8FillLast,nb=4;break;case"base64":this.text=base64Text,this.end=base64End,nb=3;break;default:return this.write=simpleWrite,void(this.end=simpleEnd)}this.lastNeed=0,this.lastTotal=0,this.lastChar=Buffer.allocUnsafe(nb)}function utf8CheckByte(byte){return byte<=127?0:byte>>5==6?2:byte>>4==14?3:byte>>3==30?4:-1}function utf8FillLast(buf){var p=this.lastTotal-this.lastNeed,r=function(self,buf,p){if(128!=(192&buf[0]))return self.lastNeed=0,"�".repeat(p);if(1<self.lastNeed&&1<buf.length){if(128!=(192&buf[1]))return self.lastNeed=1,"�".repeat(p+1);if(2<self.lastNeed&&2<buf.length&&128!=(192&buf[2]))return self.lastNeed=2,"�".repeat(p+2)}}(this,buf,p);return void 0!==r?r:this.lastNeed<=buf.length?(buf.copy(this.lastChar,p,0,this.lastNeed),this.lastChar.toString(this.encoding,0,this.lastTotal)):(buf.copy(this.lastChar,p,0,buf.length),void(this.lastNeed-=buf.length))}function utf16Text(buf,i){if((buf.length-i)%2==0){var r=buf.toString("utf16le",i);if(r){var c=r.charCodeAt(r.length-1);if(55296<=c&&c<=56319)return this.lastNeed=2,this.lastTotal=4,this.lastChar[0]=buf[buf.length-2],this.lastChar[1]=buf[buf.length-1],r.slice(0,-1)}return r}return this.lastNeed=1,this.lastTotal=2,this.lastChar[0]=buf[buf.length-1],buf.toString("utf16le",i,buf.length-1)}function utf16End(buf){var r=buf&&buf.length?this.write(buf):"";if(this.lastNeed){var end=this.lastTotal-this.lastNeed;return r+this.lastChar.toString("utf16le",0,end)}return r}function base64Text(buf,i){var n=(buf.length-i)%3;return 0===n?buf.toString("base64",i):(this.lastNeed=3-n,this.lastTotal=3,1===n?this.lastChar[0]=buf[buf.length-1]:(this.lastChar[0]=buf[buf.length-2],this.lastChar[1]=buf[buf.length-1]),buf.toString("base64",i,buf.length-n))}function base64End(buf){var r=buf&&buf.length?this.write(buf):"";return this.lastNeed?r+this.lastChar.toString("base64",0,3-this.lastNeed):r}function simpleWrite(buf){return buf.toString(this.encoding)}function simpleEnd(buf){return buf&&buf.length?this.write(buf):""}(exports.StringDecoder=StringDecoder).prototype.write=function(buf){if(0===buf.length)return"";var r,i;if(this.lastNeed){if(void 0===(r=this.fillLast(buf)))return"";i=this.lastNeed,this.lastNeed=0}else i=0;return i<buf.length?r?r+this.text(buf,i):this.text(buf,i):r||""},StringDecoder.prototype.end=function(buf){var r=buf&&buf.length?this.write(buf):"";return this.lastNeed?r+"�".repeat(this.lastTotal-this.lastNeed):r},StringDecoder.prototype.text=function(buf,i){var total=function(self,buf,i){var j=buf.length-1;if(j<i)return 0;var nb=utf8CheckByte(buf[j]);if(0<=nb)return 0<nb&&(self.lastNeed=nb-1),nb;if(--j<i)return 0;if(0<=(nb=utf8CheckByte(buf[j])))return 0<nb&&(self.lastNeed=nb-2),nb;if(--j<i)return 0;if(0<=(nb=utf8CheckByte(buf[j])))return 0<nb&&(2===nb?nb=0:self.lastNeed=nb-3),nb;return 0}(this,buf,i);if(!this.lastNeed)return buf.toString("utf8",i);this.lastTotal=total;var end=buf.length-(total-this.lastNeed);return buf.copy(this.lastChar,0,end),buf.toString("utf8",i,end)},StringDecoder.prototype.fillLast=function(buf){if(this.lastNeed<=buf.length)return buf.copy(this.lastChar,this.lastTotal-this.lastNeed,0,this.lastNeed),this.lastChar.toString(this.encoding,0,this.lastTotal);buf.copy(this.lastChar,this.lastTotal-this.lastNeed,0,buf.length),this.lastNeed-=buf.length}},{"safe-buffer":41}],52:[function(require,module,exports){(function(global){function config(name){try{if(!global.localStorage)return!1}catch(_){return!1}var val=global.localStorage[name];return null!=val&&"true"===String(val).toLowerCase()}module.exports=function(fn,msg){if(config("noDeprecation"))return fn;var warned=!1;return function(){if(!warned){if(config("throwDeprecation"))throw new Error(msg);config("traceDeprecation")?console.trace(msg):console.warn(msg),warned=!0}return fn.apply(this,arguments)}}}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],53:[function(require,module,exports){(function(Buffer){var bs58check=require("bs58check"),cashaddr=require("cashaddrjs"),Format={Legacy:"legacy",Bitpay:"bitpay",Cashaddr:"cashaddr"},Network={Mainnet:"mainnet",Testnet:"testnet"},Type={};function detectAddressFormat(address){return decodeAddress(address).format}function detectAddressNetwork(address){return decodeAddress(address).network}function detectAddressType(address){return decodeAddress(address).type}Type.P2PKH="p2pkh",Type.P2SH="p2sh";var VERSION_BYTE={};function decodeAddress(address){try{return function(address){try{var payload=bs58check.decode(address);if(payload.length!==BASE_58_CHECK_PAYLOAD_LENGTH)throw new InvalidAddressError;var versionByte=payload[0],hash=Array.prototype.slice.call(payload,1);switch(versionByte){case VERSION_BYTE[Format.Legacy][Network.Mainnet][Type.P2PKH]:return{hash:hash,format:Format.Legacy,network:Network.Mainnet,type:Type.P2PKH};case VERSION_BYTE[Format.Legacy][Network.Mainnet][Type.P2SH]:return{hash:hash,format:Format.Legacy,network:Network.Mainnet,type:Type.P2SH};case VERSION_BYTE[Format.Legacy][Network.Testnet][Type.P2PKH]:return{hash:hash,format:Format.Legacy,network:Network.Testnet,type:Type.P2PKH};case VERSION_BYTE[Format.Legacy][Network.Testnet][Type.P2SH]:return{hash:hash,format:Format.Legacy,network:Network.Testnet,type:Type.P2SH};case VERSION_BYTE[Format.Bitpay][Network.Mainnet][Type.P2PKH]:return{hash:hash,format:Format.Bitpay,network:Network.Mainnet,type:Type.P2PKH};case VERSION_BYTE[Format.Bitpay][Network.Mainnet][Type.P2SH]:return{hash:hash,format:Format.Bitpay,network:Network.Mainnet,type:Type.P2SH}}}catch(error){}throw new InvalidAddressError}(address)}catch(error){}try{return function(address){if(-1!==address.indexOf(":"))try{return decodeCashAddressWithPrefix(address)}catch(error){}else for(var prefixes=["bitcoincash","bchtest","bchreg"],i=0;i<prefixes.length;++i)try{var prefix=prefixes[i];return decodeCashAddressWithPrefix(prefix+":"+address)}catch(error){}throw new InvalidAddressError}(address)}catch(error){}throw new InvalidAddressError}VERSION_BYTE[Format.Legacy]={},VERSION_BYTE[Format.Legacy][Network.Mainnet]={},VERSION_BYTE[Format.Legacy][Network.Mainnet][Type.P2PKH]=0,VERSION_BYTE[Format.Legacy][Network.Mainnet][Type.P2SH]=5,VERSION_BYTE[Format.Legacy][Network.Testnet]={},VERSION_BYTE[Format.Legacy][Network.Testnet][Type.P2PKH]=111,VERSION_BYTE[Format.Legacy][Network.Testnet][Type.P2SH]=196,VERSION_BYTE[Format.Bitpay]={},VERSION_BYTE[Format.Bitpay][Network.Mainnet]={},VERSION_BYTE[Format.Bitpay][Network.Mainnet][Type.P2PKH]=28,VERSION_BYTE[Format.Bitpay][Network.Mainnet][Type.P2SH]=40,VERSION_BYTE[Format.Bitpay][Network.Testnet]={},VERSION_BYTE[Format.Bitpay][Network.Testnet][Type.P2PKH]=111,VERSION_BYTE[Format.Bitpay][Network.Testnet][Type.P2SH]=196;var BASE_58_CHECK_PAYLOAD_LENGTH=21;function decodeCashAddressWithPrefix(address){try{var decoded=cashaddr.decode(address),hash=Array.prototype.slice.call(decoded.hash,0),type="P2PKH"===decoded.type?Type.P2PKH:Type.P2SH;switch(decoded.prefix){case"bitcoincash":return{hash:hash,format:Format.Cashaddr,network:Network.Mainnet,type:type};case"bchtest":case"bchreg":return{hash:hash,format:Format.Cashaddr,network:Network.Testnet,type:type}}}catch(error){}throw new InvalidAddressError}function InvalidAddressError(){var error=new Error;this.name=error.name="InvalidAddressError",this.message=error.message="Received an invalid Bitcoin Cash address as input.",this.stack=error.stack}InvalidAddressError.prototype=Object.create(Error.prototype),module.exports={Format:Format,Network:Network,Type:Type,isValidAddress:function(input){try{return decodeAddress(input),!0}catch(error){return!1}},detectAddressFormat:detectAddressFormat,detectAddressNetwork:detectAddressNetwork,detectAddressType:detectAddressType,toLegacyAddress:function(address){var decoded=decodeAddress(address);return decoded.format===Format.Legacy?address:function(decoded){var versionByte=VERSION_BYTE[Format.Legacy][decoded.network][decoded.type],buffer=Buffer.alloc(1+decoded.hash.length);return buffer[0]=versionByte,buffer.set(decoded.hash,1),bs58check.encode(buffer)}(decoded)},toBitpayAddress:function(address){var decoded=decodeAddress(address);return decoded.format===Format.Bitpay?address:function(decoded){var versionByte=VERSION_BYTE[Format.Bitpay][decoded.network][decoded.type],buffer=Buffer.alloc(1+decoded.hash.length);return buffer[0]=versionByte,buffer.set(decoded.hash,1),bs58check.encode(buffer)}(decoded)},toCashAddress:function(address){return function(decoded){var prefix=decoded.network===Network.Mainnet?"bitcoincash":"bchtest",type=decoded.type===Type.P2PKH?"P2PKH":"P2SH",hash=new Uint8Array(decoded.hash);return cashaddr.encode(prefix,type,hash)}(decodeAddress(address))},isLegacyAddress:function(address){return detectAddressFormat(address)===Format.Legacy},isBitpayAddress:function(address){return detectAddressFormat(address)===Format.Bitpay},isCashAddress:function(address){return detectAddressFormat(address)===Format.Cashaddr},isMainnetAddress:function(address){return detectAddressNetwork(address)===Network.Mainnet},isTestnetAddress:function(address){return detectAddressNetwork(address)===Network.Testnet},isP2PKHAddress:function(address){return detectAddressType(address)===Type.P2PKH},isP2SHAddress:function(address){return detectAddressType(address)===Type.P2SH},InvalidAddressError:InvalidAddressError}}).call(this,require("buffer").Buffer)},{bs58check:7,buffer:9,cashaddrjs:11}]},{},[53])(53)});
</script>
<script>
/**
 *  this is a port of pyflate
 *  @url http://www.paul.sladen.org/projects/pyflate/
 *  @author kirilloid
 * @license CC-SA 3.0
 */

var ArchUtils = (function(){
    'use strict';

    // python functions eliminated, Gonzalo

    /**
     * bwt_reverse code from wikipedia (slightly modified)
     * @url http://en.wikipedia.org/wiki/Burrows%E2%80%93Wheeler_transform
     * @license: CC-SA 3.0
     */

    function bwt_reverse(src, primary) {
        var len = src.length;
        if (primary >= len) throw RangeError("Out of bound");
        if (primary < 0) throw RangeError("Out of bound");

        //only used on arrays, optimized, Gonzalo
        var A = src;
        src = src.join('');
        A.sort();

        var start = {};
        for (var i = len-1; i >= 0; i--) start[A[i]] = i;

        var links = [];
        for (i = 0; i < len; i++) links.push(start[src[i]]++);

        var i, first = A[i = primary], ret = [];

        for (var j = 1; j < len; j++) {
            ret.push(A[i = links[i]]);
        }
        return first + ret.reverse().join('');
    }

    //move_to_front is always used to store reslt in array, optimized, Gonzalo
    function move_to_front_and_store(a, c, buff) {
        var v = a[c];
        for (var i = c; i > 0; a[i] = a[--i]);
        buff.push(a[0] = v);
    }

    // BitfieldBase never used directly, optimized, Gonzalo
    /**
     * @class RBitfield
     * right-sided bitfield for reading bits in byte from right to left
     */
    var RBitfield = function() {
        this.init = function(x) {
            this.masks = [];
            for (var i = 0; i < 31; i++) this.masks[i] = (1 << i) - 1;
            this.masks[31] = -0x80000000;
            //eliminated support for RBitfield.init( RBitfield ), never used, Gonzalo
            this.f = x;
            this.bits = 0;
            this.bitfield = 0x0;
            this.count = 0;
        }
        //_read not used, optimized, Gonzalo
        //readByte inlined, Gonzalo
        //needbits inlined, Gonzalo
        //align inlined, Gonzalo
        //toskip inlined, Gonzalo
        // this.dropbytes not used, eliminated, Gonzalo
        // this.tell not used, eliminated, Gonzalo
        // since js truncate args to int32 with bit operators
        // we need to specific processing for n >= 32 bits reading
        // separate function is created for optimization purposes
        //readbits2 always called ith constants >=32, check removed, Gonzalo
        this.readbits2 = function readbits2(n) {
            //only for n>=32!!!, check removed
            var n2 = n >> 1;
            return this.readbits(n2) * (1 << n2) + this.readbits(n - n2);
        }
        this.readbits = function readbits(n) {
            //if (n > this.bits) this.needbits(n);
            // INLINED: needbits, readByte
            while (this.bits < n) {
                this.bitfield = (this.bitfield << 8) + this.f.charCodeAt(this.count++);
                this.bits += 8;
            }
            var m = this.masks[n];
            var r = (this.bitfield >> (this.bits - n)) & m;
            this.bits -= n;
            this.bitfield &= ~(m << this.bits);
            return r;
        }
    }

    /**
     * @class HuffmanLength
     * utility class, used for comparison of huffman codes
     */
    var HuffmanLength = function(code, bits) {
        this.code = code;
        this.bits = bits;
        this.symbol = undefined;
    } //cropped unused functions and needless checks, Gonzalo

    //class HuffmanTable never used directly..., optimized, Gonzalo

    /**
     * @class OrderedHuffmanTable
     * utility class for working with huffman table
     */
    var OrderedHuffmanTable = function() {
        this.process = function(lengths) {
            var len = lengths.length;
            var z = [];
            for (var i = 0; i < len; i++) {
                z.push([i, lengths[i]]);
            }
            z.push([len, -1]);

            var l = [];
            var b = z[0];
            var start = b[0], bits = b[1];
            for (var p = 1; p < z.length; p++) {
                var finish = z[p][0], endbits = z[p][1];
                if (bits)
                    for (var code = start; code < finish; code++)
                        l.push(new HuffmanLength(code, bits));
                start = finish;
                bits = endbits;
                if (endbits == -1) break;
            }
            l.sort(function (a, b) { //function cmpHuffmanTable(a, b), can be anonymous, optimized, Gonzalo
                return (a.bits - b.bits) || (a.code - b.code);
            });
            this.table = l;

            //inlined populate_huffman_symbols, Gonzalo
            var temp_bits = 0;
            var symbol = -1;
            // faht = Fast Access Huffman Table
            this.faht = [];
            var cb = null;
            for (var i = 0; i < this.table.length; i++) {
                var x = this.table[i];
                symbol += 1;
                if (x.bits != temp_bits ) {
                    symbol <<= x.bits - temp_bits ;
                    cb = this.faht[temp_bits = x.bits] = {};
                }
                cb[x.symbol = symbol] = x;
            }

            //inlined min_max_bits

            this.min_bits = 16;
            this.max_bits = -1;
            this.table.forEach(function(x){
                if (x.bits < this.min_bits) this.min_bits = x.bits;
                if (x.bits > this.max_bits) this.max_bits = x.bits;
            }, this);
        }
    }

    return ({ bz2: { decode: function(input) { //eliminated unused unpackSize, Gonzalo
        var b = new RBitfield();
        b.init(input);
        b.readbits(16);
        var method = b.readbits(8);
        if (method != 104) { //char 'h'
            throw "Unknown (not type 'h'uffman Bzip2) compression method";
        }

        var blocksize = b.readbits(8);
        if ( 49 <= blocksize && blocksize <= 57) { //char '1' && char '9'
            blocksize -= 48; //char 0
        } else {
            throw "Unknown (not size '1'-'9') Bzip2 blocksize";
        }

        function getUsedCharTable(b) {
            var a = [];
            var used_groups = b.readbits(16);
            for (var m1 = 1 << 15; m1 > 0; m1 >>= 1) {
                if (!(used_groups & m1)) {
                    for (var i = 0; i < 16; i++) a.push(false);
                    continue;
                }
                var used_chars = b.readbits(16);
                for (var m2 = 1 << 15; m2 > 0; m2 >>= 1) {
                    a.push( Boolean(used_chars & m2) );
                }
            }
            return a;
        }

        var out = [];

        function main_loop() { while (true) {
            var blocktype = b.readbits2(48);
            var crc = b.readbits2(32);
            if (blocktype == 0x314159265359) { // (pi)
                if (b.readbits(1)) throw "Bzip2 randomised support not implemented";
                var pointer = b.readbits(24);
                var used = getUsedCharTable(b);

                var huffman_groups = b.readbits(3);
                if (2 > huffman_groups || huffman_groups > 6)
                    throw RangeError("Bzip2: Number of Huffman groups not in range 2..6");
                var mtf = [0,1,2,3,4,5,6].slice(0,huffman_groups); //eliminate use of range, Gonzalo
                var selectors_list = [];
                for (var i = 0, selectors_used = b.readbits(15); i < selectors_used; i++) {
                    // zero-terminated bit runs (0..62) of MTF'ed huffman table
                    var c = 0;
                    while (b.readbits(1)) {
                        if (c++ >= huffman_groups)
                            throw RangeError("More than max ("+huffman_groups+") groups");
                    }
                    move_to_front_and_store(mtf, c, selectors_list); //optimized to single function, Gonzalo
                }
                var groups_lengths = [];

                // INLINE: sum used only once, Gonzalo
                var symbols_in_use = used.reduce( function(a, b) {return a + b}, 0 ) + 2; //sum(used) + 2 // remember RUN[AB] RLE symbols

                for (var j = 0; j < huffman_groups; j++) {
                    var length = b.readbits(5);
                    var lengths = [];
                    for (var i = 0; i < symbols_in_use; i++) {
                        if (length < 0 || length > 20)
                            throw RangeError("Bzip2 Huffman length code outside range 0..20");
                        while (b.readbits(1)) length -= (b.readbits(1) * 2) - 1;
                        lengths.push(length);
                    }
                    groups_lengths.push(lengths);
                }
                var tables = [];
                for (var g = 0; g < groups_lengths.length; g++) {
                    var codes = new OrderedHuffmanTable();
                    codes.process(groups_lengths[g]); //consolidated function calls
                    tables.push(codes);
                }
                var favourites = [];
                for (var c = used.length - 1; c >= 0; c--) {
                    if (used[c]) favourites.push(String.fromCharCode(c)); //inlined chr, used once, Gonzalo
                }
                favourites.reverse();
                var selector_pointer = 0;
                var decoded = 0;
                var t;

                // Main Huffman loop
                var repeat = 0;
                var repeat_power = 0;
                var buffer = [], r;

                while (true) {
                    if (--decoded <= 0) {
                        decoded = 50;
                        if (selector_pointer <= selectors_list.length)
                            t = tables[selectors_list[selector_pointer++]];
                    }

                    // INLINED: find_next_symbol
                    for (var bb in t.faht) {
                        if (b.bits < bb) {
                            b.bitfield = (b.bitfield << 8) + b.f.charCodeAt(b.count++);
                            b.bits += 8;
                        }
                        if (r = t.faht[bb][ b.bitfield >> (b.bits - bb) ]) {
                            b.bitfield &= b.masks[b.bits -= bb];
                            r = r.code;
                            break;
                        }
                    }

                    if (0 <= r && r <= 1) {
                        if (repeat == 0)  repeat_power = 1;
                        repeat += repeat_power << r;
                        repeat_power <<= 1;
                        continue;
                    } else {
                        var v = favourites[0];
                        for ( ; repeat > 0; repeat--) buffer.push(v);
                    }
                    if (r == symbols_in_use - 1) { // eof symbol
                        break;
                    } else {
                        move_to_front_and_store(favourites,r-1,buffer); //Uninlined, size efficiency, Gonzalo
                    }
                }
                var nt = bwt_reverse(buffer, pointer);
                var done = [];
                var i = 0;
                var len = nt.length;
                // RLE decoding
                while (i < len) {
                    var c = nt.charCodeAt(i);
                    if ((i < len - 4)
                    && nt.charCodeAt(i+1) == c
                    && nt.charCodeAt(i+2) == c
                    && nt.charCodeAt(i+3) == c) {
                        var c = nt.charAt(i);
                        var rep = nt.charCodeAt(i+4)+4;
                        for (; rep > 0; rep--) done.push(c);
                        i += 5;
                    } else {
                        done.push(nt[i++]);
                    }
                }
                out.push(done.join(''));
            } else if (blocktype == 0x177245385090) { // sqrt(pi)
                b.readbits(b.bits & 0x7);  //align
                break;
            } else {
                throw "Illegal Bzip2 blocktype = 0x" + blocktype.toString(16);
            }
        } }
        main_loop();
        return out.join('');
    } } });
})();</script>
<script>
    var bzdata = "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";
    var hflags = [
        { "1": 15,"2": 11,"3": 11,"4": 3,"5": 2,"6": 2,"7": 3,"8": 3,"9": 1,"10": 2,"11": 3,"12": 2,"13": 9,"14": 2,"15": 2,"16": 2,"17": 3,"18": 2,"19": 2,"21": 3,"22": 2,"23": 3,"24": 2,"25": 2,"26": 1,"27": 1,"28": 2,"30": 2,"31": 2,"33": 2,"35": 2,"38": 2,"41": 1,"42": 1,"45": 1,"46": 2,"49": 1,"54": 2,"58": 2,"59": 2,"63": 8,"64": 8,"65": 8,"66": 2,"75": 2,"76": 1,"77": 2,"78": 2,"81": 3,"82": 2,"86": 2,"87": 2,"91": 2,"93": 2,"94": 2,"95": 2,"97": 2,"105": 10,"111": 2,"112": 2,"114": 2,"116": 2,"123": 3,"124": 2,"125": 2,"126": 2,"127": 2,"128": 3,"139": 2,"144": 1,"161": 1,"192": 8,"195": 8,"200": 2,"212": 2,"214": 2,"224": 1,"229": 2,"255": 3,"256": 2,"257": 2,"259": 2,"260": 2,"273": 2,"280": 2,"282": 2,"338": 2,"360": 3,"384": 2,"386": 2,"451": 2,"467": 1,"512": 2,"513": 2,"514": 1,"522": 2,"529": 4,"536": 8,"549": 3,"613": 2,"666": 2,"897": 2,"898": 2,"978": 1,"1020": 2,"1024": 2,"1056": 2,"1153": 2,"1155": 1,"1233": 2,"1322": 2,"1337": 1,"1372": 2,"1409": 2,"1411": 2,"1441": 1,"1668": 1,"1817": 2,"1911": 2,"1915": 2,"1975": 3,"2304": 2,"2317": 2,"2683": 1,"2752": 8,"2913": 8,"3105": 2,"3264": 8,"3414": 2,"4354": 8,"4635": 1,"5216": 1,"5249": 1,"6446": 2,"6528": 1,"6531": 1,"6547": 2,"7150": 2,"8707": 1,"8984": 8,"9001": 2,"9781": 1,"10125": 2,"10241": 2,"10544": 1,"12165": 2,"12352": 8,"12801": 2,"13666": 1,"14257": 2,"17547": 2,"19358": 2,"22370": 8,"24969": 1,"25473": 2,"26867": 1,"28672": 2,"29058": 2,"29817": 2,"34181": 1,"38023": 1,"38390": 2,"38522": 2,"40003": 8,"44129": 2,"44161": 2,"51510": 1,"53722": 2,"63983": 2,"65535": 2,"65536": 2,"68252": 2,"95823": 1,"97364": 8,"113578": 1,"127744": 2,"127755": 2,"127865": 2,"128000": 2,"157168": 2,"164375": 2,"171057": 2,"191953": 2,"198669": 1,"227328": 2,"251647": 2,"253058": 2,"254218": 2,"261991": 1,"357535": 1,"384283": 2,"491993": 2,"500000": 2,"571745": 2,"639872": 2,"708246": 2,"833294": 2,"863317": 1,"920108": 2,"968319": 2,"1000000": 2 }
    ];
</script>
<style>
    #pre {
        font-size: 13px;
        overflow: hidden;
    }
    #pre .line:nth-child(4n+1):not(.tooltiptext) {
      background-color: #c0f0f0;
    }
    #pre .line:nth-child(4n+2) {
      background-color: #c0f0f0;
    }
    #pre .line:nth-child(1):not(.tooltiptext) {
      background: none;
    }
    #pre .line:nth-child(2):not(.prefix) {
      font-weight: bold;
      color: white;
      background: black;
    }
    #pre .line:nth-last-child(1):not(.prefix) {
        border-bottom: 2px solid black;
    }
    .tooltip {
      position: relative;
      display: inline-block;
    }
    .tooltip .tooltiptext {
      visibility: hidden;
      width: 120px;
      background-color: #ffffc0;
      color: black;
      text-align: center;
      padding: 5px 0;
      border-radius: 6px;
      position: absolute;
      z-index: 1;
    }
    .tooltip:hover .tooltiptext {
      visibility: visible;
      width: 800px;
      top: 100%;
      left: 50%;
      margin-left: -400px;
      font-weight: normal;
      font-style: italic;
      font-size: 14px;
      white-space: normal;
      font-family: Times;
      color: black;
      background-color: #ffffc0;
      padding: 5px 0;
      border-radius: 6px;
    }
    .qrtip {
      position: relative;
      display: inline-block;
      font-weight: bold;
      text-decoration: underline;
      text-decoration-style: dotted;
      cursor: pointer;
    }
    .qrtip .qrtipimg {
      visibility: hidden;
      width: 300px;
      background-color: white;
      bottom: 100%;
      left: 50%;
      color: black;
      text-align: center;
      padding: 5px 0;
      border-radius: 6px;
      position: absolute;
      z-index: 1;
    }
    .qrtip:hover .qrtipimg {
      visibility: visible;
      width: 300px;
      bottom: 100%;
      left: 50%;
      margin-left: -150px;
      color: black;
      background-color: white;
      padding: 5px 0;
      border-radius: 6px;
      border: 3px solid gray;
    }
    h2 {
        margin-bottom: 0;
    }
    .priv_key {
        color: black;
    }
    .notation {
        text-decoration: underline;
        text-decoration-style: dashed;
        cursor: pointer;
    }
    .prefix {
        color: #800000;
        font-weight: bold;
    }
    .suffix {
        color: #600000;
    }
    #langbox {
        position: absolute;
        top: 8px;
        right: 8px;
    }
    #modal {
        visibility: hidden;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        opacity: 0.5;
        background-color: black;
        z-index: 10;
    }
    #all {
        visibility: hidden;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: transparent;
        z-index: 11;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    #search {
        width: 60%;
        height: 20em;
        border-radius: 10px;
        background-color: white;
        border: 3px solid gray;
        visibility: hidden;
        z-index: 12;
        opacity: 1;
        padding: 10px;
    }
    #searchbox {
        width: 70%;
        font-family: monospace;
        margin-top: 1em;
    }
    #privacy {
        visibility: hidden;
        position: absolute;
        bottom: 0;
        width: 100%;
        background-color: black;
        z-index: 11;
        opacity: 1;
        color: white;
        padding: 20px;
        box-sizing: border-box;
    }
    #terms {
        font-size: 18px;
        font-family: Helvetica;
        font-style: italic;
        margin-right: 50px;
    }
    #agree_button {
        background-color: white;
        color: black;
        padding: 16px;
        float: left;
        border: none;
        font-weight: bold;
        margin-right: 10px;
        font-size: 16px;
    }
    #privacy a:visited {
        color: gray;
    }
    #privacy a:link {
        color: cyan;
    }
    .pageno {
        text-align: right;
    }
    h3 {
        margin-bottom: 0;
        font-family: Times;
        font-size: 16px;
        max-width: 100%;
        overflow: hidden;
        height: 80px;
    }
    .mobile #terms {
        font-size: 54px;
    }
    .mobile #agree_button {
        font-size: 48px;
        padding: 48px;
        margin-right: 30px;
    }
    .subtitle {
        font-size: 16px;
    }
    body {
        padding: 0;
        margin: 0;
    }
    main {
        padding: 8px;
    }
    #hilite {
        background-color: #ffc0c0 !important;
    }
    #errmsg {
        color: red;
        font-weight: bold;
        font-size: 12px;
        padding-top: 3px;
    }
    .warning {
        color: red;
    }
    #processing {
        background-image: url("data:image/gif;base64,R0lGODlhEAAQAPIAAP///wAAAMLCwkJCQgAAAGJiYoKCgpKSkiH/C05FVFNDQVBFMi4wAwEAAAAh/hpDcmVhdGVkIHdpdGggYWpheGxvYWQuaW5mbwAh+QQJCgAAACwAAAAAEAAQAAADMwi63P4wyklrE2MIOggZnAdOmGYJRbExwroUmcG2LmDEwnHQLVsYOd2mBzkYDAdKa+dIAAAh+QQJCgAAACwAAAAAEAAQAAADNAi63P5OjCEgG4QMu7DmikRxQlFUYDEZIGBMRVsaqHwctXXf7WEYB4Ag1xjihkMZsiUkKhIAIfkECQoAAAAsAAAAABAAEAAAAzYIujIjK8pByJDMlFYvBoVjHA70GU7xSUJhmKtwHPAKzLO9HMaoKwJZ7Rf8AYPDDzKpZBqfvwQAIfkECQoAAAAsAAAAABAAEAAAAzMIumIlK8oyhpHsnFZfhYumCYUhDAQxRIdhHBGqRoKw0R8DYlJd8z0fMDgsGo/IpHI5TAAAIfkECQoAAAAsAAAAABAAEAAAAzIIunInK0rnZBTwGPNMgQwmdsNgXGJUlIWEuR5oWUIpz8pAEAMe6TwfwyYsGo/IpFKSAAAh+QQJCgAAACwAAAAAEAAQAAADMwi6IMKQORfjdOe82p4wGccc4CEuQradylesojEMBgsUc2G7sDX3lQGBMLAJibufbSlKAAAh+QQJCgAAACwAAAAAEAAQAAADMgi63P7wCRHZnFVdmgHu2nFwlWCI3WGc3TSWhUFGxTAUkGCbtgENBMJAEJsxgMLWzpEAACH5BAkKAAAALAAAAAAQABAAAAMyCLrc/jDKSatlQtScKdceCAjDII7HcQ4EMTCpyrCuUBjCYRgHVtqlAiB1YhiCnlsRkAAAOwAAAAAAAAAAAA==");
        width: 16px;
        height: 16px;
        display: none;
        float: right;
    }
    .leading_zeros {
        opacity: 0.25;
    }
    a:link {
        color: black;
    }
    a:visited {
        color: #404040;
    }
    @media screen and (min-width: 900px) {
        .long {
            display: inline;
        }
        .long:link {
            color: black;
        }
        .short {
            display: none;
        }
        #nav {
            margin-top: -55px;
        }
    }
    @media screen and (max-width: 1150px) {
        #nav {
            margin-top: -30px;
        }
    }
    @media screen and (max-width: 900px) {
        .long {
            display: none;
        }
        .short {
            display: inline;
        }
    }
    #contents {
        width: 100%;
    }
</style>
<div id="contents"></div>
<script>

var html = "";
var versions = [
    { value:  0, wif: 128, label: "Bitcoin P2PKH",                                      prefix: "1",    app: "<a href='https://web.archive.org/web/20220428024327/https://electrum.org/' target='out'>Electrum</a>"                        , prettify: (x) => x.replace(/^./,"<tt class='prefix'>$&</tt>").replace(/......$/,"<tt class='suffix'>$&</tt>")    },
    { value:  5, wif: 128, label: "Bitcoin P2WPKH-P2SH",  segwit:   true,               prefix: "3",    app: "<a href='https://web.archive.org/web/20220428024327/https://electrum.org/' target='out'>Electrum</a>"                        , prettify: (x) => x.replace(/^./,"<tt class='prefix'>$&</tt>").replace(/......$/,"<tt class='suffix'>$&</tt>")    },
    { value:  0, wif: 128, label: "Bitcoin P2WPKH",       segwit:   true, bech32: true, prefix: "bc",   app: "<a href='https://web.archive.org/web/20220428024327/https://electrum.org/' target='out'>Electrum</a>"                        , prettify: (x) => x.replace(/^.../,"<tt class='prefix'>$&</tt>").replace(/......$/,"<tt class='suffix'>$&</tt>")  },
    { value:  0, wif: 128, label: "Bitcoin_Cash P2PKH",   cashaddr: true,               prefix: "q",    app: "<a href='https://web.archive.org/web/20220428024327/https://electroncash.org/' target='out'>Electron Cash</a>"               , prettify: (x) => x.replace(/^./,"<tt class='prefix'>$&</tt>").replace(/......$/,"<tt class='suffix'>$&</tt>")    },
    { value: 48, wif: 176, label: "Litecoin P2PKH",                                     prefix: "L",    app: "<a href='https://web.archive.org/web/20220428024327/https://electrum-ltc.org/' target='out'>Electrum-LTC</a>"                , prettify: (x) => x.replace(/^./,"<tt class='prefix'>$&</tt>").replace(/......$/,"<tt class='suffix'>$&</tt>")    },
    { value: 50, wif: 176, label: "Litecoin P2WPKH-P2SH", segwit:   true,               prefix: "M",    app: "<a href='https://web.archive.org/web/20220428024327/https://electrum-ltc.org/' target='out'>Electrum-LTC</a>"                , prettify: (x) => x.replace(/^./,"<tt class='prefix'>$&</tt>").replace(/......$/,"<tt class='suffix'>$&</tt>")    },
    { value:  0, wif: 176, label: "Litecoin P2WPKH",      segwit:   true, bech32: true, prefix: "ltc",  app: "<a href='https://web.archive.org/web/20220428024327/https://electrum-ltc.org/' target='out'>Electrum-LTC</a>"                , prettify: (x) => x.replace(/^..../,"<tt class='prefix'>$&</tt>").replace(/......$/,"<tt class='suffix'>$&</tt>") },
    { value: 76, wif: 204, label: "DASH P2PKH",                                         prefix: "X",    app: "<a href='https://web.archive.org/web/20220428024327/https://electrum.dash.org/' target='out'>Dash Electrum</a>"              , prettify: (x) => x.replace(/^./,"<tt class='prefix'>$&</tt>").replace(/......$/,"<tt class='suffix'>$&</tt>")    },
    { value: 30, wif: 158, label: "Dogecoin P2PKH",                                     prefix: "D",    app: "<a href='https://web.archive.org/web/20220428024327/https://my.dogechain.info/' target= out'>Dogechain Wallet</a>"           , prettify: (x) => x.replace(/^./,"<tt class='prefix'>$&</tt>").replace(/......$/,"<tt class='suffix'>$&</tt>")    },
    { value: 52, wif: 180, label: "Namecoin P2PKH",                                     prefix: "N",    app: "<a href='https://web.archive.org/web/20220428024327/https://github.com/namecoin/electrum-nmc/' target='out'>Electrum-NMC</a>", prettify: (x) => x.replace(/^./,"<tt class='prefix'>$&</tt>").replace(/......$/,"<tt class='suffix'>$&</tt>")    },
];

var items_per_page = 30;
var hilite = BigInteger.ZERO;

var max   = new BigInteger("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141",16);
var pages = max.divide(new BigInteger(`${items_per_page}`,10)).add(BigInteger.ONE);

window.dataLayer = window.dataLayer || [];
function gtag() {dataLayer.push(arguments);}

var addrmap = JSON.parse(ArchUtils.bz2.decode(atob(bzdata)));

function recompute(params,clear) {

    if (clear) hilite = BigInteger.ZERO;

    if (!params) params = { };

    if (location.search) {
        location.search.substr(1).split(/,/).forEach( (item) => {
             var data  = item.split(/=/);
             var key   = data[0];
             var value = data[1];
             sessionStorage.setItem(key,value);
        });
        location.href = location.pathname;
    } else {
        if (params) {
            Object.keys(params).forEach( (item) => {
                if (item == "agreed") {
                   localStorage.setItem(item,params[item]);
                } else {
                   sessionStorage.setItem(item,params[item]+"");
                }
            });
        }
    }

    var network_version = parseInt(sessionStorage.getItem("network_version") || "0");
    var wif_prefix = versions[network_version].wif;

    document.title = t({
        "en": `All ${versions[network_version].label.replace(/ .*$/,"").replace(/_/g," ")} Private Keys`,
        "pt-br": `Todas as Chaves Privadas ${versions[network_version].label.replace(/ .*$/,"").replace(/_/g," ")}`,
    });

    write(`<div id="langbox"></div><div id="modal"></div><div id="all"><div id="search">`);
    write(t({
        "en": "<b>Search</b>",
        "pt-br": "<b>Pesquisar</b>"
    }));
    write(`&nbsp;<div id="processing"></div>`);
    write(t({
        "en": `<br/><input type="text" id="searchbox" maxlength="78"/>&nbsp;<button onclick="event.stopPropagation(); search()">Search</button>&nbsp;<button id="random_button">Random</button><div id="errmsg"></div>`,
        "pt-br": `<br/><input type="text" id="searchbox" maxlength="78"/>&nbsp;<button onclick="event.stopPropagation(); search()">Buscar</button>&nbsp;<button id="random_button">Aleatório</button><div id="errmsg"></div>`
    }));
    write(t({
        "en": `<ul><li><b>By page:</b> Type # followed by the page number</li><br/><li><b>By <a href="https://web.archive.org/web/20220428024327/https://en.bitcoin.it/wiki/Private_key" target="out">Private Key</a>:</b> Insert WIF, hex (0x) or decimal<br/><i>Requires trusting that nobody will intercept the key (which we can't guarantee), so<br/><span class="warning">DO NOT PUT IMPORTANT/VALUABLE KEYS HERE!</span></i></li><br/><li id="addrsearch"><b>By Address:</b> Just type the address<br/><i>Will return "not found" for more than 99,9999999% of randomly-chosen addresses<br/>because the index covers only a tiny fraction of the total possible addresses</i></li><br/><li><b><a href="https://web.archive.org/web/20220428024327/https://en.wikipedia.org/wiki/SHA-2" target="out">SHA256</a> Hash:</b> Type a string within double quotes.</li></ul>`,
        "pt-br": `<ul><li><b>Por página:</b> Digite # seguido do número da página</li><br/><li><b>Por <a href="https://web.archive.org/web/20220428024327/https://en.bitcoin.it/wiki/Private_key" target="out">Chave Privada</a>:</b> Digite o WIF, hexadecimal (0x) ou decimal<br/><i>Requer confiar que ninguém intercepte a chave (o que não temos como garantir), então <br/><span class="warning">NÃO PONHA CHAVES IMPORTANTES OU VALIOSAS AQUI!</span></i></li><br/><li id="addrsearch"><b>Por Endereço:</b> Digite o endereço<br/><i>Dará "não encontrado" mais que 99,9999999% das vezes para endereços aleatórios<br/>porque o índice só cobre uma porção ínfima do total de endereços possíveis</i></li><br/><li><b>Hash <a href="https://web.archive.org/web/20220428024327/https://pt.wikipedia.org/wiki/SHA-2" target="out">SHA256</a>:</b> Digite o texto entre aspas duplas.</li></ul>`
    }));
    write(`</div></div><div id="privacy"></div><center id="main">`);
    write(`<h2>${document.title}</h2>`);
    var text = t({
        "en": "This is not a precomputed database; this page mostly calculates things on the fly as you change pages and options.",
        "pt-br": "Esta página não é um banco de dados pré-computado; ela calcula a maioria as coisas em tempo real à medida em que você muda de página ou as opções de exibição."
    });
    write(t({
        "en": `<i class="subtitle"><span class="tooltip notation">(${items_per_page} at a time<span class="tooltiptext">${text}</span></span>, along with its corresponding ${versions[network_version].label.replace(/^.*? /,"")} addresses)</i>`,
        "pt-br": `<i class="subtitle"><span class="tooltip notation">(${items_per_page} de cada vez<span class="tooltiptext">${text}</span></span>, juntamente com seus endereços ${versions[network_version].label.replace(/^.*? /,"")} correspondentes)</i>`
    }));

    var page = sessionStorage.getItem("page") || "1";
    page = new BigInteger(page,10);
    var is0 = page.compareTo(BigInteger.ZERO);
    if (!is0) page = BigInteger.ONE;
    if (is0<0) page = page.add(pages); // >
    if (page.compareTo(pages)>0) page = pages;

    var millenia = pages.divide(new BigInteger("31_557_600_000_000_000_000_000",10));

    text = t({
        "en": `You'd take ${pretty_align(millenia.toString(),0,true)} <b>millenia</b> to go through all that many pages even if you could read a trillion of them per second.`,
        "pt-br": `Levaria ${pretty_align(millenia.toString(),0,true)} <b>milênios</b> para passar por todas as páginas se você conseguisse ler um trilhão delas por segundo.`
    });
    write(t({
        "en": `<h3>Page <span class="tooltip"><input class="pageno" type="text" value="${page.toString()}" size="5" onfocus="javascript:search_dialog()"/><span class="tooltiptext" style="width: 200px; margin-left: -100px;">Click to search</span></span> of <span class="tooltip notation">${pretty_align(pages.toString(),0,true)}<span class="tooltiptext">${text}</span></span></h3>`,
        "pt-br": `<h3>Página <span class="tooltip"><input class="pageno" type="text" value="${page.toString()}" size="5" onfocus="javascript:search_dialog()"/><span class="tooltiptext" style="width: 200px; margin-left: -100px;">Clique para pesquisar</span></span> de <span class="tooltip notation">${pretty_align(pages.toString(),0,true)}<span class="tooltiptext">${text}</span></span></h3>`
    }));
    write(`<div id="nav">`);

    var prev = BigInteger.ONE;
    if (page.compareTo(BigInteger.ONE)>0) prev = page.subtract(BigInteger.ONE);
    var first_page = t({
        "en": "First",
        "pt-br": "Primeira"
    });
    var prev_page = t({
        "en": "Previous",
        "pt-br": "Anterior"
    });
    write(`<a href="javascript:recompute(\{page:'1'\})">${first_page}</a> | `);
    write(`<a href="javascript:recompute(\{page:'${prev.toString()}'\})">${prev_page}</a> | `);

    write(`<select onchange="javascript:recompute(\{network_version:this.value\},true);">`);
    var i = 0;
    versions.forEach ( (item) => {
        write(`<option value="${i}" ${network_version==i?"selected":""}>${item.label.replace(/_/g," ")}</option>`); // "
        i++;
    });
    write(`</select>`);

    var next;
    next = page.add(BigInteger.ONE);
    if (next.compareTo(pages)>0) next = page;
    var next_page = t({
        "en": "Next",
        "pt-br": "Próxima"
    });
    var last_page = t({
        "en": "Last",
        "pt-br": "Última"
    });
    write(` | <a href="javascript:recompute(\{page:'${next.toString()}'\})">${next_page}</a>`);
    write(` | <a href="javascript:recompute(\{page:'${pages.toString()}'\})">${last_page}</a>`);
    write(`</div>`);

    var cnt = page.subtract(BigInteger.ONE).multiply(new BigInteger(`${items_per_page}`,10)).add(BigInteger.ONE);
    var n;

    var compressed_wif = t({
        "en": "Compressed WIF",
        "pt-br": "WIF Comprimido",
    });

    var uncompressed_wif = t({
        "en": "Uncompressed WIF",
        "pt-br": "WIF Não-Comprimido",
    });

    var modes = [
        {
            name: "Decimal",
            length: 78,
            format: (bi,k1,k2) => bi.toFixed(10,78).replace(/^0+/,"<span class='leading_zeros'>$&</span>")
        },
        {
            name: "Hexadecimal",
            length: 64,
            format: (bi,k1,k2) => bi.toFixed(16,64).replace(/^0+/,"<span class='leading_zeros'>$&</span>")
        },
        {
            name: compressed_wif,
            length: 64,
            format: (bi,uk,ck) => (ck.getBitcoinWalletImportFormat(wif_prefix) + " ".repeat(20)).substr(0,64)
        },
        {
            name: uncompressed_wif,
            length: 64,
            format: (bi,uk,ck) => (uk.getBitcoinWalletImportFormat(wif_prefix) + " ".repeat(20)).substr(0,64)
        }
    ];

    var ec2addr = (key,ver) => (key.getBitcoinAddress(ver)+" ").substr(0,34);
    var len = 34;
    if (versions[network_version].segwit) {
        var format = versions[network_version].bech32 ? "p2wpkh" : "p2wpkh-p2sh";
        var prefix = versions[network_version].prefix;
        if (format=="p2wpkh") len = 40+prefix.length;
        ec2addr = (key,ver) => (key.getBitcoinAddress(ver,format,prefix)+" ").substr(0, len)
    }
    if (versions[network_version].cashaddr) {
        len = 42;
        ec2addr = (key,ver) => bchaddr.toCashAddress(key.getBitcoinAddress(ver)).substr(12,42);
    }

    var key_mode = parseInt(sessionStorage.getItem("key_mode") || "0");
    var key_title = t({
           "en": `-- Private Key (in ${modes[key_mode].name}) `,
        "pt-br": `-- Chave Privada (em ${modes[key_mode].name}) `
    });
    key_title += "-".repeat(modes[key_mode].length - key_title.length);
    var app = versions[network_version].app;
    text = t({
        "en": `Click to switch to different notations. The WIF formats can be use to import the keys to wallet apps such as ${app}`,
        "pt-br": `Clique para alternar para diferentes notações. Os formatos WIF podem ser usados para importar as chaves dentro de apps de carteira tais como o ${app}`
    });
    key_title  = key_title.replace(/[(](\S+) (.*?)[)]/,`($1 <span class="tooltip notation">$2<span class="tooltiptext">${text}</span></span>)`);
    var next_mode = (key_mode + 1) % modes.length;

    var c_title  = t({
        "en": "-- Compressed Address ",
        "pt-br": "-- Endereço Comprimido ",
    });
    c_title += "-".repeat(len-c_title.length);

    var u_title  = t({
        "en": "-- Uncompressed Address ",
        "pt-br": "-- Endereço Não-Comprimido ",
    });
    u_title += "-".repeat(len-u_title.length);

    var compressed = parseInt(sessionStorage.getItem("compressed")||0);

    var r_title  = t({
        "en": compressed ? "-- Address (Compressed) " : "-- Address (Uncompressed) ",
        "pt-br": compressed ? "-- Endereço (Comprimido) " : "-- Endereço (Não-Comprimido) ",
    });
    r_title += "-".repeat(len-r_title.length);

    text = t({
        "en": `Click to switch between compressed and uncompressed modes.`,
        "pt-br": `Clique para alternar entre o modo comprimido e não-comprimido.`
    });

    r_title  = r_title.replace(/(\(\S+\))/,`<span class='tooltip notation'>$1<span class='tooltiptext'>${text}</span></span>`);


    write(`<pre id='pre'>`);
    write(t({
        "en": `<i>          If there's a balance in any of those addresses below...       ${" ".repeat((modes[key_mode].length-64)/2+len-34)}  ...we can spend it because we have its corresponding private key   </i>\n`,
        "pt-br": `<i>          Se tiver saldo em qualquer um desses endereços abaixo...      ${" ".repeat((modes[key_mode].length-64)/2+len-34)}  ...podemos gastá-lo porque temos a chave privada correspondente    </i>\n`
    }));
    write(`<span class="line"><span class="short" onclick="javascript:recompute(\{compressed:${compressed?0:1},page:'1'\});">${r_title}  </span><span class="long">${c_title}  ${u_title}  </span><span onclick="javascript:recompute(\{key_mode:${next_mode}\});">${key_title}</span></span>\n`);
    var hflag    = hflags[network_version] || {};
    for (n=0;n<items_per_page;n++) {
        if (cnt.compareTo(max)>=0) break;
        var key1  = new Bitcoin.ECKey(cnt);
        var ver   = versions[network_version].value;
        var addr1 = ec2addr(key1.setCompressed(true),ver);
        var key2  = new Bitcoin.ECKey(cnt);
        var addr2 = ec2addr(key2.setCompressed(false),ver);
        var xtra  = cnt.compareTo(hilite) ? "" : "id='hilite' ";
        var addr  = compressed ? addr1 : addr2;
        var plus  = cnt.toString();
        var minus = max.subtract(cnt).toString();
        var c    = 1;
        var u    = 2;
        var hf   = hflag[plus];
        if (!hf) {
            hf = hflag[minus];
            c = 4;
            u = 8;
        }
        var prettify1 = versions[network_version].prettify;
        if (hf&c) {
            prettify1 = (addr) => {
                var p  = versions[network_version].prettify;
                if (!p) p = (x) => x;
                var sa = `<a href="https://web.archive.org/web/20220428024327/https://blockchain.com/btc/address/${addr1}" target="out">`;
                var ea = `</a>`;
                var trimmed = addr.replace(/\s+$/,"");
                return sa + p(trimmed) + ea + " ".repeat(addr.length-trimmed.length);
            }
        }
        var prettify2 = versions[network_version].prettify;
        if (hf&u) {
            prettify2 = (addr) => {
                var p  = versions[network_version].prettify;
                if (!p) p = (x) => x;
                var sa = `<a href="https://web.archive.org/web/20220428024327/https://blockchain.com/btc/address/${addr2}" target="out">`;
                var ea = `</a>`;
                var trimmed = addr.replace(/\s+$/,"");
                return sa + p(trimmed) + ea + " ".repeat(addr.length-trimmed.length);
            }
        }
        var prettify = compressed ? prettify1 : prettify2;
        write(`<span class="line"${xtra}><span class="short">${prettify(addr)}  </span><span class="long">${prettify1(addr1)}  ${prettify2(addr2)}  </span><span class="priv_key">${modes[key_mode].format(cnt,key2,key1)}</span></span>\n`);
        var key = cnt.toString();
        cnt = cnt.add(BigInteger.ONE);
    }

    var btc_addr = `14ZZtH4PBUyX19yEmGxnkZ79AhfLpRgmnL`;
    var bch_addr = `qqn5g8y3txp7v2nv8xvm679qzxnncu4zqsj070xd2f`;
    var qr_btc   = `https://chart.googleapis.com/chart?cht=qr&chs=300x300&chl=bitcoin:${btc_addr}`;
    var qr_bch   = `https://chart.googleapis.com/chart?cht=qr&chs=300x300&chl=BITCOINCASH:${bch_addr.toUpperCase()}`;
    write(`</pre><div id="footer">`);
    write(t({
        "en": `<div>Like it? Tip jar: <tt class="qrtip">${btc_addr}<span class="qrtipimg"><img src="${qr_btc}"/></span></tt> or <tt class="qrtip">${bch_addr}<span class="qrtipimg"><img src="${qr_bch}"/></span></tt></div><div>Feedback? Send to: <tt><b>allkeys</b></tt> <i>at</i> <tt><b>coinwise</b></tt> <i>dot</i> <tt><b>io</b></tt></div>`,
        "pt-br": `<div>Curtiu? Gorjetas: <tt class="qrtip">${btc_addr}<span class="qrtipimg"><img src="${qr_btc}"/></span></tt> ou <tt class="qrtip">${bch_addr}<span class="qrtipimg"><img src="${qr_bch}"/></span></tt></div><div>Comentários? Mande pra: <tt><b>allkeys</b></tt> <i>at</i> <tt><b>coinwise</b></tt> <i>dot</i> <tt><b>io</b></tt></div>`
    }));
    write(`</div></center>`);

    write(`<div id="search">`);
    write(`</div>`);

    document.getElementById('contents').innerHTML = html;

    var langs = [
        { value: 'en',     desc: 'English'   },
        { value: 'pt-br',  desc: 'Português' },
    ];
    var current_lang = (sessionStorage.getItem("lang") || navigator.language || "en").toLowerCase();
    html = `<select onchange='javascript:recompute({lang:this.value});'>`;
    langs.forEach( (lang) => {
        html += `<option value="${lang.value}" ${current_lang==lang.value?"selected":""}>${lang.desc}</option>`;
    });
    html += "</select>"
    document.getElementById('langbox').innerHTML = html;

    html = "";

    //if (window.orientation !== undefined) {
    //  document.body.classList.add("mobile");
    //}

    if (!localStorage.getItem("agreed")) {
        text = t({
            "en": `<button id='agree_button' onclick='javascript:recompute({agreed:"yes"})'>I Agree</button><button id='agree_button' onclick='javascript:recompute({agreed:"no"})'>I Disagree</button><div id="terms">We use <a href="https://web.archive.org/web/20220428024327/https://en.wikipedia.org/wiki/HTTP_cookie" target="out">Cookies</a> in conjunction with <a href="https://web.archive.org/web/20220428024327/https://analytics.google.com/" target="out">Google Analytics</a> to get a rough idea of how many people visit this site, where they come from (IP address and IP-based geolocation), and what kind of devices/displays they have so we can improve this site for best experience. Apart from that, we do not collect any other data.</div>`,
            "pt-br": `<button id='agree_button' onclick='javascript:recompute({agreed:"yes"})'>Aceito</button><button id='agree_button' onclick='javascript:recompute({agreed:"no"})'>Não Aceito</button><div id="terms">Usamos <a href="https://web.archive.org/web/20220428024327/https://pt.wikipedia.org/wiki/Cookie_(inform%C3%A1tica)" target="out">Cookies</a> em conjunto com o <a href="https://web.archive.org/web/20220428024327/https://analytics.google.com/" target="out">Google Analytics</a> para obter uma ideia geral de quantas pessoas visitam o site, de onde elas acessam (endereço IP e geolocalização por IP) e qual tipo de dispositivo/tela eles têm para que possamos otimizar a experiência de uso. Fora isso, não coletamos nenhum outro dado.</div>`
        })
        document.getElementById('privacy').innerHTML = text;
        document.getElementById('privacy').style.visibility = 'visible';
        document.getElementById('modal').style.visibility = 'visible';
    }

    if (location.hostname != "localhost" && location.hostname.substr(0,4) != "127." && location.protocol != "file:" && localStorage.getItem("agreed")=="yes") {
        var s = document.createElement("script");
        s.type = "text/javascript";
        s.src = "https://web.archive.org/web/20220428024327/https://www.googletagmanager.com/gtag/js?id=UA-145680170-1";
        document.body.append(s);
        gtag('js', new Date());
        gtag('config', 'UA-145680170-1');
    }

    var s = document.createElement("script");
    s.type = "text/javascript";
    s.src = "https://web.archive.org/web/20220428024327/https://cdn.jsdelivr.net/npm/tar-stream@2.1.0/index.min.js";
}

recompute();

function clear_errmsg() {
    document.getElementById("errmsg").innerHTML = "&nbsp;";
}

function hide_search_dialog()
{
    document.getElementById('modal').style.visibility = 'hidden';
    document.getElementById('all').style.visibility = 'hidden';
    document.getElementById('search').style.visibility = 'hidden';
}

function search_dialog() {
    clear_errmsg();
    document.getElementById('modal').style.visibility = 'visible';
    document.getElementById('all').style.visibility = 'visible';
    document.getElementById('search').style.visibility = 'visible';
    //document.getElementById('processing').style.display = 'none';
    document.getElementById('searchbox').value = "";
    document.getElementById('searchbox').onclick = (e) => {
        e.stopPropagation();  clear_errmsg();
    };
    document.getElementById('searchbox').onkeydown = (e) => {
        clear_errmsg();
        if (e.which==27) hide_search_dialog();
        if (e.which==13) search();
    };
    document.getElementById('random_button').onclick = (e) => {
        e.stopPropagation();
        var x = crypto.getRandomValues(new Uint8Array(32));
        var r = (new BigInteger(x))
              .mod(max.subtract(BigInteger.ONE))
              .add(BigInteger.ONE);
        document.getElementById('searchbox').value = r.toString();
    };
    document.getElementById('searchbox').focus();
    document.getElementById('all').onclick = hide_search_dialog;
}

function search()
{
    var value = document.getElementById('searchbox').value;
    value = value.replace(/^\s+/,"").replace(/\s+$/,"");
    if (value.substr(0,1) == '"') {
        var l = value.length-1;
        if (value.substr(l,1) == '"') l--;
         document.getElementById('searchbox').value = "0x" + Crypto.SHA256(value.substr(1,l));
         return;
    }
    if (value.substr(0,1) == "#") {
        var neg = value.substr(1,1)=="-";
        value  = value.substr(1).replace(/[^\d]/g,"");
        hilite = BigInteger.ZERO;
        var page = new BigInteger(value,10);
        if (!page.compareTo(BigInteger.ZERO)) value="1";
        if (neg) page = page.add(pages);
        if (page.compareTo(pages)>0) value = pages.toString();
        recompute({page:value});
        gtag("event","search",{
            'event_category': 'private_key',
            'event_label': 'page'
        });
        return;
    }
    if ( [33,34,42,43].find((x)=>x==value.length) && value.match(/[a-z]/i) ) {
        var n;
        var network_version = -1;
        for (n=0;n<versions.length;n++) { // >
            if (value.substr(0,versions[n].prefix.length) == versions[n].prefix) {
                network_version = n; break;
            }
        }
        if (network_version<0) { // >
            document.getElementById("errmsg").innerHTML = t({
                "en": "Unrecognized address type",
                "pt-br": "Tipo de endereço desconhecido"
            });
            gtag("event","search",{
                'event_category': 'address',
                'event_label': `(unrecognized address type)`
            });
            document.getElementById('hilite').style.visibility = 'hidden';
            return;
        }
        if (versions[network_version].cashaddr) {
            if (!bchaddr.isValidAddress(value)) {
                document.getElementById("errmsg").innerHTML = t({
                    "en": "Invalid CashAddress",
                    "pt-br": "Endereço CashAddress inválido"
                });
                gtag("event","search",{
                    'event_category': 'address',
                    'event_label': `${network_version} (bad cashaddr)`
                });
                document.getElementById('hilite').setAttribute("id","");
                return;
            }
            value = bchaddr.toLegacyAddress(value);
        }
        var addr;
        try {
            addr = new Bitcoin.Address(value);
        } catch(e) {
            document.getElementById("errmsg").innerHTML = t({
                "en": "Invalid address, bad checksum",
                "pt-br": "Endereço inválido, dígitos verificadores não conferem"
            });
            gtag("event","search",{
                'event_category': 'address',
                'event_label': `${network_version} (bad checksum)`
            });
            document.getElementById('hilite').setAttribute("id","");
            return;
        }
        function do_search(hash,map) {
            var target = hash.toString("hex").toLowerCase();
            var idx = (hash[0]<<4)|(hash[1]>>4);
            value = "";
            var candidate = 0;
            map[idx].forEach( (i) => {
                candidate += i;
                var pos   = new BigInteger(`${candidate}`);
                var key1  = new Bitcoin.ECKey(pos);
                var hash1 = key1.setCompressed(true).getPubKeyHash().toString("hex").toLowerCase();
                var key2  = new Bitcoin.ECKey(pos);
                var hash2 = key2.setCompressed(false).getPubKeyHash().toString("hex").toLowerCase();
                if (target == hash1 || target == hash2) value = `${candidate}`;
                var neg   = max.subtract(pos);
                var key3  = new Bitcoin.ECKey(neg);
                var hash3 = key3.setCompressed(true).getPubKeyHash().toString("hex").toLowerCase();
                var key4  = new Bitcoin.ECKey(neg);
                var hash4 = key4.setCompressed(false).getPubKeyHash().toString("hex").toLowerCase();
                if (target == hash3 || target == hash4) value = neg.toString();
            });
            document.getElementById('processing').style.display = 'none';
            if (value == "") {
                document.getElementById("errmsg").innerHTML = t({
                    "en": "Address not found within the index",
                    "pt-br": "Endereço não encontrado no índice"
                });
                gtag("event","search",{
                    'event_category': 'address',
                    'event_label': `(not found)`
                });
                hilite = BigInteger.ZERO;
                document.getElementById('hilite').setAttribute("id","");
                return;
            }
            hilite   = new BigInteger(value,10);
            var page = hilite.subtract(BigInteger.ONE)
                             .divide(new BigInteger(`${items_per_page}`,10))
                             .add(BigInteger.ONE);
            if (page.compareTo(pages)>0) page = pages;
            recompute({page,network_version});
            return;
        }
        document.getElementById('processing').style.display = 'block';
        var idx1 = addr.hash[2];
        var idx0 = (addr.hash[3]<<2)|((addr.hash[4]>>6)&0x3);
        var fname = ("000"+idx0).substr(-4);
        fetch(`index/${fname}.dat`,{
            'headers': {
                "Range": "bytes=0-511"
            }
        }).then( (res) => {
            if (res.status == 206) {
                return res.arrayBuffer();
            } else {
                do_search(addr.hash,addrmap);
                return;
            }
        }).then( (res) => {
            var data = new Uint16Array(res);
            var pos  = 512;
            var len  = 0;
            var n;
            for (n=0;n<=idx1;n++) { // >
                pos += len;
                len  = data[n]+32768;
            }
            fetch(`index/${fname}.dat`,{
                'headers': {
                    "Range": `bytes=${pos}-${pos+len}`
                }
            }).then( (res) => {
                if (res.status == 206) {
                    return res.arrayBuffer();
                } else {
                    return bzdata;
                }
            }).then( (res) => {
                var map;
                try {
                    var text = "";
                    var data = new Uint8Array(res);
                    for (n=0;n<data.length;n++) { // >
                        text += String.fromCharCode(data[n]);
                    }
                    text = ArchUtils.bz2.decode(text);
                    map = JSON.parse(text);
                } catch(e) {
                    map = addrmap;
                }
                do_search(addr.hash,map);
            }).catch( (e) => {
                do_search(addr.hash,addrmap);
            });
        }).catch( (e) => {
            do_search(addr.hash,addrmap);
            return;
        });
        return;
    }
    var network_version = -1;
    var key_mode = 0;
    if (value.length == 52 || value.length == 51 && value.match(/[a-z]/i)) {
        var key = new Bitcoin.ECKey(value);
        if (key.priv) {
            var n;
            for (n=0; n<versions.length ; n++) {  // >
                if (key.wif_version == versions[n].wif) {
                    network_version = n;
                    key_mode = value.length == 51 ? 3 : 2;
                    break;
                }
            }
            value = key.priv.toString();
        } else {
            document.getElementById("errmsg").innerHTML = t({
                "en": "Invalid WIF, bad checksum",
                "pt-br": "WIF inválido, dígitos verificadores não conferem"
            });
            gtag("event","search",{
                'event_category': 'private_key',
                'event_label': `${modes[key_mode]} (bad checksum)`
            });
            hilite = BigInteger.ZERO;
            document.getElementById('hilite').style.visibility = 'hidden';
            return;
        }
    }
    var base = 10;
    if (value.substr(0,2)=="0x") {
        base = 16;
        value = value.substr(2);
        key_mode = 1;
    }
    hilite   = new BigInteger(value,base);
    var is0  = hilite.compareTo(BigInteger.ZERO);
    if (is0<0) hilite = max.add(hilite); // >
    var page = hilite.subtract(BigInteger.ONE)
                     .divide(new BigInteger(`${items_per_page}`,10))
                     .add(BigInteger.ONE);
    if (page.compareTo(pages)>0) page = pages;
    if (network_version>=0) {
        recompute({page,network_version,key_mode});
    } else {
        recompute({page,key_mode});
    }
    var modes = ["Decimal","Hex","Compressed WIF","Uncompressed WIF"];
    gtag("event","search",{
        'event_category': 'private_key',
        'event_label': modes[key_mode]
    });
}

function pretty_align(value,width,ptbr)
{
    var s = value.split("").reverse().join("");
        s = s.replace(/\d\d\d/g,(x) => `${x},`);
        s = s.split("").reverse().join("").replace(/^,/,"");
    var lang = (sessionStorage.getItem("lang") || navigator.language || "en").toLowerCase();
    if (lang.substr(0,2)=="pt") {
        s = s.replace(/\./,";").replace(/,/g,".").replace(/;/,",");
    }
    if (s.length<width) {
        s = " ".repeat(width-s.length) + s;
    }
    return s;
}

function t(msgs)
{
    var lang = (sessionStorage.getItem("lang") || navigator.language || "en").toLowerCase();
    return msgs[lang] || msgs["en"];
}

function write(string) {
    html += string;
}
</script>
</body>
</html>
<!--
     FILE ARCHIVED ON 02:43:27 Apr 28, 2022 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 01:43:44 Apr 22, 2023.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
-->
<!--
playback timings (ms):
  captures_list: 196.227 (11)
  exclusion.robots: 0.195
  exclusion.robots.policy: 0.184
  cdx.remote: 0.064
  esindex: 0.008
  LoadShardBlock: 136.756 (3)
  PetaboxLoader3.datanode: 286.323 (5)
  load_resource: 272.877
  PetaboxLoader3.resolve: 102.13
  loaddict: 82.102
-->
